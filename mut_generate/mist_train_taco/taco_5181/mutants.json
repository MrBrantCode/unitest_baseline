{
  "task_id": "taco_5181",
  "entry_point": "count_good_strings",
  "mutant_count": 135,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 - 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 * 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 1\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = -1\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 1\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return count % MOD",
      "mutated_line": "return count * MOD",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return count % MOD",
      "mutated_line": "return count + MOD",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count + MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 * 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 + 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 8\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 6\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 0\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 1\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + -7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "Len = len(S) - 1",
      "mutated_line": "Len = len(S) + 1",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) + 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "Len = len(S) - 1",
      "mutated_line": "Len = len(S) * 1",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) * 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = 1",
      "mutated_line": "d = 2",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 2\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = 1",
      "mutated_line": "d = 0",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 0\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = 1",
      "mutated_line": "d = 0",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 0\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = 1",
      "mutated_line": "d = -1",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = -1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len - 2 * d > 0:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d > 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len - 2 * d < 0:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d < 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len - 2 * d == 0:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d == 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "d += 1",
      "mutated_line": "d -= 1",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d -= 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return False\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return False\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'",
      "mutated_line": "alphabet = 'a' if A != 1 else 'ab' if A == 2 else 'abc'",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A != 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'",
      "mutated_line": "alphabet = '' if A == 1 else 'ab' if A == 2 else 'abc'",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = '' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if is_good(t) and hamming_distance(s, t) <= K:",
      "mutated_line": "if is_good(t) or hamming_distance(s, t) <= K:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) or hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count -= 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 11 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 9 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 0 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 1 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = -10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 10 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 8 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 0 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 1 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** -9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Len = len(S) - 1",
      "mutated_line": "Len = len(S) - 2",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 2\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Len = len(S) - 1",
      "mutated_line": "Len = len(S) - 0",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 0\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Len = len(S) - 1",
      "mutated_line": "Len = len(S) - 0",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 0\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Len = len(S) - 1",
      "mutated_line": "Len = len(S) - -1",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - -1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len + 2 * d >= 0:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len + 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len * (2 * d) >= 0:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len * (2 * d) >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len - 2 * d >= 1:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 1:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len - 2 * d >= -1:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= -1:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len - 2 * d >= 1:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 1:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] == S[Len - d] or S[Len] == S[Len - 2 * d]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] or S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d += 1",
      "mutated_line": "d += 2",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 2\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d += 1",
      "mutated_line": "d += 0",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 0\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d += 1",
      "mutated_line": "d += 0",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 0\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d += 1",
      "mutated_line": "d += -1",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += -1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'",
      "mutated_line": "alphabet = 'a' if A == 2 else 'ab' if A == 2 else 'abc'",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 2 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'",
      "mutated_line": "alphabet = 'a' if A == 0 else 'ab' if A == 2 else 'abc'",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 0 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'",
      "mutated_line": "alphabet = 'a' if A == 0 else 'ab' if A == 2 else 'abc'",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 0 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'",
      "mutated_line": "alphabet = 'a' if A == -1 else 'ab' if A == 2 else 'abc'",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == -1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'",
      "mutated_line": "alphabet = 'a' if A == 1 else 'ab' if A != 2 else 'abc'",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A != 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'",
      "mutated_line": "alphabet = 'a' if A == 1 else '' if A == 2 else 'abc'",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else '' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'",
      "mutated_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else ''",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else ''\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if is_good(t) and hamming_distance(s, t) <= K:",
      "mutated_line": "if is_good(t) and hamming_distance(s, t) < K:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) < K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if is_good(t) and hamming_distance(s, t) <= K:",
      "mutated_line": "if is_good(t) and hamming_distance(s, t) > K:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) > K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if is_good(t) and hamming_distance(s, t) <= K:",
      "mutated_line": "if is_good(t) and hamming_distance(s, t) == K:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) == K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 2\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 0\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 0\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += -1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len - 2 / d >= 0:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 / d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len - (2 + d) >= 0:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - (2 + d) >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len - 2 ** d >= 0:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 ** d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] != S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] != S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] == S[Len - d] and S[Len] != S[Len - 2 * d]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] != S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return True\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, Len):",
      "mutated_line": "for j in range(i - 1, Len):",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i - 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, Len):",
      "mutated_line": "for j in range(i * 1, Len):",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i * 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if S[i] == S[j]:",
      "mutated_line": "if S[i] != S[j]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] != S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return sum(1 for a, b in zip(Str1, Str2) if a != b)",
      "mutated_line": "return sum((2 for (a, b) in zip(Str1, Str2) if a != b))",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((2 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return sum(1 for a, b in zip(Str1, Str2) if a != b)",
      "mutated_line": "return sum((0 for (a, b) in zip(Str1, Str2) if a != b))",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((0 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return sum(1 for a, b in zip(Str1, Str2) if a != b)",
      "mutated_line": "return sum((0 for (a, b) in zip(Str1, Str2) if a != b))",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((0 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return sum(1 for a, b in zip(Str1, Str2) if a != b)",
      "mutated_line": "return sum((-1 for (a, b) in zip(Str1, Str2) if a != b))",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((-1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'",
      "mutated_line": "alphabet = 'a' if A == 1 else 'ab' if A == 3 else 'abc'",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 3 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'",
      "mutated_line": "alphabet = 'a' if A == 1 else 'ab' if A == 1 else 'abc'",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 1 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'",
      "mutated_line": "alphabet = 'a' if A == 1 else 'ab' if A == 0 else 'abc'",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 0 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'",
      "mutated_line": "alphabet = 'a' if A == 1 else 'ab' if A == 1 else 'abc'",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 1 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'",
      "mutated_line": "alphabet = 'a' if A == 1 else 'ab' if A == -2 else 'abc'",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == -2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len - 3 * d >= 0:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 3 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len - 1 * d >= 0:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 1 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len - 0 * d >= 0:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 0 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len - 1 * d >= 0:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 1 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while Len - 2 * d >= 0:",
      "mutated_line": "while Len - -2 * d >= 0:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - -2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, Len):",
      "mutated_line": "for j in range(i + 2, Len):",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 2, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, Len):",
      "mutated_line": "for j in range(i + 0, Len):",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 0, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, Len):",
      "mutated_line": "for j in range(i + 0, Len):",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 0, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, Len):",
      "mutated_line": "for j in range(i + -1, Len):",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + -1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i < Len or S[i] == S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len or S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "return sum(1 for a, b in zip(Str1, Str2) if a != b)",
      "mutated_line": "return sum((1 for (a, b) in zip(Str1, Str2) if a == b))",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a == b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [''.join(p) for p in product(alphabet, repeat=length)]",
      "mutated_line": "return ['MUTATED'.join(p) for p in product(alphabet, repeat=length)]",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return ['MUTATED'.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] == S[Len + d] and S[Len] == S[Len - 2 * d]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len + d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] == S[Len * d] and S[Len] == S[Len - 2 * d]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len * d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] == S[Len - d] and S[Len] == S[Len + 2 * d]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len + 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] == S[Len - d] and S[Len] == S[Len * (2 * d)]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len * (2 * d)]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i <= Len and S[i] == S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i <= Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i >= Len and S[i] == S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i >= Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i != Len and S[i] == S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i != Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i < Len and S[i] != S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] != S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return True\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 / d]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 / d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - (2 + d)]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - (2 + d)]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 ** d]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 ** d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j + i < Len and S[i] == S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j + i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j * i < Len and S[i] == S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j * i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 3 * d]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 3 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 1 * d]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 1 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 0 * d]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 0 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 1 * d]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 1 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:",
      "mutated_line": "if S[Len] == S[Len - d] and S[Len] == S[Len - -2 * d]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - -2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 / j - i < Len and S[i] == S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 / j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 + j - i < Len and S[i] == S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 + j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 ** j - i < Len and S[i] == S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 ** j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i < Len and S[i] == S[2 * j + i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j + i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i < Len and S[i] == S[2 * j * i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 * j * i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 3 * j - i < Len and S[i] == S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 3 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 1 * j - i < Len and S[i] == S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 1 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 0 * j - i < Len and S[i] == S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 0 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 1 * j - i < Len and S[i] == S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 1 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if -2 * j - i < Len and S[i] == S[2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if -2 * j - i < Len and S[i] == S[2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i < Len and S[i] == S[2 / j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 / j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i < Len and S[i] == S[2 + j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 + j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i < Len and S[i] == S[2 ** j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[2 ** j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i < Len and S[i] == S[3 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[3 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i < Len and S[i] == S[1 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[1 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i < Len and S[i] == S[0 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[0 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i < Len and S[i] == S[1 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[1 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2 * j - i < Len and S[i] == S[2 * j - i]:",
      "mutated_line": "if 2 * j - i < Len and S[i] == S[-2 * j - i]:",
      "code": "def count_good_strings(s: str, A: int, K: int) -> int:\n    MOD = 10 ** 9 + 7\n\n    def is_good(S: str) -> bool:\n        Len = len(S) - 1\n        d = 1\n        while Len - 2 * d >= 0:\n            if S[Len] == S[Len - d] and S[Len] == S[Len - 2 * d]:\n                return False\n            d += 1\n        return True\n\n    def is_ok(S: str) -> bool:\n        Len = len(S)\n        for i in range(Len):\n            for j in range(i + 1, Len):\n                if S[i] == S[j]:\n                    if 2 * j - i < Len and S[i] == S[-2 * j - i]:\n                        return False\n        return True\n\n    def hamming_distance(Str1: str, Str2: str) -> int:\n        return sum((1 for (a, b) in zip(Str1, Str2) if a != b))\n\n    def generate_strings(length: int, alphabet: str):\n        from itertools import product\n        return [''.join(p) for p in product(alphabet, repeat=length)]\n    alphabet = 'a' if A == 1 else 'ab' if A == 2 else 'abc'\n    all_strings = generate_strings(len(s), alphabet)\n    count = 0\n    for t in all_strings:\n        if is_good(t) and hamming_distance(s, t) <= K:\n            count += 1\n    return count % MOD"
    }
  ]
}