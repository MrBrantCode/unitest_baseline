{
  "task_id": "taco_9342",
  "entry_point": "is_lexicographically_sorted",
  "mutant_count": 73,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "blank_flag = False",
      "mutated_line": "blank_flag = True",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = True\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "visited = [0] * 26",
      "mutated_line": "visited = [0] / 26",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] / 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "visited = [0] * 26",
      "mutated_line": "visited = [0] + 26",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] + 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "visited = [0] * 26",
      "mutated_line": "visited = [0] ** 26",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] ** 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "cycle_flag = False",
      "mutated_line": "cycle_flag = True",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = True\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ind = 0",
      "mutated_line": "ind = 1",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 1\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ind = 0",
      "mutated_line": "ind = -1",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = -1\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ind = 0",
      "mutated_line": "ind = 1",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 1\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "LCR",
      "lineno": 5,
      "original_line": "while ind < max_len and s1[ind] == s2[ind]:",
      "mutated_line": "while ind < max_len or s1[ind] == s2[ind]:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len or s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "ind += 1",
      "mutated_line": "ind -= 1",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind -= 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if ind == max_len:",
      "mutated_line": "if ind != max_len:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind != max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "c1 = ord(s1[ind]) - ord('a')",
      "mutated_line": "c1 = ord(s1[ind]) + ord('a')",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) + ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "c1 = ord(s1[ind]) - ord('a')",
      "mutated_line": "c1 = ord(s1[ind]) * ord('a')",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) * ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "c2 = ord(s2[ind]) - ord('a')",
      "mutated_line": "c2 = ord(s2[ind]) + ord('a')",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) + ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "c2 = ord(s2[ind]) - ord('a')",
      "mutated_line": "c2 = ord(s2[ind]) * ord('a')",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) * ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return True\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ret = False",
      "mutated_line": "ret = True",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = True\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if visited[n] == 2:",
      "mutated_line": "if visited[n] != 2:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] != 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return True\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "visited = [0] * 26",
      "mutated_line": "visited = [0] * 27",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 27\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "visited = [0] * 26",
      "mutated_line": "visited = [0] * 25",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 25\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "visited = [0] * 26",
      "mutated_line": "visited = [0] * 0",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 0\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "visited = [0] * 26",
      "mutated_line": "visited = [0] * 1",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 1\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "visited = [0] * 26",
      "mutated_line": "visited = [0] * -26",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * -26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "cycle_flag = cycle_flag or visit(n, visited, adj_lst)",
      "mutated_line": "cycle_flag = cycle_flag and visit(n, visited, adj_lst)",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag and visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while ind < max_len and s1[ind] == s2[ind]:",
      "mutated_line": "while ind <= max_len and s1[ind] == s2[ind]:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind <= max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while ind < max_len and s1[ind] == s2[ind]:",
      "mutated_line": "while ind >= max_len and s1[ind] == s2[ind]:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind >= max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while ind < max_len and s1[ind] == s2[ind]:",
      "mutated_line": "while ind != max_len and s1[ind] == s2[ind]:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind != max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while ind < max_len and s1[ind] == s2[ind]:",
      "mutated_line": "while ind < max_len and s1[ind] != s2[ind]:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] != s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ind += 1",
      "mutated_line": "ind += 2",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 2\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ind += 1",
      "mutated_line": "ind += 0",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 0\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ind += 1",
      "mutated_line": "ind += 0",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 0\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ind += 1",
      "mutated_line": "ind += -1",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += -1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return max_len < len(s1)",
      "mutated_line": "return max_len <= len(s1)",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len <= len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return max_len < len(s1)",
      "mutated_line": "return max_len >= len(s1)",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len >= len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return max_len < len(s1)",
      "mutated_line": "return max_len != len(s1)",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len != len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if visited[n] == 2:",
      "mutated_line": "if visited[n] == 3:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 3:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if visited[n] == 2:",
      "mutated_line": "if visited[n] == 1:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 1:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if visited[n] == 2:",
      "mutated_line": "if visited[n] == 0:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 0:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if visited[n] == 2:",
      "mutated_line": "if visited[n] == 1:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 1:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if visited[n] == 2:",
      "mutated_line": "if visited[n] == -2:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == -2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return False\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif visited[n] == 0:",
      "mutated_line": "elif visited[n] != 0:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] != 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i - 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i * 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])",
      "mutated_line": "blank_flag = blank_flag and add_edge(node, adj_lst, words[i], words[j])",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag and add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "visited = [0] * 26",
      "mutated_line": "visited = [1] * 26",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [1] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "visited = [0] * 26",
      "mutated_line": "visited = [-1] * 26",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [-1] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "visited = [0] * 26",
      "mutated_line": "visited = [1] * 26",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [1] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c1 = ord(s1[ind]) - ord('a')",
      "mutated_line": "c1 = ord(s1[ind]) - ord('')",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "c2 = ord(s2[ind]) - ord('a')",
      "mutated_line": "c2 = ord(s2[ind]) - ord('')",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif visited[n] == 0:",
      "mutated_line": "elif visited[n] == 1:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 1:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif visited[n] == 0:",
      "mutated_line": "elif visited[n] == -1:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == -1:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif visited[n] == 0:",
      "mutated_line": "elif visited[n] == 1:",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 1:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "visited[n] = 2",
      "mutated_line": "visited[n] = 3",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 3\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "visited[n] = 2",
      "mutated_line": "visited[n] = 1",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 1\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "visited[n] = 2",
      "mutated_line": "visited[n] = 0",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 0\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "visited[n] = 2",
      "mutated_line": "visited[n] = 1",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 1\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "visited[n] = 2",
      "mutated_line": "visited[n] = -2",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = -2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "visited[n] = 1",
      "mutated_line": "visited[n] = 2",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 2\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "visited[n] = 1",
      "mutated_line": "visited[n] = 0",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 0\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "visited[n] = 1",
      "mutated_line": "visited[n] = 0",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 0\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "visited[n] = 1",
      "mutated_line": "visited[n] = -1",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = -1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "adj_lst = [set() for _ in range(26)]",
      "mutated_line": "adj_lst = [set() for _ in range(27)]",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(27)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "adj_lst = [set() for _ in range(26)]",
      "mutated_line": "adj_lst = [set() for _ in range(25)]",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(25)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "adj_lst = [set() for _ in range(26)]",
      "mutated_line": "adj_lst = [set() for _ in range(0)]",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(0)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "adj_lst = [set() for _ in range(26)]",
      "mutated_line": "adj_lst = [set() for _ in range(1)]",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(1)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "adj_lst = [set() for _ in range(26)]",
      "mutated_line": "adj_lst = [set() for _ in range(-26)]",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(-26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 2, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 0, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 0, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret or visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + -1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "ret = ret or visit(to, visited, adj_lst)",
      "mutated_line": "ret = ret and visit(to, visited, adj_lst)",
      "code": "def is_lexicographically_sorted(n, words):\n\n    def add_edge(node, adj_lst, s1, s2):\n        ind = 0\n        max_len = min(len(s1), len(s2))\n        while ind < max_len and s1[ind] == s2[ind]:\n            ind += 1\n        if ind == max_len:\n            return max_len < len(s1)\n        c1 = ord(s1[ind]) - ord('a')\n        c2 = ord(s2[ind]) - ord('a')\n        adj_lst[c1].add(c2)\n        node.add(c1)\n        node.add(c2)\n        return False\n\n    def visit(n, visited, adj_lst):\n        ret = False\n        if visited[n] == 2:\n            return True\n        elif visited[n] == 0:\n            visited[n] = 2\n            for to in adj_lst[n]:\n                ret = ret and visit(to, visited, adj_lst)\n            visited[n] = 1\n        return ret\n    node = set()\n    adj_lst = [set() for _ in range(26)]\n    blank_flag = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            blank_flag = blank_flag or add_edge(node, adj_lst, words[i], words[j])\n    if blank_flag:\n        return False\n    visited = [0] * 26\n    cycle_flag = False\n    for n in node:\n        cycle_flag = cycle_flag or visit(n, visited, adj_lst)\n    return not cycle_flag"
    }
  ]
}