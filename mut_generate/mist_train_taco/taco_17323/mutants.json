{
  "task_id": "taco_17323",
  "entry_point": "find_max_path_value",
  "mutant_count": 82,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "CurrentPosition = namedtuple('current_position', 'points, cell, pairs')",
      "mutated_line": "CurrentPosition = namedtuple('', 'points, cell, pairs')",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "CurrentPosition = namedtuple('current_position', 'points, cell, pairs')",
      "mutated_line": "CurrentPosition = namedtuple('current_position', '')",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', '')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "pos += explore(p)",
      "mutated_line": "pos -= explore(p)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos -= explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "new_pairs = p.pairs[:i] + p.pairs[i + 1:]",
      "mutated_line": "new_pairs = p.pairs[:i] - p.pairs[i + 1:]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] - p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "new_pairs = p.pairs[:i] + p.pairs[i + 1:]",
      "mutated_line": "new_pairs = p.pairs[:i] * p.pairs[i + 1:]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] * p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if px < R and py < C:",
      "mutated_line": "if px < R or py < C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R or py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "mutated_line": "next_pos -= [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos -= [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if px < R and 0 <= py:",
      "mutated_line": "if px < R or 0 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R or 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "mutated_line": "next_pos -= [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos -= [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if 0 <= px and py < C:",
      "mutated_line": "if 0 <= px or py < C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px or py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "mutated_line": "next_pos -= [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos -= [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if 0 <= px and 0 <= py:",
      "mutated_line": "if 0 <= px or 0 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px or 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "mutated_line": "next_pos -= [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos -= [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = pos.pop(0)",
      "mutated_line": "p = pos.pop(1)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(1)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = pos.pop(0)",
      "mutated_line": "p = pos.pop(-1)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(-1)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "p = pos.pop(0)",
      "mutated_line": "p = pos.pop(1)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(1)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(px, py) = (sx + dx, sy + dy)",
      "mutated_line": "(px, py) = (sx - dx, sy + dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx - dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(px, py) = (sx + dx, sy + dy)",
      "mutated_line": "(px, py) = (sx * dx, sy + dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx * dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(px, py) = (sx + dx, sy + dy)",
      "mutated_line": "(px, py) = (sx + dx, sy - dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(px, py) = (sx + dx, sy + dy)",
      "mutated_line": "(px, py) = (sx + dx, sy * dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy * dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if px < R and py < C:",
      "mutated_line": "if px <= R and py < C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px <= R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if px < R and py < C:",
      "mutated_line": "if px >= R and py < C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px >= R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if px < R and py < C:",
      "mutated_line": "if px != R and py < C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px != R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if px < R and py < C:",
      "mutated_line": "if px < R and py <= C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py <= C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if px < R and py < C:",
      "mutated_line": "if px < R and py >= C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py >= C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if px < R and py < C:",
      "mutated_line": "if px < R and py != C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py != C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(px, py) = (sx + dx, sy - dy)",
      "mutated_line": "(px, py) = (sx - dx, sy - dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(px, py) = (sx + dx, sy - dy)",
      "mutated_line": "(px, py) = (sx * dx, sy - dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx * dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(px, py) = (sx + dx, sy - dy)",
      "mutated_line": "(px, py) = (sx + dx, sy + dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(px, py) = (sx + dx, sy - dy)",
      "mutated_line": "(px, py) = (sx + dx, sy * dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy * dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if px < R and 0 <= py:",
      "mutated_line": "if px <= R and 0 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px <= R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if px < R and 0 <= py:",
      "mutated_line": "if px >= R and 0 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px >= R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if px < R and 0 <= py:",
      "mutated_line": "if px != R and 0 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px != R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if px < R and 0 <= py:",
      "mutated_line": "if px < R and 0 < py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 < py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if px < R and 0 <= py:",
      "mutated_line": "if px < R and 0 > py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 > py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if px < R and 0 <= py:",
      "mutated_line": "if px < R and 0 == py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 == py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "(px, py) = (sx - dx, sy + dy)",
      "mutated_line": "(px, py) = (sx + dx, sy + dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "(px, py) = (sx - dx, sy + dy)",
      "mutated_line": "(px, py) = (sx * dx, sy + dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx * dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "(px, py) = (sx - dx, sy + dy)",
      "mutated_line": "(px, py) = (sx - dx, sy - dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "(px, py) = (sx - dx, sy + dy)",
      "mutated_line": "(px, py) = (sx - dx, sy * dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy * dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 0 <= px and py < C:",
      "mutated_line": "if 0 < px and py < C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 < px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 0 <= px and py < C:",
      "mutated_line": "if 0 > px and py < C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 > px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 0 <= px and py < C:",
      "mutated_line": "if 0 == px and py < C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 == px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 0 <= px and py < C:",
      "mutated_line": "if 0 <= px and py <= C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py <= C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 0 <= px and py < C:",
      "mutated_line": "if 0 <= px and py >= C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py >= C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 0 <= px and py < C:",
      "mutated_line": "if 0 <= px and py != C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py != C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "(px, py) = (sx - dx, sy - dy)",
      "mutated_line": "(px, py) = (sx + dx, sy - dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "(px, py) = (sx - dx, sy - dy)",
      "mutated_line": "(px, py) = (sx * dx, sy - dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx * dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "(px, py) = (sx - dx, sy - dy)",
      "mutated_line": "(px, py) = (sx - dx, sy + dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "(px, py) = (sx - dx, sy - dy)",
      "mutated_line": "(px, py) = (sx - dx, sy * dy)",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy * dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if 0 <= px and 0 <= py:",
      "mutated_line": "if 0 < px and 0 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 < px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if 0 <= px and 0 <= py:",
      "mutated_line": "if 0 > px and 0 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 > px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if 0 <= px and 0 <= py:",
      "mutated_line": "if 0 == px and 0 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 == px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if 0 <= px and 0 <= py:",
      "mutated_line": "if 0 <= px and 0 < py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 < py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if 0 <= px and 0 <= py:",
      "mutated_line": "if 0 <= px and 0 > py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 > py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if 0 <= px and 0 <= py:",
      "mutated_line": "if 0 <= px and 0 == py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 == py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if px < R and 0 <= py:",
      "mutated_line": "if px < R and 1 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 1 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if px < R and 0 <= py:",
      "mutated_line": "if px < R and -1 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and -1 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if px < R and 0 <= py:",
      "mutated_line": "if px < R and 1 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 1 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 0 <= px and py < C:",
      "mutated_line": "if 1 <= px and py < C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 1 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 0 <= px and py < C:",
      "mutated_line": "if -1 <= px and py < C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if -1 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 0 <= px and py < C:",
      "mutated_line": "if 1 <= px and py < C:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 1 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if 0 <= px and 0 <= py:",
      "mutated_line": "if 1 <= px and 0 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 1 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if 0 <= px and 0 <= py:",
      "mutated_line": "if -1 <= px and 0 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if -1 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if 0 <= px and 0 <= py:",
      "mutated_line": "if 1 <= px and 0 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 1 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if 0 <= px and 0 <= py:",
      "mutated_line": "if 0 <= px and 1 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 1 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if 0 <= px and 0 <= py:",
      "mutated_line": "if 0 <= px and -1 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and -1 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if 0 <= px and 0 <= py:",
      "mutated_line": "if 0 <= px and 1 <= py:",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 1 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "new_pairs = p.pairs[:i] + p.pairs[i + 1:]",
      "mutated_line": "new_pairs = p.pairs[:i] + p.pairs[i - 1:]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i - 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "new_pairs = p.pairs[:i] + p.pairs[i + 1:]",
      "mutated_line": "new_pairs = p.pairs[:i] + p.pairs[i * 1:]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i * 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "mutated_line": "next_pos += [CurrentPosition(p.points - board[px][py], (px, py), new_pairs)]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points - board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "mutated_line": "next_pos += [CurrentPosition(p.points * board[px][py], (px, py), new_pairs)]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points * board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "mutated_line": "next_pos += [CurrentPosition(p.points - board[px][py], (px, py), new_pairs)]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points - board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "mutated_line": "next_pos += [CurrentPosition(p.points * board[px][py], (px, py), new_pairs)]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points * board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "mutated_line": "next_pos += [CurrentPosition(p.points - board[px][py], (px, py), new_pairs)]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points - board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "mutated_line": "next_pos += [CurrentPosition(p.points * board[px][py], (px, py), new_pairs)]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points * board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "mutated_line": "next_pos += [CurrentPosition(p.points - board[px][py], (px, py), new_pairs)]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points - board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]",
      "mutated_line": "next_pos += [CurrentPosition(p.points * board[px][py], (px, py), new_pairs)]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points * board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "new_pairs = p.pairs[:i] + p.pairs[i + 1:]",
      "mutated_line": "new_pairs = p.pairs[:i] + p.pairs[i + 2:]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 2:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "new_pairs = p.pairs[:i] + p.pairs[i + 1:]",
      "mutated_line": "new_pairs = p.pairs[:i] + p.pairs[i + 0:]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 0:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "new_pairs = p.pairs[:i] + p.pairs[i + 1:]",
      "mutated_line": "new_pairs = p.pairs[:i] + p.pairs[i + 0:]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + 0:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "new_pairs = p.pairs[:i] + p.pairs[i + 1:]",
      "mutated_line": "new_pairs = p.pairs[:i] + p.pairs[i + -1:]",
      "code": "from collections import namedtuple\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\ndef find_max_path_value(R, C, N, Sx, Sy, dx, dy, board):\n    tel_pairs = list(zip(dx, dy))\n\n    def explore(p):\n        next_pos = []\n        for (i, (dx, dy)) in enumerate(p.pairs):\n            (sx, sy) = p.cell\n            new_pairs = p.pairs[:i] + p.pairs[i + -1:]\n            (px, py) = (sx + dx, sy + dy)\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx + dx, sy - dy)\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy + dy)\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n            (px, py) = (sx - dx, sy - dy)\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points + board[px][py], (px, py), new_pairs)]\n        return next_pos\n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n    return result"
    }
  ]
}