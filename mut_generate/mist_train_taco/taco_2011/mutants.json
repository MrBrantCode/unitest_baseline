{
  "task_id": "taco_2011",
  "entry_point": "bounded_pow",
  "mutant_count": 101,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i -= 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIM = 60",
      "mutated_line": "LIM = 61",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 61\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIM = 60",
      "mutated_line": "LIM = 59",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 59\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIM = 60",
      "mutated_line": "LIM = 0",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 0\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIM = 60",
      "mutated_line": "LIM = 1",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 1\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIM = 60",
      "mutated_line": "LIM = -60",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = -60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if b * math.log(a) > LOG_LIM:",
      "mutated_line": "if b * math.log(a) >= LOG_LIM:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) >= LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if b * math.log(a) > LOG_LIM:",
      "mutated_line": "if b * math.log(a) <= LOG_LIM:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) <= LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if b * math.log(a) > LOG_LIM:",
      "mutated_line": "if b * math.log(a) != LOG_LIM:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) != LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "nxt = [0] * (n + 1)",
      "mutated_line": "nxt = [0] / (n + 1)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] / (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "nxt = [0] * (n + 1)",
      "mutated_line": "nxt = [0] + (n + 1)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] + (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "nxt = [0] * (n + 1)",
      "mutated_line": "nxt = [0] ** (n + 1)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] ** (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if i == j or a[i] <= 1:",
      "mutated_line": "if i == j and a[i] <= 1:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j and a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 2\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 0\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 0\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += -1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "while j > i and p < 60:",
      "mutated_line": "while j > i or p < 60:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i or p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "j -= 1",
      "mutated_line": "j += 1",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j += 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "return pow(x, p, mod) == 0",
      "mutated_line": "return pow(x, p, mod) != 0",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) != 0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "LOG_LIM = math.log(LIM * 2)",
      "mutated_line": "LOG_LIM = math.log(LIM / 2)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM / 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "LOG_LIM = math.log(LIM * 2)",
      "mutated_line": "LOG_LIM = math.log(LIM + 2)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM + 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "LOG_LIM = math.log(LIM * 2)",
      "mutated_line": "LOG_LIM = math.log(LIM ** 2)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM ** 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if b * math.log(a) > LOG_LIM:",
      "mutated_line": "if b / math.log(a) > LOG_LIM:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b / math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if b * math.log(a) > LOG_LIM:",
      "mutated_line": "if b + math.log(a) > LOG_LIM:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b + math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if b * math.log(a) > LOG_LIM:",
      "mutated_line": "if b ** math.log(a) > LOG_LIM:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b ** math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "nxt = [0] * (n + 1)",
      "mutated_line": "nxt = [0] * (n - 1)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n - 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "nxt = [0] * (n + 1)",
      "mutated_line": "nxt = [0] * (n * 1)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n * 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n + 1, -1, -1):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n + 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n * 1, -1, -1):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n * 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n - 1, +1, -1):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, +1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n - 1, -1, +1):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, +1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if a[k] <= 1:",
      "mutated_line": "if a[k] < 1:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] < 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if a[k] <= 1:",
      "mutated_line": "if a[k] > 1:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] > 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if a[k] <= 1:",
      "mutated_line": "if a[k] == 1:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] == 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i == j or a[i] <= 1:",
      "mutated_line": "if i != j or a[i] <= 1:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i != j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i == j or a[i] <= 1:",
      "mutated_line": "if i == j or a[i] < 1:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] < 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i == j or a[i] <= 1:",
      "mutated_line": "if i == j or a[i] > 1:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] > 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i == j or a[i] <= 1:",
      "mutated_line": "if i == j or a[i] == 1:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] == 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "return a[i] % mod == 0",
      "mutated_line": "return a[i] % mod != 0",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod != 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while j > i and p < 60:",
      "mutated_line": "while j >= i and p < 60:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j >= i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while j > i and p < 60:",
      "mutated_line": "while j <= i and p < 60:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j <= i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while j > i and p < 60:",
      "mutated_line": "while j != i and p < 60:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j != i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while j > i and p < 60:",
      "mutated_line": "while j > i and p <= 60:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p <= 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while j > i and p < 60:",
      "mutated_line": "while j > i and p >= 60:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p >= 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while j > i and p < 60:",
      "mutated_line": "while j > i and p != 60:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p != 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j -= 1",
      "mutated_line": "j -= 2",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 2\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 0\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j -= 1",
      "mutated_line": "j -= 0",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 0\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "j -= 1",
      "mutated_line": "j -= -1",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= -1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return pow(x, p, mod) == 0",
      "mutated_line": "return pow(x, p, mod) == 1",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return pow(x, p, mod) == 0",
      "mutated_line": "return pow(x, p, mod) == -1",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return pow(x, p, mod) == 0",
      "mutated_line": "return pow(x, p, mod) == 1",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "LOG_LIM = math.log(LIM * 2)",
      "mutated_line": "LOG_LIM = math.log(LIM * 3)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 3)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "LOG_LIM = math.log(LIM * 2)",
      "mutated_line": "LOG_LIM = math.log(LIM * 1)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 1)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "LOG_LIM = math.log(LIM * 2)",
      "mutated_line": "LOG_LIM = math.log(LIM * 0)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 0)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "LOG_LIM = math.log(LIM * 2)",
      "mutated_line": "LOG_LIM = math.log(LIM * 1)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 1)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "LOG_LIM = math.log(LIM * 2)",
      "mutated_line": "LOG_LIM = math.log(LIM * -2)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * -2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nxt = [0] * (n + 1)",
      "mutated_line": "nxt = [1] * (n + 1)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [1] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nxt = [0] * (n + 1)",
      "mutated_line": "nxt = [-1] * (n + 1)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [-1] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nxt = [0] * (n + 1)",
      "mutated_line": "nxt = [1] * (n + 1)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [1] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nxt = [0] * (n + 1)",
      "mutated_line": "nxt = [0] * (n + 2)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 2)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nxt = [0] * (n + 1)",
      "mutated_line": "nxt = [0] * (n + 0)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 0)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nxt = [0] * (n + 1)",
      "mutated_line": "nxt = [0] * (n + 0)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 0)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nxt = [0] * (n + 1)",
      "mutated_line": "nxt = [0] * (n + -1)",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + -1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n - 2, -1, -1):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 2, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n - 0, -1, -1):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 0, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n - 0, -1, -1):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 0, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n - -1, -1, -1):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - -1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n - 1, -2, -1):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -2, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n - 1, -0, -1):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -0, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n - 1, -0, -1):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -0, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n - 1, --1, -1):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, --1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n - 1, -1, -2):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -2):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n - 1, -1, -0):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -0):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n - 1, -1, -0):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -0):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for k in range(n - 1, -1, -1):",
      "mutated_line": "for k in range(n - 1, -1, --1):",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, --1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if a[k] <= 1:",
      "mutated_line": "if a[k] <= 2:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 2:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if a[k] <= 1:",
      "mutated_line": "if a[k] <= 0:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 0:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if a[k] <= 1:",
      "mutated_line": "if a[k] <= 0:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 0:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if a[k] <= 1:",
      "mutated_line": "if a[k] <= -1:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= -1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i == j or a[i] <= 1:",
      "mutated_line": "if i == j or a[i] <= 2:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 2:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i == j or a[i] <= 1:",
      "mutated_line": "if i == j or a[i] <= 0:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 0:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i == j or a[i] <= 1:",
      "mutated_line": "if i == j or a[i] <= 0:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 0:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i == j or a[i] <= 1:",
      "mutated_line": "if i == j or a[i] <= -1:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= -1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return a[i] % mod == 0",
      "mutated_line": "return a[i] * mod == 0",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] * mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return a[i] % mod == 0",
      "mutated_line": "return a[i] + mod == 0",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] + mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return a[i] % mod == 0",
      "mutated_line": "return a[i] % mod == 1",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 1\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return a[i] % mod == 0",
      "mutated_line": "return a[i] % mod == -1",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == -1\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return a[i] % mod == 0",
      "mutated_line": "return a[i] % mod == 1",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 1\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while j > i and p < 60:",
      "mutated_line": "while j > i and p < 61:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 61:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while j > i and p < 60:",
      "mutated_line": "while j > i and p < 59:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 59:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while j > i and p < 60:",
      "mutated_line": "while j > i and p < 0:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 0:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while j > i and p < 60:",
      "mutated_line": "while j > i and p < 1:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 1:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while j > i and p < 60:",
      "mutated_line": "while j > i and p < -60:",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < -60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nxt[k] = nxt[k + 1]",
      "mutated_line": "nxt[k] = nxt[k - 1]",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k - 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nxt[k] = nxt[k + 1]",
      "mutated_line": "nxt[k] = nxt[k * 1]",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k * 1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "nxt[k] = nxt[k + 1]",
      "mutated_line": "nxt[k] = nxt[k + 2]",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 2]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "nxt[k] = nxt[k + 1]",
      "mutated_line": "nxt[k] = nxt[k + 0]",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 0]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "nxt[k] = nxt[k + 1]",
      "mutated_line": "nxt[k] = nxt[k + 0]",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + 0]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "nxt[k] = nxt[k + 1]",
      "mutated_line": "nxt[k] = nxt[k + -1]",
      "code": "import math\n\ndef bounded_pow(a, b):\n    LIM = 60\n    LOG_LIM = math.log(LIM * 2)\n    if b * math.log(a) > LOG_LIM:\n        return LIM\n    return min(pow(a, b), LIM)\n\ndef query_divisibility(a, i, j, mod):\n    n = len(a)\n    nxt = [0] * (n + 1)\n    nxt[n] = n\n    for k in range(n - 1, -1, -1):\n        if a[k] <= 1:\n            nxt[k] = k\n        else:\n            nxt[k] = nxt[k + -1]\n    if i == j or a[i] <= 1:\n        return a[i] % mod == 0\n    x = a[i]\n    i += 1\n    tmp = nxt[i]\n    j = min(j, tmp)\n    p = a[j]\n    while j > i and p < 60:\n        j -= 1\n        p = bounded_pow(a[j], p)\n    return pow(x, p, mod) == 0"
    }
  ]
}