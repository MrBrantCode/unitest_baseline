{
  "task_id": "taco_18285",
  "entry_point": "find_minimum_difficulty",
  "mutant_count": 251,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if k < 2:",
      "mutated_line": "if k <= 2:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k <= 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if k < 2:",
      "mutated_line": "if k >= 2:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k >= 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if k < 2:",
      "mutated_line": "if k != 2:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k != 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = float('inf')",
      "mutated_line": "INF = float('')",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if k < 2:",
      "mutated_line": "if k < 3:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 3:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if k < 2:",
      "mutated_line": "if k < 1:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 1:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if k < 2:",
      "mutated_line": "if k < 0:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 0:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if k < 2:",
      "mutated_line": "if k < 1:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 1:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if k < 2:",
      "mutated_line": "if k < -2:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < -2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 1\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return -1\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 1\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if (u, v) in cost:",
      "mutated_line": "if (u, v) not in cost:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) not in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k == 0:",
      "mutated_line": "if k != 0:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k != 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(2, n + 1):",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(2, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(0, n + 1):",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(0, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(0, n + 1):",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(0, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(-1, n + 1):",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(-1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n - 1):",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n - 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n * 1):",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n * 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans == INF else -1",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans == INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 54,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else +1",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else +1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 1:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k == 0:",
      "mutated_line": "if k == -1:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == -1:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 1:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 1\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return -1\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 1\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif k > e - s + 1:",
      "mutated_line": "elif k >= e - s + 1:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k >= e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif k > e - s + 1:",
      "mutated_line": "elif k <= e - s + 1:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k <= e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "elif k > e - s + 1:",
      "mutated_line": "elif k != e - s + 1:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k != e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "tmp = [0] * 2",
      "mutated_line": "tmp = [0] / 2",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] / 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "tmp = [0] * 2",
      "mutated_line": "tmp = [0] + 2",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] + 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "tmp = [0] * 2",
      "mutated_line": "tmp = [0] ** 2",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] ** 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if v < nv:",
      "mutated_line": "if v <= nv:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v <= nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if v < nv:",
      "mutated_line": "if v >= nv:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v >= nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if v < nv:",
      "mutated_line": "if v != nv:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v != nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if min(tmp) + cost[v, nv] < ret:",
      "mutated_line": "if min(tmp) + cost[v, nv] <= ret:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] <= ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if min(tmp) + cost[v, nv] < ret:",
      "mutated_line": "if min(tmp) + cost[v, nv] >= ret:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] >= ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if min(tmp) + cost[v, nv] < ret:",
      "mutated_line": "if min(tmp) + cost[v, nv] != ret:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] != ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n + 2):",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 2):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n + 0):",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 0):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n + 0):",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 0):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for v in range(1, n + 1):",
      "mutated_line": "for v in range(1, n + -1):",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + -1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "tmp = [INF] * 2",
      "mutated_line": "tmp = [INF] / 2",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] / 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "tmp = [INF] * 2",
      "mutated_line": "tmp = [INF] + 2",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] + 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "tmp = [INF] * 2",
      "mutated_line": "tmp = [INF] ** 2",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] ** 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if v < nv:",
      "mutated_line": "if v <= nv:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v <= nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if v < nv:",
      "mutated_line": "if v >= nv:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v >= nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if v < nv:",
      "mutated_line": "if v != nv:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v != nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if min(tmp) + cost[v, nv] < ans:",
      "mutated_line": "if min(tmp) + cost[v, nv] <= ans:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] <= ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if min(tmp) + cost[v, nv] < ans:",
      "mutated_line": "if min(tmp) + cost[v, nv] >= ans:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] >= ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if min(tmp) + cost[v, nv] < ans:",
      "mutated_line": "if min(tmp) + cost[v, nv] != ans:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] != ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else -2",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -2"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else -0",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -0"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else -0",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -0"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else --1",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else --1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edge = [[] for _ in range(n + 1)]",
      "mutated_line": "edge = [[] for _ in range(n - 1)]",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n - 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edge = [[] for _ in range(n + 1)]",
      "mutated_line": "edge = [[] for _ in range(n * 1)]",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n * 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "elif k > e - s + 1:",
      "mutated_line": "elif k > e - s - 1:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s - 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "elif k > e - s + 1:",
      "mutated_line": "elif k > (e - s) * 1:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > (e - s) * 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if not s <= nv <= e:",
      "mutated_line": "if not s < nv <= e:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s < nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if not s <= nv <= e:",
      "mutated_line": "if not s > nv <= e:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s > nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if not s <= nv <= e:",
      "mutated_line": "if not s == nv <= e:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s == nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "tmp = [0] * 2",
      "mutated_line": "tmp = [0] * 3",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 3\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "tmp = [0] * 2",
      "mutated_line": "tmp = [0] * 1",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 1\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "tmp = [0] * 2",
      "mutated_line": "tmp = [0] * 0",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 0\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "tmp = [0] * 2",
      "mutated_line": "tmp = [0] * 1",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 1\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "tmp = [0] * 2",
      "mutated_line": "tmp = [0] * -2",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * -2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if min(tmp) + cost[v, nv] < ret:",
      "mutated_line": "if min(tmp) - cost[v, nv] < ret:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) - cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if min(tmp) + cost[v, nv] < ret:",
      "mutated_line": "if min(tmp) * cost[v, nv] < ret:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) * cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ret = min(tmp) + cost[v, nv]",
      "mutated_line": "ret = min(tmp) - cost[v, nv]",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) - cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ret = min(tmp) + cost[v, nv]",
      "mutated_line": "ret = min(tmp) * cost[v, nv]",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) * cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "tmp = [INF] * 2",
      "mutated_line": "tmp = [INF] * 3",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 3\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "tmp = [INF] * 2",
      "mutated_line": "tmp = [INF] * 1",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 1\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "tmp = [INF] * 2",
      "mutated_line": "tmp = [INF] * 0",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 0\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "tmp = [INF] * 2",
      "mutated_line": "tmp = [INF] * 1",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 1\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "tmp = [INF] * 2",
      "mutated_line": "tmp = [INF] * -2",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * -2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if min(tmp) + cost[v, nv] < ans:",
      "mutated_line": "if min(tmp) - cost[v, nv] < ans:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) - cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if min(tmp) + cost[v, nv] < ans:",
      "mutated_line": "if min(tmp) * cost[v, nv] < ans:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) * cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = min(tmp) + cost[v, nv]",
      "mutated_line": "ans = min(tmp) - cost[v, nv]",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) - cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = min(tmp) + cost[v, nv]",
      "mutated_line": "ans = min(tmp) * cost[v, nv]",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) * cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge = [[] for _ in range(n + 1)]",
      "mutated_line": "edge = [[] for _ in range(n + 2)]",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 2)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge = [[] for _ in range(n + 1)]",
      "mutated_line": "edge = [[] for _ in range(n + 0)]",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 0)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge = [[] for _ in range(n + 1)]",
      "mutated_line": "edge = [[] for _ in range(n + 0)]",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 0)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge = [[] for _ in range(n + 1)]",
      "mutated_line": "edge = [[] for _ in range(n + -1)]",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + -1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "elif k > e - s + 1:",
      "mutated_line": "elif k > e + s + 1:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e + s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "elif k > e - s + 1:",
      "mutated_line": "elif k > e * s + 1:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e * s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif k > e - s + 1:",
      "mutated_line": "elif k > e - s + 2:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 2:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif k > e - s + 1:",
      "mutated_line": "elif k > e - s + 0:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 0:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif k > e - s + 1:",
      "mutated_line": "elif k > e - s + 0:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 0:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "elif k > e - s + 1:",
      "mutated_line": "elif k > e - s + -1:",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + -1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "tmp = [0] * 2",
      "mutated_line": "tmp = [1] * 2",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [1] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "tmp = [0] * 2",
      "mutated_line": "tmp = [-1] * 2",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [-1] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "tmp = [0] * 2",
      "mutated_line": "tmp = [1] * 2",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [1] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[1] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[-1] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[-1] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[1] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 1), nv + 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv + 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 1), nv * 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv * 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k + 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k + 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k * 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k * 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[2] = recur(nv, nv + 1, e, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[2] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, nv + 1, e, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[0] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, nv + 1, e, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[0] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[-1] = recur(nv, nv + 1, e, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[-1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv - 1, e, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv - 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv * 1, e, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv * 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, e, k + 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k + 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, e, k * 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k * 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, s, nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[1] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[-1] = recur(nv, s, nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[-1] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, s, nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[1] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, s, nv + 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv + 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, s, nv * 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv * 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, s, nv - 1, k + 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k + 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, s, nv - 1, k * 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k * 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[2] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[2] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[0] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[0] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[0] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[0] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[-1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[-1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv - 1, min(v - 1, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv - 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv * 1, min(v - 1, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv * 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k + 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k + 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k * 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k * 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, n, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[1] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[-1] = recur(nv, nv + 1, n, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[-1] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, n, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[1] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv - 1, n, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv - 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv * 1, n, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv * 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv + 1, n, k + 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k + 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv + 1, n, k * 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k * 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[2] = recur(nv, v + 1, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[2] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, v + 1, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[0] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, v + 1, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[0] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[-1] = recur(nv, v + 1, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[-1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v - 1, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v - 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v * 1, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v * 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 1, nv + 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv + 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 1, nv * 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv * 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 1, nv - 1, k + 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k + 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 1, nv - 1, k * 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k * 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, 1, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[1] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[-1] = recur(nv, 1, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[-1] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, 1, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[1] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 2, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 2, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 0, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 0, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 0, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 0, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, -1, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, -1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 1, nv + 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv + 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 1, nv * 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv * 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 1, nv - 1, k + 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k + 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 1, nv - 1, k * 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k * 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[2] = recur(nv, nv + 1, v - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[2] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv + 1, v - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[0] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv + 1, v - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[0] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[-1] = recur(nv, nv + 1, v - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[-1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv - 1, v - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv - 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv * 1, v - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv * 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, v + 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v + 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, v * 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v * 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, v - 1, k + 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k + 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, v - 1, k * 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k * 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v - 1), nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v - 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v * 1), nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v * 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 2, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 2, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 0, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 0, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 0, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 0, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 1), nv - -1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - -1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 0)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 0)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 0)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 0)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - -1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - -1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 2, e, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 2, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 0, e, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 0, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 0, e, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 0, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + -1, e, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + -1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, e, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 2)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, e, k - 0)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 0)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, e, k - 0)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 0)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tmp[1] = recur(nv, nv + 1, e, k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, e, k - -1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - -1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, s, nv - 2, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 2, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, s, nv - 0, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 0, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, s, nv - 0, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 0, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, s, nv - -1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - -1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, s, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, s, nv - 1, k - 0)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 0)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, s, nv - 1, k - 0)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 0)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "tmp[0] = recur(nv, s, nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, s, nv - 1, k - -1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - -1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 2, min(v - 1, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 2, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 0, min(v - 1, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 0, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 0, min(v - 1, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 0, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + -1, min(v - 1, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + -1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, min(v + 1, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v + 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, min(v * 1, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v * 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 2)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 0)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 0)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 0)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 0)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - -1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - -1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv + 2, n, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 2, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv + 0, n, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 0, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv + 0, n, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 0, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv + -1, n, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + -1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv + 1, n, k - 3)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 3)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv + 1, n, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 1)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv + 1, n, k - 0)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 0)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv + 1, n, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 1)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "tmp[0] = recur(nv, nv + 1, n, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, nv + 1, n, k - -2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - -2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 2, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 2, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 0, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 0, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 0, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 0, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + -1, nv - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + -1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 1, nv - 2, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 2, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 1, nv - 0, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 0, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 1, nv - 0, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 0, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 1, nv - -1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - -1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 3)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 3)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 1)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 0)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 0)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 1)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, v + 1, nv - 1, k - -2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - -2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 1, nv - 2, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 2, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 1, nv - 0, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 0, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 1, nv - 0, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 0, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 1, nv - -1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - -1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 1, nv - 1, k - 3)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 3)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 1, nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 1, nv - 1, k - 0)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 0)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 1, nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tmp[0] = recur(nv, 1, nv - 1, k - 2)",
      "mutated_line": "tmp[0] = recur(nv, 1, nv - 1, k - -2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - -2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 2, v - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 2, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 0, v - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 0, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 0, v - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 0, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + -1, v - 1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + -1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, v - 2, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 2, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, v - 0, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 0, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, v - 0, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 0, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, v - -1, k - 2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - -1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 3)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 3)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 1)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 0)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 0)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 1)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - 2)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, v - 1, k - -2)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - -2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 2), nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 2), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 0), nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 0), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + 0), nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 0), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)",
      "mutated_line": "tmp[0] = recur(nv, max(s, v + -1), nv - 1, k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + -1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, min(v - 2, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 2, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, min(v - 0, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 0, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, min(v - 0, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - 0, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tmp[1] = recur(nv, nv + 1, min(v - 1, e), k - 1)",
      "mutated_line": "tmp[1] = recur(nv, nv + 1, min(v - -1, e), k - 1)",
      "code": "import sys\nfrom functools import lru_cache\n\ndef find_minimum_difficulty(n, k, m, lanes):\n    INF = float('inf')\n    if k < 2:\n        return 0\n    edge = [[] for _ in range(n + 1)]\n    cost = {}\n    for (u, v, c) in lanes:\n        if (u, v) in cost:\n            cost[u, v] = min(cost[u, v], c)\n        else:\n            edge[u].append(v)\n            cost[u, v] = c\n\n    @lru_cache(maxsize=None)\n    def recur(v, s, e, k):\n        if k == 0:\n            return 0\n        elif k > e - s + 1:\n            return INF\n        ret = INF\n        for nv in edge[v]:\n            if not s <= nv <= e:\n                continue\n            tmp = [0] * 2\n            if v < nv:\n                tmp[0] = recur(nv, max(s, v + 1), nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, e, k - 1)\n            else:\n                tmp[0] = recur(nv, s, nv - 1, k - 1)\n                tmp[1] = recur(nv, nv + 1, min(v - -1, e), k - 1)\n            if min(tmp) + cost[v, nv] < ret:\n                ret = min(tmp) + cost[v, nv]\n        return ret\n    ans = INF\n    for v in range(1, n + 1):\n        for nv in edge[v]:\n            tmp = [INF] * 2\n            if v < nv:\n                tmp[0] = recur(nv, nv + 1, n, k - 2)\n                tmp[1] = recur(nv, v + 1, nv - 1, k - 2)\n            else:\n                tmp[0] = recur(nv, 1, nv - 1, k - 2)\n                tmp[1] = recur(nv, nv + 1, v - 1, k - 2)\n            if min(tmp) + cost[v, nv] < ans:\n                ans = min(tmp) + cost[v, nv]\n    return ans if ans != INF else -1"
    }
  ]
}