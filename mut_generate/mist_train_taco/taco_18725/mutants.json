{
  "task_id": "taco_18725",
  "entry_point": "find_long_cycle_or_independent_set",
  "mutant_count": 68,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if len(currset) >= ma:",
      "mutated_line": "if len(currset) > ma:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) > ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if len(currset) >= ma:",
      "mutated_line": "if len(currset) < ma:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) < ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if len(currset) >= ma:",
      "mutated_line": "if len(currset) == ma:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) == ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dep = [0] * (n + 1)",
      "mutated_line": "dep = [0] / (n + 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] / (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dep = [0] * (n + 1)",
      "mutated_line": "dep = [0] + (n + 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] + (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dep = [0] * (n + 1)",
      "mutated_line": "dep = [0] ** (n + 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] ** (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "par = [0] * (n + 1)",
      "mutated_line": "par = [0] / (n + 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] / (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "par = [0] * (n + 1)",
      "mutated_line": "par = [0] + (n + 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] + (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "par = [0] * (n + 1)",
      "mutated_line": "par = [0] ** (n + 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] ** (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ma = math.ceil(n ** 0.5)",
      "mutated_line": "ma = math.ceil(n * 0.5)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n * 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ma = math.ceil(n ** 0.5)",
      "mutated_line": "ma = math.ceil(n + 0.5)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n + 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if i in g:",
      "mutated_line": "if i not in g:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i not in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if len(currset) == ma:",
      "mutated_line": "if len(currset) != ma:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) != ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return (2, cycles)",
      "mutated_line": "return (3, cycles)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (3, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return (2, cycles)",
      "mutated_line": "return (1, cycles)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (1, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return (2, cycles)",
      "mutated_line": "return (0, cycles)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (0, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return (2, cycles)",
      "mutated_line": "return (1, cycles)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (1, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return (2, cycles)",
      "mutated_line": "return (-2, cycles)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (-2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dep = [0] * (n + 1)",
      "mutated_line": "dep = [0] * (n - 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n - 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dep = [0] * (n + 1)",
      "mutated_line": "dep = [0] * (n * 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n * 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "par = [0] * (n + 1)",
      "mutated_line": "par = [0] * (n - 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n - 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "par = [0] * (n + 1)",
      "mutated_line": "par = [0] * (n * 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n * 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "st = [1]",
      "mutated_line": "st = [2]",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [2]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "st = [1]",
      "mutated_line": "st = [0]",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [0]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "st = [1]",
      "mutated_line": "st = [0]",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [0]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "st = [1]",
      "mutated_line": "st = [-1]",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [-1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dep[u] = dep[par[u]] + 1",
      "mutated_line": "dep[u] = dep[par[u]] - 1",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] - 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dep[u] = dep[par[u]] + 1",
      "mutated_line": "dep[u] = dep[par[u]] * 1",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] * 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ma = math.ceil(n ** 0.5)",
      "mutated_line": "ma = math.ceil(n ** 1.5)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 1.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ma = math.ceil(n ** 0.5)",
      "mutated_line": "ma = math.ceil(n ** -0.5)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** -0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ma = math.ceil(n ** 0.5)",
      "mutated_line": "ma = math.ceil(n ** 0)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ma = math.ceil(n ** 0.5)",
      "mutated_line": "ma = math.ceil(n ** 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 1)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ma = math.ceil(n ** 0.5)",
      "mutated_line": "ma = math.ceil(n ** -0.5)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** -0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return (1, list(currset)[:ma])",
      "mutated_line": "return (2, list(currset)[:ma])",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (2, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return (1, list(currset)[:ma])",
      "mutated_line": "return (0, list(currset)[:ma])",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (0, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return (1, list(currset)[:ma])",
      "mutated_line": "return (0, list(currset)[:ma])",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (0, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return (1, list(currset)[:ma])",
      "mutated_line": "return (-1, list(currset)[:ma])",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (-1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dep = [0] * (n + 1)",
      "mutated_line": "dep = [1] * (n + 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [1] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dep = [0] * (n + 1)",
      "mutated_line": "dep = [-1] * (n + 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [-1] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dep = [0] * (n + 1)",
      "mutated_line": "dep = [1] * (n + 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [1] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dep = [0] * (n + 1)",
      "mutated_line": "dep = [0] * (n + 2)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 2)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dep = [0] * (n + 1)",
      "mutated_line": "dep = [0] * (n + 0)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 0)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dep = [0] * (n + 1)",
      "mutated_line": "dep = [0] * (n + 0)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 0)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dep = [0] * (n + 1)",
      "mutated_line": "dep = [0] * (n + -1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + -1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "par = [0] * (n + 1)",
      "mutated_line": "par = [1] * (n + 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [1] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "par = [0] * (n + 1)",
      "mutated_line": "par = [-1] * (n + 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [-1] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "par = [0] * (n + 1)",
      "mutated_line": "par = [1] * (n + 1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [1] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "par = [0] * (n + 1)",
      "mutated_line": "par = [0] * (n + 2)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 2)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "par = [0] * (n + 1)",
      "mutated_line": "par = [0] * (n + 0)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 0)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "par = [0] * (n + 1)",
      "mutated_line": "par = [0] * (n + 0)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 0)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "par = [0] * (n + 1)",
      "mutated_line": "par = [0] * (n + -1)",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + -1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dep[u] = dep[par[u]] + 1",
      "mutated_line": "dep[u] = dep[par[u]] + 2",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 2\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dep[u] = dep[par[u]] + 1",
      "mutated_line": "dep[u] = dep[par[u]] + 0",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 0\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dep[u] = dep[par[u]] + 1",
      "mutated_line": "dep[u] = dep[par[u]] + 0",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 0\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dep[u] = dep[par[u]] + 1",
      "mutated_line": "dep[u] = dep[par[u]] + -1",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + -1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if k in g:",
      "mutated_line": "if k not in g:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k not in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif dep[u] - dep[v] + 1 >= req:",
      "mutated_line": "elif dep[u] - dep[v] + 1 > req:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 > req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif dep[u] - dep[v] + 1 >= req:",
      "mutated_line": "elif dep[u] - dep[v] + 1 < req:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 < req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif dep[u] - dep[v] + 1 >= req:",
      "mutated_line": "elif dep[u] - dep[v] + 1 == req:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 == req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif dep[u] - dep[v] + 1 >= req:",
      "mutated_line": "elif dep[u] - dep[v] - 1 >= req:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] - 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif dep[u] - dep[v] + 1 >= req:",
      "mutated_line": "elif (dep[u] - dep[v]) * 1 >= req:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif (dep[u] - dep[v]) * 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while u != par[v]:",
      "mutated_line": "while u == par[v]:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 1 >= req:\n                    cyc = []\n                    while u == par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif dep[u] - dep[v] + 1 >= req:",
      "mutated_line": "elif dep[u] + dep[v] + 1 >= req:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] + dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif dep[u] - dep[v] + 1 >= req:",
      "mutated_line": "elif dep[u] * dep[v] + 1 >= req:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] * dep[v] + 1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif dep[u] - dep[v] + 1 >= req:",
      "mutated_line": "elif dep[u] - dep[v] + 2 >= req:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 2 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif dep[u] - dep[v] + 1 >= req:",
      "mutated_line": "elif dep[u] - dep[v] + 0 >= req:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 0 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif dep[u] - dep[v] + 1 >= req:",
      "mutated_line": "elif dep[u] - dep[v] + 0 >= req:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + 0 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif dep[u] - dep[v] + 1 >= req:",
      "mutated_line": "elif dep[u] - dep[v] + -1 >= req:",
      "code": "import math\nfrom collections import defaultdict\n\ndef find_long_cycle_or_independent_set(n, m, edges):\n\n    def dfs():\n        nonlocal req\n        dep = [0] * (n + 1)\n        par = [0] * (n + 1)\n        st = [1]\n        st2 = []\n        while st:\n            u = st.pop()\n            if dep[u]:\n                continue\n            st2.append(u)\n            dep[u] = dep[par[u]] + 1\n            for v in g2[u]:\n                if not dep[v]:\n                    par[v] = u\n                    st.append(v)\n                elif dep[u] - dep[v] + -1 >= req:\n                    cyc = []\n                    while u != par[v]:\n                        cyc.append(u)\n                        u = par[u]\n                    return (None, cyc)\n        return (None, None)\n    g = defaultdict(set)\n    g2 = defaultdict(set)\n    for (a, b) in edges:\n        g[a].add(b)\n        g[b].add(a)\n        g2[a].add(b)\n        g2[b].add(a)\n    for i in g2:\n        g2[i] = set(sorted(list(g2[i])))\n    currset = set()\n    ma = math.ceil(n ** 0.5)\n    req = ma\n    for i in sorted(g, key=lambda x: len(g[x])):\n        if i in g:\n            currset.add(i)\n            for k in list(g[i]):\n                if k in g:\n                    g.pop(k)\n            g.pop(i)\n        if len(currset) == ma:\n            break\n    if len(currset) >= ma:\n        return (1, list(currset)[:ma])\n    (_, cycles) = dfs()\n    return (2, cycles)"
    }
  ]
}