{
  "task_id": "taco_10080",
  "entry_point": "can_chef_kill_all_zombies",
  "mutant_count": 79,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] / (N + 1)",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] / (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] + (N + 1)",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] + (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] ** (N + 1)",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] ** (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = dmg = 0",
      "mutated_line": "ans = dmg = 1",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 1\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = dmg = 0",
      "mutated_line": "ans = dmg = -1",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = -1\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = dmg = 0",
      "mutated_line": "ans = dmg = 1",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 1\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "dmg -= D[i]",
      "mutated_line": "dmg += D[i]",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg += D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "Z[i] -= dmg",
      "mutated_line": "Z[i] += dmg",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] += dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if ans == -1:",
      "mutated_line": "if ans != -1:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans != -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] * (N - 1)",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N - 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] * (N * 1)",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N * 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while Z[i] > 0:",
      "mutated_line": "while Z[i] >= 0:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] >= 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while Z[i] > 0:",
      "mutated_line": "while Z[i] <= 0:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] <= 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while Z[i] > 0:",
      "mutated_line": "while Z[i] != 0:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] != 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "Z[i] -= d",
      "mutated_line": "Z[i] += d",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] += d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "K -= d",
      "mutated_line": "K += d",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K += d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "ans += d",
      "mutated_line": "ans -= d",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans -= d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "dmg += d",
      "mutated_line": "dmg -= d",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg -= d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "D[R + 1] += d",
      "mutated_line": "D[R + 1] -= d",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] -= d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if ans == -1:",
      "mutated_line": "if ans != -1:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans != -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "if ans == -1:",
      "mutated_line": "if ans == +1:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == +1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [1] * (N + 1)",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [1] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [-1] * (N + 1)",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [-1] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [1] * (N + 1)",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [1] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] * (N + 2)",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 2)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] * (N + 0)",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 0)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] * (N + 0)",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 0)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] * (N + -1)",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + -1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while Z[i] > 0:",
      "mutated_line": "while Z[i] > 1:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 1:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while Z[i] > 0:",
      "mutated_line": "while Z[i] > -1:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > -1:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while Z[i] > 0:",
      "mutated_line": "while Z[i] > 1:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 1:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if not heap or -heap[0][0] < i:",
      "mutated_line": "if not heap and -heap[0][0] < i:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap and -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "R = -R",
      "mutated_line": "R = +R",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = +R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "if ans == -1:",
      "mutated_line": "if ans == +1:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == +1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if ans == -1:",
      "mutated_line": "if ans == -2:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -2:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if ans == -1:",
      "mutated_line": "if ans == -0:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -0:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if ans == -1:",
      "mutated_line": "if ans == -0:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -0:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if ans == -1:",
      "mutated_line": "if ans == --1:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == --1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "results.append('NO')",
      "mutated_line": "results.append('')",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C[L - 1].append((R - 1, K))",
      "mutated_line": "C[L - 1].append((R + 1, K))",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R + 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C[L - 1].append((R - 1, K))",
      "mutated_line": "C[L - 1].append((R * 1, K))",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R * 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not heap or -heap[0][0] < i:",
      "mutated_line": "if not heap or -heap[0][0] <= i:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] <= i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not heap or -heap[0][0] < i:",
      "mutated_line": "if not heap or -heap[0][0] >= i:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] >= i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not heap or -heap[0][0] < i:",
      "mutated_line": "if not heap or -heap[0][0] != i:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] != i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "ans = -1",
      "mutated_line": "ans = +1",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = +1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "D[R + 1] += d",
      "mutated_line": "D[R - 1] += d",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R - 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "D[R + 1] += d",
      "mutated_line": "D[R * 1] += d",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R * 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ans == -1:",
      "mutated_line": "if ans == -2:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -2:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ans == -1:",
      "mutated_line": "if ans == -0:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -0:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ans == -1:",
      "mutated_line": "if ans == -0:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -0:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ans == -1:",
      "mutated_line": "if ans == --1:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == --1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "results.append(f'YES {ans}')",
      "mutated_line": "results.append(f'{ans}')",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'{ans}')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C[L - 1].append((R - 1, K))",
      "mutated_line": "C[L + 1].append((R - 1, K))",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L + 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C[L - 1].append((R - 1, K))",
      "mutated_line": "C[L * 1].append((R - 1, K))",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L * 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C[L - 1].append((R - 1, K))",
      "mutated_line": "C[L - 1].append((R - 2, K))",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 2, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C[L - 1].append((R - 1, K))",
      "mutated_line": "C[L - 1].append((R - 0, K))",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 0, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C[L - 1].append((R - 1, K))",
      "mutated_line": "C[L - 1].append((R - 0, K))",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 0, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C[L - 1].append((R - 1, K))",
      "mutated_line": "C[L - 1].append((R - -1, K))",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - -1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "heapq.heappush(heap, (-R, K))",
      "mutated_line": "heapq.heappush(heap, (+R, K))",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (+R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "if not heap or -heap[0][0] < i:",
      "mutated_line": "if not heap or +heap[0][0] < i:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or +heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = -1",
      "mutated_line": "ans = -2",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -2\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = -1",
      "mutated_line": "ans = -0",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -0\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = -1",
      "mutated_line": "ans = -0",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -0\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = -1",
      "mutated_line": "ans = --1",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = --1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "D[R + 1] += d",
      "mutated_line": "D[R + 2] += d",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 2] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "D[R + 1] += d",
      "mutated_line": "D[R + 0] += d",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 0] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "D[R + 1] += d",
      "mutated_line": "D[R + 0] += d",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 0] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "D[R + 1] += d",
      "mutated_line": "D[R + -1] += d",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + -1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C[L - 1].append((R - 1, K))",
      "mutated_line": "C[L - 2].append((R - 1, K))",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 2].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C[L - 1].append((R - 1, K))",
      "mutated_line": "C[L - 0].append((R - 1, K))",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 0].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C[L - 1].append((R - 1, K))",
      "mutated_line": "C[L - 0].append((R - 1, K))",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 0].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C[L - 1].append((R - 1, K))",
      "mutated_line": "C[L - -1].append((R - 1, K))",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - -1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "heapq.heappush(heap, (-R, K))",
      "mutated_line": "heapq.heappush(heap, (+R, K))",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (+R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not heap or -heap[0][0] < i:",
      "mutated_line": "if not heap or -heap[0][1] < i:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][1] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not heap or -heap[0][0] < i:",
      "mutated_line": "if not heap or -heap[0][-1] < i:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][-1] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not heap or -heap[0][0] < i:",
      "mutated_line": "if not heap or -heap[0][1] < i:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[0][1] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not heap or -heap[0][0] < i:",
      "mutated_line": "if not heap or -heap[1][0] < i:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[1][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not heap or -heap[0][0] < i:",
      "mutated_line": "if not heap or -heap[-1][0] < i:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[-1][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not heap or -heap[0][0] < i:",
      "mutated_line": "if not heap or -heap[1][0] < i:",
      "code": "import heapq\n\ndef can_chef_kill_all_zombies(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, Z, cranes) = case\n        C = [[] for _ in range(N)]\n        for (L, R, K) in cranes:\n            C[L - 1].append((R - 1, K))\n        D = [0] * (N + 1)\n        heap = []\n        ans = dmg = 0\n        for i in range(N):\n            dmg -= D[i]\n            for (R, K) in C[i]:\n                heapq.heappush(heap, (-R, K))\n            Z[i] -= dmg\n            while Z[i] > 0:\n                if not heap or -heap[1][0] < i:\n                    ans = -1\n                    break\n                (R, K) = heapq.heappop(heap)\n                R = -R\n                d = min(K, Z[i])\n                Z[i] -= d\n                K -= d\n                ans += d\n                dmg += d\n                D[R + 1] += d\n                if K:\n                    heapq.heappush(heap, (-R, K))\n            if ans == -1:\n                break\n        if ans == -1:\n            results.append('NO')\n        else:\n            results.append(f'YES {ans}')\n    return results"
    }
  ]
}