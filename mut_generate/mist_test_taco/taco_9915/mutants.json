{
  "task_id": "taco_9915",
  "entry_point": "is_prime",
  "mutant_count": 345,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return False\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "visited[Num1] = True",
      "mutated_line": "visited[Num1] = False",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = False\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ptr = 0",
      "mutated_line": "ptr = 1",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 1\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ptr = 0",
      "mutated_line": "ptr = -1",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = -1\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ptr = 0",
      "mutated_line": "ptr = 1",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 1\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "level = 0",
      "mutated_line": "level = 1",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 1\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "level = 0",
      "mutated_line": "level = -1",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = -1\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "level = 0",
      "mutated_line": "level = 1",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 1\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "while ptr < len(q):",
      "mutated_line": "while ptr <= len(q):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr <= len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "while ptr < len(q):",
      "mutated_line": "while ptr >= len(q):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr >= len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "while ptr < len(q):",
      "mutated_line": "while ptr != len(q):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr != len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 54,
      "original_line": "level += 1",
      "mutated_line": "level -= 1",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level -= 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 56,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(3, int(sqrt(n)) + 1):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(3, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(1, int(sqrt(n)) + 1):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(1, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(0, int(sqrt(n)) + 1):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(0, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(1, int(sqrt(n)) + 1):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(1, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(-2, int(sqrt(n)) + 1):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(-2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(2, int(sqrt(n)) - 1):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) - 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(2, int(sqrt(n)) * 1):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) * 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "data = [False for i in range(10000)]",
      "mutated_line": "data = [True for i in range(10000)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [True for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [False for i in range(10000)]",
      "mutated_line": "visited = [True for i in range(10000)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [True for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1000, 10000):",
      "mutated_line": "for i in range(1001, 10000):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1001, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1000, 10000):",
      "mutated_line": "for i in range(999, 10000):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(999, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1000, 10000):",
      "mutated_line": "for i in range(0, 10000):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(0, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1000, 10000):",
      "mutated_line": "for i in range(1, 10000):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1000, 10000):",
      "mutated_line": "for i in range(-1000, 10000):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(-1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1000, 10000):",
      "mutated_line": "for i in range(1000, 10001):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10001):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1000, 10000):",
      "mutated_line": "for i in range(1000, 9999):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 9999):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1000, 10000):",
      "mutated_line": "for i in range(1000, 0):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 0):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1000, 10000):",
      "mutated_line": "for i in range(1000, 1):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 1):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1000, 10000):",
      "mutated_line": "for i in range(1000, -10000):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, -10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if q[ptr] == Num2:",
      "mutated_line": "if q[ptr] != Num2:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] != Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "ptr += 1",
      "mutated_line": "ptr -= 1",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr -= 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "level += 1",
      "mutated_line": "level += 2",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "level += 1",
      "mutated_line": "level += 0",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "level += 1",
      "mutated_line": "level += 0",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "level += 1",
      "mutated_line": "level += -1",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += -1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(2, int(sqrt(n)) + 2):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 2):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(2, int(sqrt(n)) + 0):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 0):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(2, int(sqrt(n)) + 0):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 0):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(2, int(sqrt(n)) + 1):",
      "mutated_line": "for i in range(2, int(sqrt(n)) + -1):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + -1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if not n % i:",
      "mutated_line": "if not n * i:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n * i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if not n % i:",
      "mutated_line": "if not n + i:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n + i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return True\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "data[i] = True",
      "mutated_line": "data[i] = False",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = False\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(2, 10):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(2, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(0, 10):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(0, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(0, 10):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(0, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(-1, 10):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(-1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(1, 11):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 11):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(1, 9):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 9):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(1, 0):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 0):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(1, 1):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 1):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(1, -10):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, -10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a or data[1000 * i + 100 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a or data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(11):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(11):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(9):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(9):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(0):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(0):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(1):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(1):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(-10):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(-10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b or data[1000 * a + 100 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b or data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(11):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(11):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(9):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(9):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(0):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(0):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(1):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(1):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(-10):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(-10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c or data[1000 * a + 100 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c or data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(11):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(11):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(9):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(9):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(0):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(0):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(1):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(1):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(10):",
      "mutated_line": "for i in range(-10):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(-10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d or data[1000 * a + 100 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d or data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for _ in range(len(q) - ptr):",
      "mutated_line": "for _ in range(len(q) + ptr):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) + ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for _ in range(len(q) - ptr):",
      "mutated_line": "for _ in range(len(q) * ptr):",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) * ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if top == Num2:",
      "mutated_line": "if top != Num2:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top != Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ptr += 1",
      "mutated_line": "ptr += 2",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 2\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ptr += 1",
      "mutated_line": "ptr += 0",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 0\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ptr += 1",
      "mutated_line": "ptr += 0",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 0\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ptr += 1",
      "mutated_line": "ptr += -1",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += -1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "data = [False for i in range(10000)]",
      "mutated_line": "data = [False for i in range(10001)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10001)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "data = [False for i in range(10000)]",
      "mutated_line": "data = [False for i in range(9999)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(9999)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "data = [False for i in range(10000)]",
      "mutated_line": "data = [False for i in range(0)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(0)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "data = [False for i in range(10000)]",
      "mutated_line": "data = [False for i in range(1)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(1)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "data = [False for i in range(10000)]",
      "mutated_line": "data = [False for i in range(-10000)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(-10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [False for i in range(10000)]",
      "mutated_line": "visited = [False for i in range(10001)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10001)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [False for i in range(10000)]",
      "mutated_line": "visited = [False for i in range(9999)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(9999)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [False for i in range(10000)]",
      "mutated_line": "visited = [False for i in range(0)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(0)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [False for i in range(10000)]",
      "mutated_line": "visited = [False for i in range(1)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(1)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [False for i in range(10000)]",
      "mutated_line": "visited = [False for i in range(-10000)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(-10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "adj = [[] for i in range(10000)]",
      "mutated_line": "adj = [[] for i in range(10001)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10001)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "adj = [[] for i in range(10000)]",
      "mutated_line": "adj = [[] for i in range(9999)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(9999)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "adj = [[] for i in range(10000)]",
      "mutated_line": "adj = [[] for i in range(0)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(0)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "adj = [[] for i in range(10000)]",
      "mutated_line": "adj = [[] for i in range(1)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(1)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "adj = [[] for i in range(10000)]",
      "mutated_line": "adj = [[] for i in range(-10000)]",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(-10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i == a and data[1000 * i + 100 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i == a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i == b and data[1000 * a + 100 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i == b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i == c and data[1000 * a + 100 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i == c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i == d and data[1000 * a + 100 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i == d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 100 * b + 10 * c - d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c - d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[(1000 * i + 100 * b + 10 * c) * d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[(1000 * i + 100 * b + 10 * c) * d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 100 * b + 10 * c - d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c - d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append((1000 * i + 100 * b + 10 * c) * d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append((1000 * i + 100 * b + 10 * c) * d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 100 * i + 10 * c - d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c - d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[(1000 * a + 100 * i + 10 * c) * d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[(1000 * a + 100 * i + 10 * c) * d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * i + 10 * c - d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c - d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append((1000 * a + 100 * i + 10 * c) * d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append((1000 * a + 100 * i + 10 * c) * d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 100 * b + 10 * i - d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i - d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[(1000 * a + 100 * b + 10 * i) * d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[(1000 * a + 100 * b + 10 * i) * d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + 10 * i - d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i - d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append((1000 * a + 100 * b + 10 * i) * d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append((1000 * a + 100 * b + 10 * i) * d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 100 * b + 10 * c - i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c - i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[(1000 * a + 100 * b + 10 * c) * i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[(1000 * a + 100 * b + 10 * c) * i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + 10 * c - i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c - i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append((1000 * a + 100 * b + 10 * c) * i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append((1000 * a + 100 * b + 10 * c) * i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "visited[i] = True",
      "mutated_line": "visited[i] = False",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = False\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 100 * b - 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b - 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[(1000 * i + 100 * b) * (10 * c) + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[(1000 * i + 100 * b) * (10 * c) + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 100 * b - 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b - 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append((1000 * i + 100 * b) * (10 * c) + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append((1000 * i + 100 * b) * (10 * c) + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 100 * i - 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i - 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[(1000 * a + 100 * i) * (10 * c) + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[(1000 * a + 100 * i) * (10 * c) + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * i - 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i - 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append((1000 * a + 100 * i) * (10 * c) + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append((1000 * a + 100 * i) * (10 * c) + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 100 * b - 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b - 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[(1000 * a + 100 * b) * (10 * i) + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[(1000 * a + 100 * b) * (10 * i) + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b - 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b - 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append((1000 * a + 100 * b) * (10 * i) + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append((1000 * a + 100 * b) * (10 * i) + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 100 * b - 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b - 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[(1000 * a + 100 * b) * (10 * c) + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[(1000 * a + 100 * b) * (10 * c) + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b - 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b - 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append((1000 * a + 100 * b) * (10 * c) + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append((1000 * a + 100 * b) * (10 * c) + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i - 100 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i - 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i * (100 * b) + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i * (100 * b) + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 100 * b + 10 / c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 / c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 100 * b + (10 + c) + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + (10 + c) + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 100 * b + 10 ** c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 ** c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i - 100 * b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i - 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i * (100 * b) + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i * (100 * b) + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 100 * b + 10 / c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 / c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 100 * b + (10 + c) + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + (10 + c) + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 100 * b + 10 ** c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 ** c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a - 100 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a - 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a * (100 * i) + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a * (100 * i) + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 100 * i + 10 / c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 / c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 100 * i + (10 + c) + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + (10 + c) + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 100 * i + 10 ** c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 ** c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a - 100 * i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a - 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a * (100 * i) + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a * (100 * i) + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * i + 10 / c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 / c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * i + (10 + c) + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + (10 + c) + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * i + 10 ** c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 ** c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a - 100 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a - 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a * (100 * b) + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a * (100 * b) + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 100 * b + 10 / i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 / i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 100 * b + (10 + i) + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + (10 + i) + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 100 * b + 10 ** i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 ** i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a - 100 * b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a - 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a * (100 * b) + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a * (100 * b) + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + 10 / i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 / i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + (10 + i) + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + (10 + i) + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + 10 ** i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 ** i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a - 100 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a - 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a * (100 * b) + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a * (100 * b) + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 100 * b + 10 / c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 / c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 100 * b + (10 + c) + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + (10 + c) + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 100 * b + 10 ** c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 ** c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a - 100 * b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a - 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a * (100 * b) + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a * (100 * b) + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + 10 / c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 / c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + (10 + c) + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + (10 + c) + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + 10 ** c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 ** c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 / i + 100 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 / i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 + i + 100 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 + i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 ** i + 100 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 ** i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 100 / b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 / b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + (100 + b) + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + (100 + b) + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 100 ** b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 ** b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 100 * b + 11 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 11 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 100 * b + 9 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 9 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 100 * b + 0 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 0 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 100 * b + 1 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 1 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 100 * b + -10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + -10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 / i + 100 * b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 / i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 + i + 100 * b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 + i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 ** i + 100 * b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 ** i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 100 / b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 / b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + (100 + b) + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + (100 + b) + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 100 ** b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 ** b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 100 * b + 11 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 11 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 100 * b + 9 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 9 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 100 * b + 0 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 0 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 100 * b + 1 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 1 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 100 * b + -10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + -10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 / a + 100 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 / a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 + a + 100 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 + a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 ** a + 100 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 ** a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 100 / i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 / i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + (100 + i) + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + (100 + i) + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 100 ** i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 ** i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 100 * i + 11 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 11 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 100 * i + 9 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 9 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 100 * i + 0 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 0 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 100 * i + 1 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 1 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 100 * i + -10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + -10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 / a + 100 * i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 / a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 + a + 100 * i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 + a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 ** a + 100 * i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 ** a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 / i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 / i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + (100 + i) + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + (100 + i) + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 ** i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 ** i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * i + 11 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 11 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * i + 9 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 9 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * i + 0 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 0 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * i + 1 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 1 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * i + -10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + -10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 / a + 100 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 / a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 + a + 100 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 + a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 ** a + 100 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 ** a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 100 / b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 / b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + (100 + b) + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + (100 + b) + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 100 ** b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 ** b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 100 * b + 11 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 11 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 100 * b + 9 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 9 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 100 * b + 0 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 0 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 100 * b + 1 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 1 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 100 * b + -10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + -10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 / a + 100 * b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 / a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 + a + 100 * b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 + a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 ** a + 100 * b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 ** a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 / b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 / b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + (100 + b) + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + (100 + b) + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 ** b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 ** b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + 11 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 11 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + 9 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 9 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + 0 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 0 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + 1 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 1 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + -10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + -10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 / a + 100 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 / a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 + a + 100 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 + a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 ** a + 100 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 ** a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 100 / b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 / b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + (100 + b) + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + (100 + b) + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 100 ** b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 ** b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 100 * b + 11 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 11 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 100 * b + 9 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 9 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 100 * b + 0 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 0 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 100 * b + 1 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 1 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 100 * b + -10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + -10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 / a + 100 * b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 / a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 + a + 100 * b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 + a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 ** a + 100 * b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 ** a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 100 / b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 / b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + (100 + b) + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + (100 + b) + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 100 ** b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 ** b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + 11 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 11 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + 9 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 9 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + 0 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 0 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + 1 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 1 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 100 * b + -10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + -10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1001 * i + 100 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1001 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[999 * i + 100 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[999 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[0 * i + 100 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[0 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1 * i + 100 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[-1000 * i + 100 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[-1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 101 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 101 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 99 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 99 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 0 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 0 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + 1 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 1 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i != a and data[1000 * i + 100 * b + 10 * c + d]:",
      "mutated_line": "if i != a and data[1000 * i + -100 * b + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + -100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1001 * i + 100 * b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1001 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(999 * i + 100 * b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(999 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(0 * i + 100 * b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(0 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1 * i + 100 * b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(-1000 * i + 100 * b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(-1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 101 * b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 101 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 99 * b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 99 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 0 * b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 0 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + 1 * b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 1 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "adj[t].append(1000 * i + 100 * b + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * i + -100 * b + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + -100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1001 * a + 100 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1001 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[999 * a + 100 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[999 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[0 * a + 100 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[0 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1 * a + 100 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[-1000 * a + 100 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[-1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 101 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 101 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 99 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 99 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 0 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 0 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + 1 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 1 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i != b and data[1000 * a + 100 * i + 10 * c + d]:",
      "mutated_line": "if i != b and data[1000 * a + -100 * i + 10 * c + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + -100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1001 * a + 100 * i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1001 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(999 * a + 100 * i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(999 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(0 * a + 100 * i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(0 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1 * a + 100 * i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(-1000 * a + 100 * i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(-1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 101 * i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 101 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 99 * i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 99 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 0 * i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 0 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + 1 * i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 1 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[t].append(1000 * a + 100 * i + 10 * c + d)",
      "mutated_line": "adj[t].append(1000 * a + -100 * i + 10 * c + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + -100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1001 * a + 100 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1001 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[999 * a + 100 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[999 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[0 * a + 100 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[0 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1 * a + 100 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[-1000 * a + 100 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[-1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 101 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 101 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 99 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 99 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 0 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 0 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + 1 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 1 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if i != c and data[1000 * a + 100 * b + 10 * i + d]:",
      "mutated_line": "if i != c and data[1000 * a + -100 * b + 10 * i + d]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + -100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1001 * a + 100 * b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1001 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(999 * a + 100 * b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(999 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(0 * a + 100 * b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(0 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1 * a + 100 * b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(-1000 * a + 100 * b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(-1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 101 * b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 101 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 99 * b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 99 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 0 * b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 0 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + 1 * b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 1 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * i + d)",
      "mutated_line": "adj[t].append(1000 * a + -100 * b + 10 * i + d)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + -100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1001 * a + 100 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1001 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[999 * a + 100 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[999 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[0 * a + 100 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[0 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1 * a + 100 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[-1000 * a + 100 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[-1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 101 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 101 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 99 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 99 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 0 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 0 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + 1 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 1 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if i != d and data[1000 * a + 100 * b + 10 * c + i]:",
      "mutated_line": "if i != d and data[1000 * a + -100 * b + 10 * c + i]:",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + -100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1001 * a + 100 * b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1001 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(999 * a + 100 * b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(999 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(0 * a + 100 * b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(0 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1 * a + 100 * b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(-1000 * a + 100 * b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(-1000 * a + 100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 101 * b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 101 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 99 * b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 99 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 0 * b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 0 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + 1 * b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + 1 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "adj[t].append(1000 * a + 100 * b + 10 * c + i)",
      "mutated_line": "adj[t].append(1000 * a + -100 * b + 10 * c + i)",
      "code": "from math import sqrt\n\ndef is_prime(n):\n    for i in range(2, int(sqrt(n)) + 1):\n        if not n % i:\n            return False\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    data = [False for i in range(10000)]\n    visited = [False for i in range(10000)]\n    output = []\n    for i in range(1000, 10000):\n        if is_prime(i):\n            data[i] = True\n            output.append(i)\n    adj = [[] for i in range(10000)]\n    for t in output:\n        (a, b, c, d) = map(int, list(str(t)))\n        for i in range(1, 10):\n            if i != a and data[1000 * i + 100 * b + 10 * c + d]:\n                adj[t].append(1000 * i + 100 * b + 10 * c + d)\n        for i in range(10):\n            if i != b and data[1000 * a + 100 * i + 10 * c + d]:\n                adj[t].append(1000 * a + 100 * i + 10 * c + d)\n        for i in range(10):\n            if i != c and data[1000 * a + 100 * b + 10 * i + d]:\n                adj[t].append(1000 * a + 100 * b + 10 * i + d)\n        for i in range(10):\n            if i != d and data[1000 * a + 100 * b + 10 * c + i]:\n                adj[t].append(1000 * a + -100 * b + 10 * c + i)\n    q = [Num1]\n    visited[Num1] = True\n    ptr = 0\n    level = 0\n    while ptr < len(q):\n        if q[ptr] == Num2:\n            return level\n        for _ in range(len(q) - ptr):\n            top = q[ptr]\n            if top == Num2:\n                return level\n            ptr += 1\n            for i in adj[top]:\n                if not visited[i]:\n                    visited[i] = True\n                    q.append(i)\n        level += 1\n    return -1"
    }
  ]
}