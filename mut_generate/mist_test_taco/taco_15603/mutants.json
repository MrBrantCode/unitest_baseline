{
  "task_id": "taco_15603",
  "entry_point": "find_shortest_time_to_extinguish_fuses",
  "mutant_count": 136,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 4,
      "original_line": "sx -= 1",
      "mutated_line": "sx += 1",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx += 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "sy -= 1",
      "mutated_line": "sy += 1",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy += 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sx -= 1",
      "mutated_line": "sx -= 2",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 2\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sx -= 1",
      "mutated_line": "sx -= 0",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 0\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sx -= 1",
      "mutated_line": "sx -= 0",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 0\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sx -= 1",
      "mutated_line": "sx -= -1",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= -1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sy -= 1",
      "mutated_line": "sy -= 2",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 2\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sy -= 1",
      "mutated_line": "sy -= 0",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 0\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sy -= 1",
      "mutated_line": "sy -= 0",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 0\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sy -= 1",
      "mutated_line": "sy -= -1",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= -1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dic[sx, sy, tuple(rest), 0] = True",
      "mutated_line": "dic[sx, sy, tuple(rest), 0] = False",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = False\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return --1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "rest = [i for i in range(N) if (sx, sy) != paths[i][0]]",
      "mutated_line": "rest = [i for i in range(N) if (sx, sy) == paths[i][0]]",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) == paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "que.append((sx, sy, rest, 0))",
      "mutated_line": "que.append((sx, sy, rest, 1))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 1))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "que.append((sx, sy, rest, 0))",
      "mutated_line": "que.append((sx, sy, rest, -1))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, -1))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "que.append((sx, sy, rest, 0))",
      "mutated_line": "que.append((sx, sy, rest, 1))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 1))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dic[sx, sy, tuple(rest), 0] = True",
      "mutated_line": "dic[sx, sy, tuple(rest), 1] = True",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 1] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dic[sx, sy, tuple(rest), 0] = True",
      "mutated_line": "dic[sx, sy, tuple(rest), -1] = True",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), -1] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dic[sx, sy, tuple(rest), 0] = True",
      "mutated_line": "dic[sx, sy, tuple(rest), 1] = True",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 1] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((2, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((2, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((0, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((0, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((0, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((0, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((-1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((-1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 1), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 1), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, -1), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, -1), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 1), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 1), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (2, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (2, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (0, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (0, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (0, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (0, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (-1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (-1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, +1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, +1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (1, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (1, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (-1, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (-1, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (1, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (1, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, +1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, +1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (+1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (+1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, +1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, +1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (+1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (+1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 1), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 1), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, -1), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, -1), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 1), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 1), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (+1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (+1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 2), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 2), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 0), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 0), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 0), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 0), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, -1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, -1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (1, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (1, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (-1, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (-1, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (1, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (1, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 2), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 2), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 0), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 0), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 0), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 0), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, -1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, -1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (2, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (2, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (0, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (0, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (0, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (0, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (-1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (-1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 2), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 2), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 0), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 0), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 0), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 0), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, -1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, -1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (-1, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (-1, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 1))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 1))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, -1))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, -1))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 1))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 1))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "mutated_line": "if (nx, ny) in bombs and (not 0 <= nx < W) and (not 0 <= ny < H):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs and (not 0 <= nx < W) and (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "new_time = time + 1",
      "mutated_line": "new_time = time - 1",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time - 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "new_time = time + 1",
      "mutated_line": "new_time = time * 1",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time * 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cont_flag = False",
      "mutated_line": "cont_flag = True",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = True\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if (nx, ny, tuple(new_rest), new_time) not in dic:",
      "mutated_line": "if (nx, ny, tuple(new_rest), new_time) in dic:",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "bombs.add(path[-1])",
      "mutated_line": "bombs.add(path[+1])",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[+1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -2), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -2), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -0), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -0), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -0), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -0), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, --1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, --1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -2), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -2), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -0), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -0), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -0), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -0), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, --1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, --1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-2, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-2, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-0, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-0, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-0, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-0, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (--1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (--1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -2), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -2), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -0), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -0), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -0), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -0), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, --1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, --1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-2, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-2, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-0, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-0, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-0, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-0, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (--1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (--1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-2, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-2, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-0, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-0, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-0, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-0, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))",
      "mutated_line": "vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (--1, 1), (0, 1), (1, 1), (0, 0))",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (--1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "(nx, ny) = (x + dx, y + dy)",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x - dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "(nx, ny) = (x + dx, y + dy)",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x * dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "(nx, ny) = (x + dx, y + dy)",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y - dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "(nx, ny) = (x + dx, y + dy)",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y * dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "mutated_line": "if (nx, ny) not in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) not in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "new_time = time + 1",
      "mutated_line": "new_time = time + 2",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 2\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "new_time = time + 1",
      "mutated_line": "new_time = time + 0",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 0\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "new_time = time + 1",
      "mutated_line": "new_time = time + 0",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 0\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "new_time = time + 1",
      "mutated_line": "new_time = time + -1",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + -1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if new_time >= limits[i]:",
      "mutated_line": "if new_time > limits[i]:",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time > limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if new_time >= limits[i]:",
      "mutated_line": "if new_time < limits[i]:",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time < limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if new_time >= limits[i]:",
      "mutated_line": "if new_time == limits[i]:",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time == limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if paths[i][new_time] == (nx, ny):",
      "mutated_line": "if paths[i][new_time] != (nx, ny):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] != (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dic[nx, ny, tuple(new_rest), new_time] = True",
      "mutated_line": "dic[nx, ny, tuple(new_rest), new_time] = False",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = False\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bombs.add(path[-1])",
      "mutated_line": "bombs.add(path[-2])",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-2])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bombs.add(path[-1])",
      "mutated_line": "bombs.add(path[-0])",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-0])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bombs.add(path[-1])",
      "mutated_line": "bombs.add(path[-0])",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-0])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bombs.add(path[-1])",
      "mutated_line": "bombs.add(path[--1])",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[--1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "rest = [i for i in range(N) if (sx, sy) != paths[i][0]]",
      "mutated_line": "rest = [i for i in range(N) if (sx, sy) != paths[i][1]]",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][1]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "rest = [i for i in range(N) if (sx, sy) != paths[i][0]]",
      "mutated_line": "rest = [i for i in range(N) if (sx, sy) != paths[i][-1]]",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][-1]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "rest = [i for i in range(N) if (sx, sy) != paths[i][0]]",
      "mutated_line": "rest = [i for i in range(N) if (sx, sy) != paths[i][1]]",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][1]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "mutated_line": "if (nx, ny) in bombs or not 0 < nx < W or (not 0 <= ny < H):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 < nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "mutated_line": "if (nx, ny) in bombs or not 0 > nx < W or (not 0 <= ny < H):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 > nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "mutated_line": "if (nx, ny) in bombs or not 0 == nx < W or (not 0 <= ny < H):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 == nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "mutated_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 < ny < H):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 < ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "mutated_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 > ny < H):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 > ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "mutated_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 == ny < H):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 == ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cont_flag = True",
      "mutated_line": "cont_flag = False",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = False\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "new_rest = [i for i in rest if i not in removes]",
      "mutated_line": "new_rest = [i for i in rest if i in removes]",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "mutated_line": "if (nx, ny) in bombs or not 1 <= nx < W or (not 0 <= ny < H):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 1 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "mutated_line": "if (nx, ny) in bombs or not -1 <= nx < W or (not 0 <= ny < H):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not -1 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "mutated_line": "if (nx, ny) in bombs or not 1 <= nx < W or (not 0 <= ny < H):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 1 <= nx < W or (not 0 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "mutated_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 1 <= ny < H):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 1 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "mutated_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not -1 <= ny < H):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not -1 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 0 <= ny < H):",
      "mutated_line": "if (nx, ny) in bombs or not 0 <= nx < W or (not 1 <= ny < H):",
      "code": "from collections import deque\n\ndef find_shortest_time_to_extinguish_fuses(W, H, N, sx, sy, paths):\n    sx -= 1\n    sy -= 1\n    limits = []\n    bombs = set()\n    for path in paths:\n        limit = len(path)\n        bombs.add(path[-1])\n        limits.append(limit)\n    rest = [i for i in range(N) if (sx, sy) != paths[i][0]]\n    que = deque()\n    que.append((sx, sy, rest, 0))\n    dic = {}\n    dic[sx, sy, tuple(rest), 0] = True\n    vec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (0, 0))\n    while que:\n        (x, y, rest, time) = que.popleft()\n        if not rest:\n            return time\n        for (dx, dy) in vec:\n            (nx, ny) = (x + dx, y + dy)\n            if (nx, ny) in bombs or not 0 <= nx < W or (not 1 <= ny < H):\n                continue\n            new_time = time + 1\n            removes = []\n            cont_flag = False\n            for i in rest:\n                if new_time >= limits[i]:\n                    cont_flag = True\n                    break\n                if paths[i][new_time] == (nx, ny):\n                    removes.append(i)\n            if cont_flag:\n                continue\n            new_rest = [i for i in rest if i not in removes]\n            if (nx, ny, tuple(new_rest), new_time) not in dic:\n                dic[nx, ny, tuple(new_rest), new_time] = True\n                que.append((nx, ny, new_rest, new_time))\n    return -1"
    }
  ]
}