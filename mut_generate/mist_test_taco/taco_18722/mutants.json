{
  "task_id": "taco_18722",
  "entry_point": "find_max_interesting_sequence_cost",
  "mutant_count": 134,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dif = 0",
      "mutated_line": "dif = 1",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 1\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dif = 0",
      "mutated_line": "dif = -1",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = -1\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dif = 0",
      "mutated_line": "dif = 1",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 1\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if L <= len(set(A)):",
      "mutated_line": "if L < len(set(A)):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L < len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if L <= len(set(A)):",
      "mutated_line": "if L > len(set(A)):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L > len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if L <= len(set(A)):",
      "mutated_line": "if L == len(set(A)):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L == len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 1\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = -1\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 1\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while False:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if v not in dic:",
      "mutated_line": "if v in dic:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mid = (s + e) // 2",
      "mutated_line": "mid = (s + e) / 2",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) / 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mid = (s + e) // 2",
      "mutated_line": "mid = (s + e) * 2",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) * 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if s == e or mid > len(l):",
      "mutated_line": "if s == e and mid > len(l):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e and mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if l[mid][0] < v[0]:",
      "mutated_line": "if l[mid][0] <= v[0]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] <= v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if l[mid][0] < v[0]:",
      "mutated_line": "if l[mid][0] >= v[0]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] >= v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if l[mid][0] < v[0]:",
      "mutated_line": "if l[mid][0] != v[0]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] != v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i, v in enumerate(A, start=1):",
      "mutated_line": "for (i, v) in enumerate(A, start=2):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=2):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i, v in enumerate(A, start=1):",
      "mutated_line": "for (i, v) in enumerate(A, start=0):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=0):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i, v in enumerate(A, start=1):",
      "mutated_line": "for (i, v) in enumerate(A, start=0):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=0):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i, v in enumerate(A, start=1):",
      "mutated_line": "for (i, v) in enumerate(A, start=-1):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=-1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(2, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(0, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(0, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(-1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "il = 1",
      "mutated_line": "il = 2",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 2\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "il = 1",
      "mutated_line": "il = 0",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 0\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "il = 1",
      "mutated_line": "il = 0",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 0\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "il = 1",
      "mutated_line": "il = -1",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = -1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "il = 1",
      "mutated_line": "il = 2",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 2\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "il = 1",
      "mutated_line": "il = 0",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 0\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "il = 1",
      "mutated_line": "il = 0",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 0\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "il = 1",
      "mutated_line": "il = -1",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = -1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mid = (s + e) // 2",
      "mutated_line": "mid = (s - e) // 2",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s - e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mid = (s + e) // 2",
      "mutated_line": "mid = s * e // 2",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = s * e // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mid = (s + e) // 2",
      "mutated_line": "mid = (s + e) // 3",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 3\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mid = (s + e) // 2",
      "mutated_line": "mid = (s + e) // 1",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 1\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mid = (s + e) // 2",
      "mutated_line": "mid = (s + e) // 0",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 0\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mid = (s + e) // 2",
      "mutated_line": "mid = (s + e) // 1",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 1\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mid = (s + e) // 2",
      "mutated_line": "mid = (s + e) // -2",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // -2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if s == e or mid > len(l):",
      "mutated_line": "if s != e or mid > len(l):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s != e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if s == e or mid > len(l):",
      "mutated_line": "if s == e or mid >= len(l):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid >= len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if s == e or mid > len(l):",
      "mutated_line": "if s == e or mid <= len(l):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid <= len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if s == e or mid > len(l):",
      "mutated_line": "if s == e or mid != len(l):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid != len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "s = mid + 1",
      "mutated_line": "s = mid - 1",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid - 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "s = mid + 1",
      "mutated_line": "s = mid * 1",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid * 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "elif l[mid][0] > v[0]:",
      "mutated_line": "elif l[mid][0] >= v[0]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] >= v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "elif l[mid][0] > v[0]:",
      "mutated_line": "elif l[mid][0] <= v[0]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] <= v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "elif l[mid][0] > v[0]:",
      "mutated_line": "elif l[mid][0] != v[0]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] != v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dic[v][0] = min(dic[v][0], i)",
      "mutated_line": "dic[v][1] = min(dic[v][0], i)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][1] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dic[v][0] = min(dic[v][0], i)",
      "mutated_line": "dic[v][-1] = min(dic[v][0], i)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][-1] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dic[v][0] = min(dic[v][0], i)",
      "mutated_line": "dic[v][1] = min(dic[v][0], i)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][1] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dic[v][1] = max(dic[v][1], i)",
      "mutated_line": "dic[v][2] = max(dic[v][1], i)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][2] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dic[v][1] = max(dic[v][1], i)",
      "mutated_line": "dic[v][0] = max(dic[v][1], i)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][0] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dic[v][1] = max(dic[v][1], i)",
      "mutated_line": "dic[v][0] = max(dic[v][1], i)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][0] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dic[v][1] = max(dic[v][1], i)",
      "mutated_line": "dic[v][-1] = max(dic[v][1], i)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][-1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dif = max(dif, dic[v][1] - dic[v][0])",
      "mutated_line": "dif = max(dif, dic[v][1] + dic[v][0])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] + dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dif = max(dif, dic[v][1] - dic[v][0])",
      "mutated_line": "dif = max(dif, dic[v][1] * dic[v][0])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] * dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i_l.sort(reverse=True)",
      "mutated_line": "i_l.sort(reverse=False)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=False)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "dp = [[-1 for _ in range(L)] for _ in range(N)]",
      "mutated_line": "dp = [[+1 for _ in range(L)] for _ in range(N)]",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[+1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for il in range(2, min(L, i + 1)):",
      "mutated_line": "for il in range(3, min(L, i + 1)):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(3, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for il in range(2, min(L, i + 1)):",
      "mutated_line": "for il in range(1, min(L, i + 1)):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(1, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for il in range(2, min(L, i + 1)):",
      "mutated_line": "for il in range(0, min(L, i + 1)):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(0, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for il in range(2, min(L, i + 1)):",
      "mutated_line": "for il in range(1, min(L, i + 1)):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(1, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for il in range(2, min(L, i + 1)):",
      "mutated_line": "for il in range(-2, min(L, i + 1)):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(-2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if l[mid][0] < v[0]:",
      "mutated_line": "if l[mid][1] < v[0]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][1] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if l[mid][0] < v[0]:",
      "mutated_line": "if l[mid][-1] < v[0]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][-1] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if l[mid][0] < v[0]:",
      "mutated_line": "if l[mid][1] < v[0]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][1] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if l[mid][0] < v[0]:",
      "mutated_line": "if l[mid][0] < v[1]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[1]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if l[mid][0] < v[0]:",
      "mutated_line": "if l[mid][0] < v[-1]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[-1]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if l[mid][0] < v[0]:",
      "mutated_line": "if l[mid][0] < v[1]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[1]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "s = mid + 1",
      "mutated_line": "s = mid + 2",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 2\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "s = mid + 1",
      "mutated_line": "s = mid + 0",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 0\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "s = mid + 1",
      "mutated_line": "s = mid + 0",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 0\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "s = mid + 1",
      "mutated_line": "s = mid + -1",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + -1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dic[v][0] = min(dic[v][0], i)",
      "mutated_line": "dic[v][0] = min(dic[v][1], i)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][1], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dic[v][0] = min(dic[v][0], i)",
      "mutated_line": "dic[v][0] = min(dic[v][-1], i)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][-1], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dic[v][0] = min(dic[v][0], i)",
      "mutated_line": "dic[v][0] = min(dic[v][1], i)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][1], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dic[v][1] = max(dic[v][1], i)",
      "mutated_line": "dic[v][1] = max(dic[v][2], i)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][2], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dic[v][1] = max(dic[v][1], i)",
      "mutated_line": "dic[v][1] = max(dic[v][0], i)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][0], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dic[v][1] = max(dic[v][1], i)",
      "mutated_line": "dic[v][1] = max(dic[v][0], i)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][0], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dic[v][1] = max(dic[v][1], i)",
      "mutated_line": "dic[v][1] = max(dic[v][-1], i)",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][-1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp = [[-1 for _ in range(L)] for _ in range(N)]",
      "mutated_line": "dp = [[-2 for _ in range(L)] for _ in range(N)]",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-2 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp = [[-1 for _ in range(L)] for _ in range(N)]",
      "mutated_line": "dp = [[-0 for _ in range(L)] for _ in range(N)]",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-0 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp = [[-1 for _ in range(L)] for _ in range(N)]",
      "mutated_line": "dp = [[-0 for _ in range(L)] for _ in range(N)]",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-0 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp = [[-1 for _ in range(L)] for _ in range(N)]",
      "mutated_line": "dp = [[--1 for _ in range(L)] for _ in range(N)]",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[--1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dif = abs(i_l[i][1] - i_l[j][1])",
      "mutated_line": "dif = abs(i_l[i][1] + i_l[j][1])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] + i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dif = abs(i_l[i][1] - i_l[j][1])",
      "mutated_line": "dif = abs(i_l[i][1] * i_l[j][1])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] * i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for il in range(2, min(L, i + 1)):",
      "mutated_line": "for il in range(2, min(L, i - 1)):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i - 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for il in range(2, min(L, i + 1)):",
      "mutated_line": "for il in range(2, min(L, i * 1)):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i * 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if ind == i:",
      "mutated_line": "if ind != i:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind != i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if prev_max < dp[i][il]:",
      "mutated_line": "if prev_max <= dp[i][il]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max <= dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if prev_max < dp[i][il]:",
      "mutated_line": "if prev_max >= dp[i][il]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max >= dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if prev_max < dp[i][il]:",
      "mutated_line": "if prev_max != dp[i][il]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max != dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 51,
      "original_line": "ans = max(ans, dp[i][-1])",
      "mutated_line": "ans = max(ans, dp[i][+1])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][+1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif l[mid][0] > v[0]:",
      "mutated_line": "elif l[mid][1] > v[0]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][1] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif l[mid][0] > v[0]:",
      "mutated_line": "elif l[mid][-1] > v[0]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][-1] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif l[mid][0] > v[0]:",
      "mutated_line": "elif l[mid][1] > v[0]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][1] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif l[mid][0] > v[0]:",
      "mutated_line": "elif l[mid][0] > v[1]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[1]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif l[mid][0] > v[0]:",
      "mutated_line": "elif l[mid][0] > v[-1]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[-1]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif l[mid][0] > v[0]:",
      "mutated_line": "elif l[mid][0] > v[1]:",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[1]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dif = max(dif, dic[v][1] - dic[v][0])",
      "mutated_line": "dif = max(dif, dic[v][2] - dic[v][0])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][2] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dif = max(dif, dic[v][1] - dic[v][0])",
      "mutated_line": "dif = max(dif, dic[v][0] - dic[v][0])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][0] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dif = max(dif, dic[v][1] - dic[v][0])",
      "mutated_line": "dif = max(dif, dic[v][0] - dic[v][0])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][0] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dif = max(dif, dic[v][1] - dic[v][0])",
      "mutated_line": "dif = max(dif, dic[v][-1] - dic[v][0])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][-1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dif = max(dif, dic[v][1] - dic[v][0])",
      "mutated_line": "dif = max(dif, dic[v][1] - dic[v][1])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][1])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dif = max(dif, dic[v][1] - dic[v][0])",
      "mutated_line": "dif = max(dif, dic[v][1] - dic[v][-1])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][-1])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dif = max(dif, dic[v][1] - dic[v][0])",
      "mutated_line": "dif = max(dif, dic[v][1] - dic[v][1])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][1])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i_l = [[v, i] for i, v in enumerate(A, start=1)]",
      "mutated_line": "i_l = [[v, i] for (i, v) in enumerate(A, start=2)]",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=2)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i_l = [[v, i] for i, v in enumerate(A, start=1)]",
      "mutated_line": "i_l = [[v, i] for (i, v) in enumerate(A, start=0)]",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=0)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i_l = [[v, i] for i, v in enumerate(A, start=1)]",
      "mutated_line": "i_l = [[v, i] for (i, v) in enumerate(A, start=0)]",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=0)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i_l = [[v, i] for i, v in enumerate(A, start=1)]",
      "mutated_line": "i_l = [[v, i] for (i, v) in enumerate(A, start=-1)]",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=-1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for il in range(2, min(L, i + 1)):",
      "mutated_line": "for il in range(2, min(L, i + 2)):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 2)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for il in range(2, min(L, i + 1)):",
      "mutated_line": "for il in range(2, min(L, i + 0)):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 0)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for il in range(2, min(L, i + 1)):",
      "mutated_line": "for il in range(2, min(L, i + 0)):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 0)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for il in range(2, min(L, i + 1)):",
      "mutated_line": "for il in range(2, min(L, i + -1)):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + -1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for prev_max, ind in reversed(pq_l[il - 1]):",
      "mutated_line": "for (prev_max, ind) in reversed(pq_l[il + 1]):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il + 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for prev_max, ind in reversed(pq_l[il - 1]):",
      "mutated_line": "for (prev_max, ind) in reversed(pq_l[il * 1]):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il * 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans = max(ans, dp[i][-1])",
      "mutated_line": "ans = max(ans, dp[i][-2])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-2])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans = max(ans, dp[i][-1])",
      "mutated_line": "ans = max(ans, dp[i][-0])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans = max(ans, dp[i][-1])",
      "mutated_line": "ans = max(ans, dp[i][-0])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans = max(ans, dp[i][-1])",
      "mutated_line": "ans = max(ans, dp[i][--1])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][--1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dif = abs(i_l[i][1] - i_l[j][1])",
      "mutated_line": "dif = abs(i_l[i][2] - i_l[j][1])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][2] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dif = abs(i_l[i][1] - i_l[j][1])",
      "mutated_line": "dif = abs(i_l[i][0] - i_l[j][1])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][0] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dif = abs(i_l[i][1] - i_l[j][1])",
      "mutated_line": "dif = abs(i_l[i][0] - i_l[j][1])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][0] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dif = abs(i_l[i][1] - i_l[j][1])",
      "mutated_line": "dif = abs(i_l[i][-1] - i_l[j][1])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][-1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dif = abs(i_l[i][1] - i_l[j][1])",
      "mutated_line": "dif = abs(i_l[i][1] - i_l[j][2])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][2])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dif = abs(i_l[i][1] - i_l[j][1])",
      "mutated_line": "dif = abs(i_l[i][1] - i_l[j][0])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][0])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dif = abs(i_l[i][1] - i_l[j][1])",
      "mutated_line": "dif = abs(i_l[i][1] - i_l[j][0])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][0])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dif = abs(i_l[i][1] - i_l[j][1])",
      "mutated_line": "dif = abs(i_l[i][1] - i_l[j][-1])",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][-1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for prev_max, ind in reversed(pq_l[il - 1]):",
      "mutated_line": "for (prev_max, ind) in reversed(pq_l[il - 2]):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 2]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for prev_max, ind in reversed(pq_l[il - 1]):",
      "mutated_line": "for (prev_max, ind) in reversed(pq_l[il - 0]):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 0]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for prev_max, ind in reversed(pq_l[il - 1]):",
      "mutated_line": "for (prev_max, ind) in reversed(pq_l[il - 0]):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - 0]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for prev_max, ind in reversed(pq_l[il - 1]):",
      "mutated_line": "for (prev_max, ind) in reversed(pq_l[il - -1]):",
      "code": "def find_max_interesting_sequence_cost(N, L, A):\n\n    def insort(l, v):\n        s = 0\n        e = len(l)\n        while True:\n            mid = (s + e) // 2\n            if s == e or mid > len(l):\n                break\n            if l[mid][0] < v[0]:\n                s = mid + 1\n            elif l[mid][0] > v[0]:\n                e = mid\n            else:\n                break\n        l.insert(mid, v)\n    dic = {}\n    dif = 0\n    for (i, v) in enumerate(A, start=1):\n        if v not in dic:\n            dic[v] = [i, i]\n        else:\n            dic[v][0] = min(dic[v][0], i)\n            dic[v][1] = max(dic[v][1], i)\n            dif = max(dif, dic[v][1] - dic[v][0])\n    ans = dif\n    if L <= len(set(A)):\n        i_l = [[v, i] for (i, v) in enumerate(A, start=1)]\n        i_l.sort(reverse=True)\n        dp = [[-1 for _ in range(L)] for _ in range(N)]\n        pq_l = [[] for _ in range(L)]\n        for i in range(1, N):\n            il = 1\n            dif_l = []\n            for j in range(i):\n                dif = abs(i_l[i][1] - i_l[j][1])\n                dif_l.append(dif)\n                dp[i][il] = max(dp[i][il], dif)\n            for il in range(2, min(L, i + 1)):\n                for (prev_max, ind) in reversed(pq_l[il - -1]):\n                    if ind == i:\n                        continue\n                    if prev_max < dp[i][il]:\n                        break\n                    else:\n                        dp[i][il] = max(dp[i][il], min(dif_l[ind], prev_max))\n                insort(pq_l[il], [dp[i][il], i])\n            il = 1\n            insort(pq_l[il], [dp[i][il], i])\n            ans = max(ans, dp[i][-1])\n    return ans"
    }
  ]
}