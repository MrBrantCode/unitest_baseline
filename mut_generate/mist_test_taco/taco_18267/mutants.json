{
  "task_id": "taco_18267",
  "entry_point": "find_minimum_cut",
  "mutant_count": 70,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-1] / N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] / N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-1] + N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] + N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-1] ** N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] ** N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = 1",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 1\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = -1",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = -1\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = 1",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 1\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "s = -1",
      "mutated_line": "s = +1",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = +1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "max_flow += path_flow",
      "mutated_line": "max_flow -= path_flow",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow -= path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if s != -1:",
      "mutated_line": "if s == -1:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s == -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [False] / N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] / N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [False] + N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] + N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [False] ** N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] ** N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited[s] = True",
      "mutated_line": "visited[s] = False",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = False\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited[s] = True",
      "mutated_line": "visited[s] = False",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = False\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "s = -1",
      "mutated_line": "s = -2",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -2\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "s = -1",
      "mutated_line": "s = -0",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -0\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "s = -1",
      "mutated_line": "s = -0",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -0\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "s = -1",
      "mutated_line": "s = --1",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = --1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while s != S:",
      "mutated_line": "while s == S:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s == S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while v != S:",
      "mutated_line": "while v == S:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v == S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "graph[u][v] -= path_flow",
      "mutated_line": "graph[u][v] += path_flow",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] += path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "graph[v][u] += path_flow",
      "mutated_line": "graph[v][u] -= path_flow",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] -= path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "if s != -1:",
      "mutated_line": "if s != +1:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != +1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [False] / N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] / N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [False] + N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] + N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [False] ** N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] ** N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return [\"-1\"]",
      "mutated_line": "return ['']",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['']"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if graph[s][i] > 0 and not visited[i]:",
      "mutated_line": "if graph[s][i] > 0 or not visited[i]:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 or not visited[i]:\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [+1] * N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [+1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "path_flow = float('Inf')",
      "mutated_line": "path_flow = float('')",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if s != -1:",
      "mutated_line": "if s != -2:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -2:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if s != -1:",
      "mutated_line": "if s != -0:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -0:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if s != -1:",
      "mutated_line": "if s != -0:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -0:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if s != -1:",
      "mutated_line": "if s != --1:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != --1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [True] * N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [True] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "u = queue.pop(0)",
      "mutated_line": "u = queue.pop(1)",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(1)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "u = queue.pop(0)",
      "mutated_line": "u = queue.pop(-1)",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(-1)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "u = queue.pop(0)",
      "mutated_line": "u = queue.pop(1)",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(1)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if not visited[ind] and val > 0:",
      "mutated_line": "if not visited[ind] or val > 0:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] or val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if graph[s][i] > 0 and not visited[i]:",
      "mutated_line": "if graph[s][i] >= 0 and (not visited[i]):",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] >= 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if graph[s][i] > 0 and not visited[i]:",
      "mutated_line": "if graph[s][i] <= 0 and (not visited[i]):",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] <= 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if graph[s][i] > 0 and not visited[i]:",
      "mutated_line": "if graph[s][i] != 0 and (not visited[i]):",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] != 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-2] * N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-2] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-0] * N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-0] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-0] * N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-0] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [--1] * N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [--1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [True] * N",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [True] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "LCR",
      "lineno": 47,
      "original_line": "if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:",
      "mutated_line": "if graph[i][j] == 0 or A[i][j] > 0 or visited[i]:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 or A[i][j] > 0 or visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return cut_list if cut_list else [\"-1\"]",
      "mutated_line": "return cut_list if cut_list else ['']",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['']\n    return ['-1']"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if not visited[ind] and val > 0:",
      "mutated_line": "if not visited[ind] and val >= 0:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val >= 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if not visited[ind] and val > 0:",
      "mutated_line": "if not visited[ind] and val <= 0:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val <= 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if not visited[ind] and val > 0:",
      "mutated_line": "if not visited[ind] and val != 0:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val != 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited[ind] = True",
      "mutated_line": "visited[ind] = False",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = False\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if graph[s][i] > 0 and not visited[i]:",
      "mutated_line": "if graph[s][i] > 1 and (not visited[i]):",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 1 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if graph[s][i] > 0 and not visited[i]:",
      "mutated_line": "if graph[s][i] > -1 and (not visited[i]):",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > -1 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if graph[s][i] > 0 and not visited[i]:",
      "mutated_line": "if graph[s][i] > 1 and (not visited[i]):",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 1 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:",
      "mutated_line": "if graph[i][j] != 0 and A[i][j] > 0 and visited[i]:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] != 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:",
      "mutated_line": "if graph[i][j] == 0 and A[i][j] >= 0 and visited[i]:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] >= 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:",
      "mutated_line": "if graph[i][j] == 0 and A[i][j] <= 0 and visited[i]:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] <= 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:",
      "mutated_line": "if graph[i][j] == 0 and A[i][j] != 0 and visited[i]:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] != 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if not visited[ind] and val > 0:",
      "mutated_line": "if not visited[ind] and val > 1:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 1:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if not visited[ind] and val > 0:",
      "mutated_line": "if not visited[ind] and val > -1:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > -1:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if not visited[ind] and val > 0:",
      "mutated_line": "if not visited[ind] and val > 1:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 1:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:",
      "mutated_line": "if graph[i][j] == 1 and A[i][j] > 0 and visited[i]:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 1 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:",
      "mutated_line": "if graph[i][j] == -1 and A[i][j] > 0 and visited[i]:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == -1 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:",
      "mutated_line": "if graph[i][j] == 1 and A[i][j] > 0 and visited[i]:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 1 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:",
      "mutated_line": "if graph[i][j] == 0 and A[i][j] > 1 and visited[i]:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 1 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:",
      "mutated_line": "if graph[i][j] == 0 and A[i][j] > -1 and visited[i]:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > -1 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:",
      "mutated_line": "if graph[i][j] == 0 and A[i][j] > 1 and visited[i]:",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 1 and visited[i]:\n                    cut_list.append(f'{i} {j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "cut_list.append(f\"{i} {j}\")",
      "mutated_line": "cut_list.append(f'{i}{j}')",
      "code": "def find_minimum_cut(A, S, T, N):\n\n    def BFS(graph, s, t, parent):\n        visited = [False] * N\n        queue = []\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.pop(0)\n            for (ind, val) in enumerate(graph[u]):\n                if not visited[ind] and val > 0:\n                    queue.append(ind)\n                    visited[ind] = True\n                    parent[ind] = u\n        return visited[t]\n\n    def dfs(graph, s, visited):\n        visited[s] = True\n        for i in range(len(graph)):\n            if graph[s][i] > 0 and (not visited[i]):\n                dfs(graph, i, visited)\n    graph = [row[:] for row in A]\n    parent = [-1] * N\n    max_flow = 0\n    s = -1\n    while BFS(graph, S, T, parent):\n        path_flow = float('Inf')\n        s = T\n        while s != S:\n            path_flow = min(path_flow, graph[parent[s]][s])\n            s = parent[s]\n        max_flow += path_flow\n        v = T\n        while v != S:\n            u = parent[v]\n            graph[u][v] -= path_flow\n            graph[v][u] += path_flow\n            v = parent[v]\n    if s != -1:\n        visited = [False] * N\n        dfs(graph, S, visited)\n        cut_list = []\n        for i in range(N):\n            for j in range(N):\n                if graph[i][j] == 0 and A[i][j] > 0 and visited[i]:\n                    cut_list.append(f'{i}{j}')\n        return cut_list if cut_list else ['-1']\n    return ['-1']"
    }
  ]
}