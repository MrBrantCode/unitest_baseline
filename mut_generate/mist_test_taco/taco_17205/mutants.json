{
  "task_id": "taco_17205",
  "entry_point": "simulate_cake_cutting",
  "mutant_count": 124,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dic[1] = (w, d)",
      "mutated_line": "dic[2] = (w, d)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[2] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dic[1] = (w, d)",
      "mutated_line": "dic[0] = (w, d)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[0] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dic[1] = (w, d)",
      "mutated_line": "dic[0] = (w, d)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[0] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dic[1] = (w, d)",
      "mutated_line": "dic[-1] = (w, d)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[-1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "cycle = 2 * (H + W)",
      "mutated_line": "cycle = 2 / (H + W)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 / (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "cycle = 2 * (H + W)",
      "mutated_line": "cycle = 2 + (H + W)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 + (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "cycle = 2 * (H + W)",
      "mutated_line": "cycle = 2 ** (H + W)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 ** (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s < W and (H + W < s and s < W + H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W and (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return [W * H for W, H in sq]",
      "mutated_line": "return [W / H for (W, H) in sq]",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W / H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return [W * H for W, H in sq]",
      "mutated_line": "return [W + H for (W, H) in sq]",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W + H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return [W * H for W, H in sq]",
      "mutated_line": "return [W ** H for (W, H) in sq]",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W ** H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(p, i + 1):",
      "mutated_line": "for j in range(p, i - 1):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i - 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(p, i + 1):",
      "mutated_line": "for j in range(p, i * 1):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i * 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cycle = 2 * (H + W)",
      "mutated_line": "cycle = 3 * (H + W)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 3 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cycle = 2 * (H + W)",
      "mutated_line": "cycle = 1 * (H + W)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 1 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cycle = 2 * (H + W)",
      "mutated_line": "cycle = 0 * (H + W)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 0 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cycle = 2 * (H + W)",
      "mutated_line": "cycle = 1 * (H + W)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 1 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cycle = 2 * (H + W)",
      "mutated_line": "cycle = -2 * (H + W)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = -2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "cycle = 2 * (H + W)",
      "mutated_line": "cycle = 2 * (H - W)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H - W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "cycle = 2 * (H + W)",
      "mutated_line": "cycle = 2 * (H * W)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H * W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s <= W or (H + W < s and s < W + H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s <= W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s >= W or (H + W < s and s < W + H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s >= W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s != W or (H + W < s and s < W + H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s != W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s < W or (H + W < s or s < W + H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s or s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if W < s:",
      "mutated_line": "if W <= s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W <= s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if W < s:",
      "mutated_line": "if W >= s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W >= s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if W < s:",
      "mutated_line": "if W != s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W != s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "s -= H + W",
      "mutated_line": "s += H + W",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s += H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif (W < s and s < H + W) and W + H + W < s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif (W < s and s < H + W) and W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(p, i + 1):",
      "mutated_line": "for j in range(p, i + 2):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 2):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(p, i + 1):",
      "mutated_line": "for j in range(p, i + 0):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 0):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(p, i + 1):",
      "mutated_line": "for j in range(p, i + 0):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 0):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(p, i + 1):",
      "mutated_line": "for j in range(p, i + -1):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + -1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dic[j] = dic[j + 1]",
      "mutated_line": "dic[j] = dic[j - 1]",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j - 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dic[j] = dic[j + 1]",
      "mutated_line": "dic[j] = dic[j * 1]",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j * 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s < W or (H + W <= s and s < W + H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W <= s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s < W or (H + W >= s and s < W + H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W >= s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s < W or (H + W != s and s < W + H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W != s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s < W or (H + W < s and s <= W + H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s <= W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s < W or (H + W < s and s >= W + H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s >= W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s < W or (H + W < s and s != W + H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s != W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "s -= H + W",
      "mutated_line": "s -= H - W",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H - W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "s -= H + W",
      "mutated_line": "s -= H * W",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H * W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dic[i + 1] = (min(s, W - s), H)",
      "mutated_line": "dic[i - 1] = (min(s, W - s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i - 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dic[i + 1] = (min(s, W - s), H)",
      "mutated_line": "dic[i * 1] = (min(s, W - s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i * 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dic[i + 2] = (max(s, W - s), H)",
      "mutated_line": "dic[i - 2] = (max(s, W - s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i - 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dic[i + 2] = (max(s, W - s), H)",
      "mutated_line": "dic[i * 2] = (max(s, W - s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i * 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif (W < s or s < H + W) or W + H + W < s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif (W < s or s < H + W) or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W < s and s < H + W or W + H + W <= s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W <= s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W < s and s < H + W or W + H + W >= s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W >= s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W < s and s < H + W or W + H + W != s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W != s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if s > H + W:",
      "mutated_line": "if s >= H + W:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s >= H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if s > H + W:",
      "mutated_line": "if s <= H + W:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s <= H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if s > H + W:",
      "mutated_line": "if s != H + W:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s != H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "s -= W + H + W",
      "mutated_line": "s += W + H + W",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s += W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "s -= W",
      "mutated_line": "s += W",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s += W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sq.sort(key=lambda x: x[0] * x[1])",
      "mutated_line": "sq.sort(key=lambda x: x[0] / x[1])",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] / x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sq.sort(key=lambda x: x[0] * x[1])",
      "mutated_line": "sq.sort(key=lambda x: x[0] + x[1])",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] + x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "sq.sort(key=lambda x: x[0] * x[1])",
      "mutated_line": "sq.sort(key=lambda x: x[0] ** x[1])",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] ** x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dic[j] = dic[j + 1]",
      "mutated_line": "dic[j] = dic[j + 2]",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 2]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dic[j] = dic[j + 1]",
      "mutated_line": "dic[j] = dic[j + 0]",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 0]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dic[j] = dic[j + 1]",
      "mutated_line": "dic[j] = dic[j + 0]",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 0]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dic[j] = dic[j + 1]",
      "mutated_line": "dic[j] = dic[j + -1]",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + -1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s < W or (H - W < s and s < W + H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H - W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s < W or (H * W < s and s < W + H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H * W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s < W or (H + W < s and s < W + H - W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H - W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s < W or (H + W < s and s < (W + H) * W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < (W + H) * W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dic[i + 1] = (min(s, W - s), H)",
      "mutated_line": "dic[i + 2] = (min(s, W - s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 2] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dic[i + 1] = (min(s, W - s), H)",
      "mutated_line": "dic[i + 0] = (min(s, W - s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 0] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dic[i + 1] = (min(s, W - s), H)",
      "mutated_line": "dic[i + 0] = (min(s, W - s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 0] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dic[i + 1] = (min(s, W - s), H)",
      "mutated_line": "dic[i + -1] = (min(s, W - s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + -1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dic[i + 1] = (min(s, W - s), H)",
      "mutated_line": "dic[i + 1] = (min(s, W + s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W + s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dic[i + 1] = (min(s, W - s), H)",
      "mutated_line": "dic[i + 1] = (min(s, W * s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W * s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dic[i + 2] = (max(s, W - s), H)",
      "mutated_line": "dic[i + 3] = (max(s, W - s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 3] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dic[i + 2] = (max(s, W - s), H)",
      "mutated_line": "dic[i + 1] = (max(s, W - s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 1] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dic[i + 2] = (max(s, W - s), H)",
      "mutated_line": "dic[i + 0] = (max(s, W - s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 0] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dic[i + 2] = (max(s, W - s), H)",
      "mutated_line": "dic[i + 1] = (max(s, W - s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 1] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dic[i + 2] = (max(s, W - s), H)",
      "mutated_line": "dic[i + -2] = (max(s, W - s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + -2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dic[i + 2] = (max(s, W - s), H)",
      "mutated_line": "dic[i + 2] = (max(s, W + s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W + s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dic[i + 2] = (max(s, W - s), H)",
      "mutated_line": "dic[i + 2] = (max(s, W * s), H)",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W * s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W <= s and s < H + W or W + H + W < s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W <= s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W >= s and s < H + W or W + H + W < s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W >= s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W != s and s < H + W or W + H + W < s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W != s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W < s and s <= H + W or W + H + W < s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s <= H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W < s and s >= H + W or W + H + W < s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s >= H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W < s and s != H + W or W + H + W < s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s != H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W < s and s < H + W or W + H - W < s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H - W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W < s and s < H + W or (W + H) * W < s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or (W + H) * W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if s > H + W:",
      "mutated_line": "if s > H - W:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H - W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if s > H + W:",
      "mutated_line": "if s > H * W:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H * W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "s -= W + H + W",
      "mutated_line": "s -= W + H - W",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H - W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "s -= W + H + W",
      "mutated_line": "s -= (W + H) * W",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= (W + H) * W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dic[i + 1] = (W, min(s, H - s))",
      "mutated_line": "dic[i - 1] = (W, min(s, H - s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i - 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dic[i + 1] = (W, min(s, H - s))",
      "mutated_line": "dic[i * 1] = (W, min(s, H - s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i * 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dic[i + 2] = (W, max(s, H - s))",
      "mutated_line": "dic[i - 2] = (W, max(s, H - s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i - 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dic[i + 2] = (W, max(s, H - s))",
      "mutated_line": "dic[i * 2] = (W, max(s, H - s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i * 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s < W or (H + W < s and s < W - H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W - H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if s < W or (H + W < s and s < W + H + W):",
      "mutated_line": "if s < W or (H + W < s and s < W * H + W):",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W * H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W < s and s < H - W or W + H + W < s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H - W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W < s and s < H * W or W + H + W < s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H * W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W < s and s < H + W or W - H + W < s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W - H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif W < s and s < H + W or W + H + W < s:",
      "mutated_line": "elif W < s and s < H + W or W * H + W < s:",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W * H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "s -= W + H + W",
      "mutated_line": "s -= W - H + W",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W - H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "s -= W + H + W",
      "mutated_line": "s -= W * H + W",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W * H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dic[i + 1] = (W, min(s, H - s))",
      "mutated_line": "dic[i + 2] = (W, min(s, H - s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 2] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dic[i + 1] = (W, min(s, H - s))",
      "mutated_line": "dic[i + 0] = (W, min(s, H - s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 0] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dic[i + 1] = (W, min(s, H - s))",
      "mutated_line": "dic[i + 0] = (W, min(s, H - s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 0] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dic[i + 1] = (W, min(s, H - s))",
      "mutated_line": "dic[i + -1] = (W, min(s, H - s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + -1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dic[i + 1] = (W, min(s, H - s))",
      "mutated_line": "dic[i + 1] = (W, min(s, H + s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H + s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dic[i + 1] = (W, min(s, H - s))",
      "mutated_line": "dic[i + 1] = (W, min(s, H * s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H * s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dic[i + 2] = (W, max(s, H - s))",
      "mutated_line": "dic[i + 3] = (W, max(s, H - s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 3] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dic[i + 2] = (W, max(s, H - s))",
      "mutated_line": "dic[i + 1] = (W, max(s, H - s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 1] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dic[i + 2] = (W, max(s, H - s))",
      "mutated_line": "dic[i + 0] = (W, max(s, H - s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 0] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dic[i + 2] = (W, max(s, H - s))",
      "mutated_line": "dic[i + 1] = (W, max(s, H - s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 1] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dic[i + 2] = (W, max(s, H - s))",
      "mutated_line": "dic[i + -2] = (W, max(s, H - s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + -2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dic[i + 2] = (W, max(s, H - s))",
      "mutated_line": "dic[i + 2] = (W, max(s, H + s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H + s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dic[i + 2] = (W, max(s, H - s))",
      "mutated_line": "dic[i + 2] = (W, max(s, H * s))",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H * s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sq.sort(key=lambda x: x[0] * x[1])",
      "mutated_line": "sq.sort(key=lambda x: x[1] * x[1])",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[1] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sq.sort(key=lambda x: x[0] * x[1])",
      "mutated_line": "sq.sort(key=lambda x: x[-1] * x[1])",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[-1] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sq.sort(key=lambda x: x[0] * x[1])",
      "mutated_line": "sq.sort(key=lambda x: x[1] * x[1])",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[1] * x[1])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sq.sort(key=lambda x: x[0] * x[1])",
      "mutated_line": "sq.sort(key=lambda x: x[0] * x[2])",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[2])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sq.sort(key=lambda x: x[0] * x[1])",
      "mutated_line": "sq.sort(key=lambda x: x[0] * x[0])",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[0])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sq.sort(key=lambda x: x[0] * x[1])",
      "mutated_line": "sq.sort(key=lambda x: x[0] * x[0])",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[0])\n    return [W * H for (W, H) in sq]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "sq.sort(key=lambda x: x[0] * x[1])",
      "mutated_line": "sq.sort(key=lambda x: x[0] * x[-1])",
      "code": "def simulate_cake_cutting(n, w, d, cuts):\n    dic = {}\n    dic[1] = (w, d)\n    for i in range(n):\n        (p, s) = cuts[i]\n        (W, H) = dic[p]\n        for j in range(p, i + 1):\n            dic[j] = dic[j + 1]\n        cycle = 2 * (H + W)\n        s %= cycle\n        if s < W or (H + W < s and s < W + H + W):\n            if W < s:\n                s -= H + W\n            dic[i + 1] = (min(s, W - s), H)\n            dic[i + 2] = (max(s, W - s), H)\n        elif W < s and s < H + W or W + H + W < s:\n            if s > H + W:\n                s -= W + H + W\n            else:\n                s -= W\n            dic[i + 1] = (W, min(s, H - s))\n            dic[i + 2] = (W, max(s, H - s))\n    sq = list(dic.values())\n    sq.sort(key=lambda x: x[0] * x[-1])\n    return [W * H for (W, H) in sq]"
    }
  ]
}