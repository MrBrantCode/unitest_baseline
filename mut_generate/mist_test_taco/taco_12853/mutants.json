{
  "task_id": "taco_12853",
  "entry_point": "infix_to_postfix",
  "mutant_count": 100,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "output = ''",
      "mutated_line": "output = 'MUTATED'",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = 'MUTATED'\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "output += stack.pop()",
      "mutated_line": "output -= stack.pop()",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output -= stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "return ch.isalpha() or ch.isdigit()",
      "mutated_line": "return ch.isalpha() and ch.isdigit()",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() and ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '': 1, '*': 2, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '': 2, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 2, '-': 1, '*': 2, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 2, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 0, '-': 1, '*': 2, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 0, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 0, '-': 1, '*': 2, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 0, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': -1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': -1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 2, '*': 2, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 2, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 0, '*': 2, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 0, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 0, '*': 2, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 0, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': -1, '*': 2, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': -1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 3, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 3, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 1, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 1, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 0, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 0, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 1, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 1, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': -2, '/': 2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': -2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 3, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 3, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 1, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 1, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 0, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 0, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 1, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 1, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': -2, '^': 3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': -2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 4}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 4}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 2}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 2}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 0}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 0}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 1}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 1}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}",
      "mutated_line": "precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': -3}",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': -3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "output += char",
      "mutated_line": "output -= char",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output -= char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif char == '(':",
      "mutated_line": "elif char != '(':",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char != '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif char == '(':",
      "mutated_line": "elif char == '':",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif char == ')':",
      "mutated_line": "elif char != ')':",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char != ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif char == ')':",
      "mutated_line": "elif char == '':",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == '':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack or stack[-1] != '(':",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack or stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "output += stack.pop()",
      "mutated_line": "output -= stack.pop()",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output -= stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-1] == '(' or (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' or (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack and stack[-1] == '(':",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] == '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-1] != '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] != '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-1] == '(' and (char == '+' and char == '-' and (char == '*') and (char == '/') and (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' and char == '-' and (char == '*') and (char == '/') and (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence or (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence or (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack and stack[-1] != '':",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-1] == '' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-1] == '(' and (char != '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char != '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-1] == '(' and (char == '+' or char != '-' or char == '*' or (char == '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char != '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char != '*' or (char == '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char != '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char != '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char != '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char != '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char != '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char not in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char not in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[-1] not in precedence and precedence[char] > precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence and precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack or stack[-1] != '(' or (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack or stack[-1] != '(' or (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "output += stack.pop()",
      "mutated_line": "output -= stack.pop()",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output -= stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack and stack[+1] != '(':",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[+1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[+1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[+1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-1] == '(' and (char == '' or char == '-' or char == '*' or (char == '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-1] == '(' and (char == '+' or char == '' or char == '*' or (char == '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '' or (char == '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[-1] in precedence or precedence[char] > precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] >= precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] >= precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] <= precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] != precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] != precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-1] == '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] == '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-1] != '(' and (char not in precedence and precedence[char] <= precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence and precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack and stack[-2] != '(':",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-2] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack and stack[-0] != '(':",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-0] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack and stack[-0] != '(':",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-0] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack and stack[--1] != '(':",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[--1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-2] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-2] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-0] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-0] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[-0] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-0] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or char == '/' or char == '^'):",
      "mutated_line": "elif stack[--1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[--1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-1] != '' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-1] != '(' and (char in precedence or precedence[char] <= precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] < precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] < precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] > precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] > precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] == precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] == precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[+1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[+1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[+1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[+1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[-2] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-2] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[-0] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-0] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[-0] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-0] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[--1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[--1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[+1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[+1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-2] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-2] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-0] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-0] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-0] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-0] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[--1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[--1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-2]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-2]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-0]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-0]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-0]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-0]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):",
      "mutated_line": "elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[--1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[--1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[+1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[+1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-2]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-2]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-0]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-0]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-0]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-0]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[-1]]):",
      "mutated_line": "while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[--1]]):",
      "code": "def infix_to_postfix(infix_expression: str) -> str:\n\n    def is_operand(ch: str) -> bool:\n        return ch.isalpha() or ch.isdigit()\n    output = ''\n    stack = []\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n    for char in infix_expression:\n        if is_operand(char):\n            output += char\n        elif not stack:\n            stack.append(char)\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        elif stack[-1] == '(' and (char == '+' or char == '-' or char == '*' or (char == '/') or (char == '^')):\n            stack.append(char)\n        elif char in precedence and (stack[-1] not in precedence or precedence[char] > precedence[stack[-1]]):\n            stack.append(char)\n        else:\n            while stack and stack[-1] != '(' and (char not in precedence or precedence[char] <= precedence[stack[--1]]):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    }
  ]
}