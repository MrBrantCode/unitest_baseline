{
  "task_id": "taco_16075",
  "entry_point": "calculate_max_coins",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "currsum = 0",
      "mutated_line": "currsum = 1",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 1\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "currsum = 0",
      "mutated_line": "currsum = -1",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = -1\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "currsum = 0",
      "mutated_line": "currsum = 1",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 1\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans = [0] * n",
      "mutated_line": "ans = [0] / n",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] / n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans = [0] * n",
      "mutated_line": "ans = [0] + n",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] + n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans = [0] * n",
      "mutated_line": "ans = [0] ** n",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] ** n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "curr = 0",
      "mutated_line": "curr = 1",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 1\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "curr = 0",
      "mutated_line": "curr = -1",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = -1\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "curr = 0",
      "mutated_line": "curr = 1",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 1\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if k > 0:",
      "mutated_line": "if k >= 0:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k >= 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if k > 0:",
      "mutated_line": "if k <= 0:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k <= 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if k > 0:",
      "mutated_line": "if k != 0:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k != 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if k > 0:",
      "mutated_line": "if k > 1:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 1:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if k > 0:",
      "mutated_line": "if k > -1:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > -1:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if k > 0:",
      "mutated_line": "if k > 1:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 1:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = [0] * n",
      "mutated_line": "ans = [1] * n",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [1] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = [0] * n",
      "mutated_line": "ans = [-1] * n",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [-1] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = [0] * n",
      "mutated_line": "ans = [1] * n",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [1] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if curr < k:",
      "mutated_line": "if curr <= k:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr <= k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if curr < k:",
      "mutated_line": "if curr >= k:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr >= k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if curr < k:",
      "mutated_line": "if curr != k:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr != k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "curr += 1",
      "mutated_line": "curr -= 1",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr -= 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "currsum += pc[i][1]",
      "mutated_line": "currsum -= pc[i][1]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum -= pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr += 1",
      "mutated_line": "curr += 2",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 2\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr += 1",
      "mutated_line": "curr += 0",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 0\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr += 1",
      "mutated_line": "curr += 0",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 0\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr += 1",
      "mutated_line": "curr += -1",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += -1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ans[powerindex[i]] = currsum + pc[i][1]",
      "mutated_line": "ans[powerindex[i]] = currsum - pc[i][1]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum - pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ans[powerindex[i]] = currsum + pc[i][1]",
      "mutated_line": "ans[powerindex[i]] = currsum * pc[i][1]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum * pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if pc[i][1] > least:",
      "mutated_line": "if pc[i][1] >= least:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] >= least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if pc[i][1] > least:",
      "mutated_line": "if pc[i][1] <= least:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] <= least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if pc[i][1] > least:",
      "mutated_line": "if pc[i][1] != least:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] != least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "currsum -= least",
      "mutated_line": "currsum += least",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum += least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "currsum += pc[i][1]",
      "mutated_line": "currsum -= pc[i][1]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum -= pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "currsum += pc[i][1]",
      "mutated_line": "currsum += pc[i][2]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][2]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "currsum += pc[i][1]",
      "mutated_line": "currsum += pc[i][0]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][0]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "currsum += pc[i][1]",
      "mutated_line": "currsum += pc[i][0]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][0]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "currsum += pc[i][1]",
      "mutated_line": "currsum += pc[i][-1]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][-1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(coinscollected, pc[i][1])",
      "mutated_line": "heapq.heappush(coinscollected, pc[i][2])",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][2])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(coinscollected, pc[i][1])",
      "mutated_line": "heapq.heappush(coinscollected, pc[i][0])",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][0])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(coinscollected, pc[i][1])",
      "mutated_line": "heapq.heappush(coinscollected, pc[i][0])",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][0])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "heapq.heappush(coinscollected, pc[i][1])",
      "mutated_line": "heapq.heappush(coinscollected, pc[i][-1])",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][-1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans[powerindex[i]] = currsum + pc[i][1]",
      "mutated_line": "ans[powerindex[i]] = currsum + pc[i][2]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][2]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans[powerindex[i]] = currsum + pc[i][1]",
      "mutated_line": "ans[powerindex[i]] = currsum + pc[i][0]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][0]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans[powerindex[i]] = currsum + pc[i][1]",
      "mutated_line": "ans[powerindex[i]] = currsum + pc[i][0]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][0]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans[powerindex[i]] = currsum + pc[i][1]",
      "mutated_line": "ans[powerindex[i]] = currsum + pc[i][-1]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][-1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if pc[i][1] > least:",
      "mutated_line": "if pc[i][2] > least:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][2] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if pc[i][1] > least:",
      "mutated_line": "if pc[i][0] > least:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][0] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if pc[i][1] > least:",
      "mutated_line": "if pc[i][0] > least:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][0] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if pc[i][1] > least:",
      "mutated_line": "if pc[i][-1] > least:",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][-1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "currsum += pc[i][1]",
      "mutated_line": "currsum += pc[i][2]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][2]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "currsum += pc[i][1]",
      "mutated_line": "currsum += pc[i][0]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][0]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "currsum += pc[i][1]",
      "mutated_line": "currsum += pc[i][0]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][0]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "currsum += pc[i][1]",
      "mutated_line": "currsum += pc[i][-1]",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][1])\n                    currsum -= least\n                    currsum += pc[i][-1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(coinscollected, pc[i][1])",
      "mutated_line": "heapq.heappush(coinscollected, pc[i][2])",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][2])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(coinscollected, pc[i][1])",
      "mutated_line": "heapq.heappush(coinscollected, pc[i][0])",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][0])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(coinscollected, pc[i][1])",
      "mutated_line": "heapq.heappush(coinscollected, pc[i][0])",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][0])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(coinscollected, pc[i][1])",
      "mutated_line": "heapq.heappush(coinscollected, pc[i][-1])",
      "code": "import heapq\n\ndef calculate_max_coins(n, k, powers, coins):\n    pc = [[powers[i], coins[i]] for i in range(n)]\n    pc.sort()\n    powerindex = sorted([i for i in range(n)], key=lambda i: powers[i])\n    currsum = 0\n    coinscollected = []\n    ans = [0] * n\n    curr = 0\n    if k > 0:\n        for i in range(n):\n            if curr < k:\n                heapq.heappush(coinscollected, pc[i][1])\n                curr += 1\n                currsum += pc[i][1]\n                ans[powerindex[i]] = currsum\n            else:\n                ans[powerindex[i]] = currsum + pc[i][1]\n                least = heapq.heappop(coinscollected)\n                if pc[i][1] > least:\n                    heapq.heappush(coinscollected, pc[i][-1])\n                    currsum -= least\n                    currsum += pc[i][1]\n                else:\n                    heapq.heappush(coinscollected, least)\n    else:\n        ans = coins\n    return ans"
    }
  ]
}