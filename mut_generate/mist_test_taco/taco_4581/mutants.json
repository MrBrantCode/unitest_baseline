{
  "task_id": "taco_4581",
  "entry_point": "shortest_xy_distance",
  "mutant_count": 82,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "row = [0 for _ in range(M)]",
      "mutated_line": "row = [1 for _ in range(M)]",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [1 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "row = [0 for _ in range(M)]",
      "mutated_line": "row = [-1 for _ in range(M)]",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [-1 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "row = [0 for _ in range(M)]",
      "mutated_line": "row = [1 for _ in range(M)]",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [1 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_dist = float('inf')",
      "mutated_line": "min_dist = float('')",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 0 and x >= N and (y < 0) and (y >= M) and visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 and x >= N and (y < 0) and (y >= M) and visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[x][y] = 1",
      "mutated_line": "visited[x][y] = 2",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 2\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[x][y] = 1",
      "mutated_line": "visited[x][y] = 0",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 0\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[x][y] = 1",
      "mutated_line": "visited[x][y] = 0",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 0\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[x][y] = 1",
      "mutated_line": "visited[x][y] = -1",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = -1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if grid[x][y] == 'Y':",
      "mutated_line": "if grid[x][y] != 'Y':",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] != 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if grid[i][j] == 'X':",
      "mutated_line": "if grid[i][j] != 'X':",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] != 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x <= 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x <= 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x >= 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x >= 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x != 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x != 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 0 or x > N or y < 0 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x > N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 0 or x < N or y < 0 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x < N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 0 or x == N or y < 0 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x == N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 0 or x >= N or y <= 0 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y <= 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 0 or x >= N or y >= 0 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y >= 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 0 or x >= N or y != 0 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y != 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 0 or x >= N or y < 0 or (y > M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y > M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 0 or x >= N or y < 0 or (y < M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y < M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 0 or x >= N or y < 0 or (y == M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y == M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if grid[x][y] == 'Y':",
      "mutated_line": "if grid[x][y] == '':",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == '':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if grid[i][j] == 'X':",
      "mutated_line": "if grid[i][j] == '':",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 1 or x >= N or y < 0 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 1 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < -1 or x >= N or y < 0 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < -1 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 1 or x >= N or y < 0 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 1 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 0 or x >= N or y < 1 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 1 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 0 or x >= N or y < -1 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < -1 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x < 0 or x >= N or y < 0 or y >= M or visited[x][y]:",
      "mutated_line": "if x < 0 or x >= N or y < 1 or (y >= M) or visited[x][y]:",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 1 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "queue.append((x + 1, y, dist + 1))",
      "mutated_line": "queue.append((x - 1, y, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "queue.append((x + 1, y, dist + 1))",
      "mutated_line": "queue.append((x * 1, y, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x * 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "queue.append((x + 1, y, dist + 1))",
      "mutated_line": "queue.append((x + 1, y, dist - 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist - 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "queue.append((x + 1, y, dist + 1))",
      "mutated_line": "queue.append((x + 1, y, dist * 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist * 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "queue.append((x, y + 1, dist + 1))",
      "mutated_line": "queue.append((x, y - 1, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "queue.append((x, y + 1, dist + 1))",
      "mutated_line": "queue.append((x, y * 1, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y * 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "queue.append((x, y + 1, dist + 1))",
      "mutated_line": "queue.append((x, y + 1, dist - 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist - 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "queue.append((x, y + 1, dist + 1))",
      "mutated_line": "queue.append((x, y + 1, dist * 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist * 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "queue.append((x - 1, y, dist + 1))",
      "mutated_line": "queue.append((x + 1, y, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "queue.append((x - 1, y, dist + 1))",
      "mutated_line": "queue.append((x * 1, y, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x * 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "queue.append((x - 1, y, dist + 1))",
      "mutated_line": "queue.append((x - 1, y, dist - 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist - 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "queue.append((x - 1, y, dist + 1))",
      "mutated_line": "queue.append((x - 1, y, dist * 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist * 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((x, y - 1, dist + 1))",
      "mutated_line": "queue.append((x, y + 1, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((x, y - 1, dist + 1))",
      "mutated_line": "queue.append((x, y * 1, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y * 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((x, y - 1, dist + 1))",
      "mutated_line": "queue.append((x, y - 1, dist - 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist - 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((x, y - 1, dist + 1))",
      "mutated_line": "queue.append((x, y - 1, dist * 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist * 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue.append((x + 1, y, dist + 1))",
      "mutated_line": "queue.append((x + 2, y, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 2, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue.append((x + 1, y, dist + 1))",
      "mutated_line": "queue.append((x + 0, y, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 0, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue.append((x + 1, y, dist + 1))",
      "mutated_line": "queue.append((x + 0, y, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 0, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue.append((x + 1, y, dist + 1))",
      "mutated_line": "queue.append((x + -1, y, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + -1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue.append((x + 1, y, dist + 1))",
      "mutated_line": "queue.append((x + 1, y, dist + 2))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 2))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue.append((x + 1, y, dist + 1))",
      "mutated_line": "queue.append((x + 1, y, dist + 0))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 0))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue.append((x + 1, y, dist + 1))",
      "mutated_line": "queue.append((x + 1, y, dist + 0))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 0))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "queue.append((x + 1, y, dist + 1))",
      "mutated_line": "queue.append((x + 1, y, dist + -1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + -1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append((x, y + 1, dist + 1))",
      "mutated_line": "queue.append((x, y + 2, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 2, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append((x, y + 1, dist + 1))",
      "mutated_line": "queue.append((x, y + 0, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 0, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append((x, y + 1, dist + 1))",
      "mutated_line": "queue.append((x, y + 0, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 0, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append((x, y + 1, dist + 1))",
      "mutated_line": "queue.append((x, y + -1, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + -1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append((x, y + 1, dist + 1))",
      "mutated_line": "queue.append((x, y + 1, dist + 2))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 2))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append((x, y + 1, dist + 1))",
      "mutated_line": "queue.append((x, y + 1, dist + 0))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 0))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append((x, y + 1, dist + 1))",
      "mutated_line": "queue.append((x, y + 1, dist + 0))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 0))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append((x, y + 1, dist + 1))",
      "mutated_line": "queue.append((x, y + 1, dist + -1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + -1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((x - 1, y, dist + 1))",
      "mutated_line": "queue.append((x - 2, y, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 2, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((x - 1, y, dist + 1))",
      "mutated_line": "queue.append((x - 0, y, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 0, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((x - 1, y, dist + 1))",
      "mutated_line": "queue.append((x - 0, y, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 0, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((x - 1, y, dist + 1))",
      "mutated_line": "queue.append((x - -1, y, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - -1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((x - 1, y, dist + 1))",
      "mutated_line": "queue.append((x - 1, y, dist + 2))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 2))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((x - 1, y, dist + 1))",
      "mutated_line": "queue.append((x - 1, y, dist + 0))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 0))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((x - 1, y, dist + 1))",
      "mutated_line": "queue.append((x - 1, y, dist + 0))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 0))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((x - 1, y, dist + 1))",
      "mutated_line": "queue.append((x - 1, y, dist + -1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + -1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((x, y - 1, dist + 1))",
      "mutated_line": "queue.append((x, y - 2, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 2, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((x, y - 1, dist + 1))",
      "mutated_line": "queue.append((x, y - 0, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 0, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((x, y - 1, dist + 1))",
      "mutated_line": "queue.append((x, y - 0, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 0, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((x, y - 1, dist + 1))",
      "mutated_line": "queue.append((x, y - -1, dist + 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - -1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((x, y - 1, dist + 1))",
      "mutated_line": "queue.append((x, y - 1, dist + 2))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 2))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((x, y - 1, dist + 1))",
      "mutated_line": "queue.append((x, y - 1, dist + 0))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 0))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((x, y - 1, dist + 1))",
      "mutated_line": "queue.append((x, y - 1, dist + 0))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 0))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((x, y - 1, dist + 1))",
      "mutated_line": "queue.append((x, y - 1, dist + -1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + -1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 0))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "queue.append((i, j, 0))",
      "mutated_line": "queue.append((i, j, 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 1))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "queue.append((i, j, 0))",
      "mutated_line": "queue.append((i, j, -1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, -1))\n    return bfs(visited, queue, grid)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "queue.append((i, j, 0))",
      "mutated_line": "queue.append((i, j, 1))",
      "code": "from copy import deepcopy\nfrom collections import deque\n\ndef shortest_xy_distance(grid, N, M):\n\n    def bfs(visited, queue, grid):\n        min_dist = float('inf')\n        while queue:\n            (x, y, dist) = queue.popleft()\n            if x < 0 or x >= N or y < 0 or (y >= M) or visited[x][y]:\n                continue\n            visited[x][y] = 1\n            if grid[x][y] == 'Y':\n                min_dist = min(dist, min_dist)\n            queue.append((x + 1, y, dist + 1))\n            queue.append((x, y + 1, dist + 1))\n            queue.append((x - 1, y, dist + 1))\n            queue.append((x, y - 1, dist + 1))\n        return min_dist\n    row = [0 for _ in range(M)]\n    visited = [deepcopy(row) for _ in range(N)]\n    queue = deque()\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'X':\n                queue.append((i, j, 1))\n    return bfs(visited, queue, grid)"
    }
  ]
}