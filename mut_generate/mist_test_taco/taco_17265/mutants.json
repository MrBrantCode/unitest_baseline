{
  "task_id": "taco_17265",
  "entry_point": "find_permutation_for_takahashi",
  "mutant_count": 146,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "ans = [-1] * n",
      "mutated_line": "ans = [-1] / n",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] / n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "ans = [-1] * n",
      "mutated_line": "ans = [-1] + n",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] + n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "ans = [-1] * n",
      "mutated_line": "ans = [-1] ** n",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] ** n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "a -= 1",
      "mutated_line": "a += 1",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a += 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "b -= 1",
      "mutated_line": "b += 1",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b += 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(even) <= zerocnt:",
      "mutated_line": "if len(even) < zerocnt:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) < zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(even) <= zerocnt:",
      "mutated_line": "if len(even) > zerocnt:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) > zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(even) <= zerocnt:",
      "mutated_line": "if len(even) == zerocnt:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) == zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(10 * 6)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 * 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(10 + 6)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 + 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(2, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(0, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(0, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(-1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n - 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n * 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "def dfs(x, last=-1, d=0):",
      "mutated_line": "def dfs(x, last=+1, d=0):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=+1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "def dfs(x, last=-1, d=0):",
      "mutated_line": "def dfs(x, last=-1, d=1):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=1):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "def dfs(x, last=-1, d=0):",
      "mutated_line": "def dfs(x, last=-1, d=-1):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=-1):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "def dfs(x, last=-1, d=0):",
      "mutated_line": "def dfs(x, last=-1, d=1):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=1):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 2 != 0:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 != 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a -= 1",
      "mutated_line": "a -= 2",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 2\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 0\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 0\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a -= 1",
      "mutated_line": "a -= -1",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= -1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b -= 1",
      "mutated_line": "b -= 2",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 2\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 0\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 0\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b -= 1",
      "mutated_line": "b -= -1",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= -1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dfs(0)",
      "mutated_line": "dfs(1)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(1)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dfs(0)",
      "mutated_line": "dfs(-1)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(-1)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dfs(0)",
      "mutated_line": "dfs(1)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(1)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[1] - nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] - nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = (nums[0] + nums[1]) * nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = (nums[0] + nums[1]) * nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "elif len(odd) <= zerocnt:",
      "mutated_line": "elif len(odd) < zerocnt:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) < zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "elif len(odd) <= zerocnt:",
      "mutated_line": "elif len(odd) > zerocnt:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) > zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "elif len(odd) <= zerocnt:",
      "mutated_line": "elif len(odd) == zerocnt:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) == zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "return ans if -1 not in ans else -1",
      "mutated_line": "return ans if -1 in ans else -1",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 in ans else -1"
    },
    {
      "operator": "UOI",
      "lineno": 57,
      "original_line": "return ans if -1 not in ans else -1",
      "mutated_line": "return ans if -1 not in ans else +1",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else +1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(11 ** 6)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(11 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(9 ** 6)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(9 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(0 ** 6)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(0 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(1 ** 6)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(1 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(-10 ** 6)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(-10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(10 ** 7)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 7)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(10 ** 5)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 5)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(10 ** 0)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 0)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(10 ** 1)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 1)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sys.setrecursionlimit(10 ** 6)",
      "mutated_line": "sys.setrecursionlimit(10 ** -6)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** -6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "ans = [-1] * n",
      "mutated_line": "ans = [+1] * n",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [+1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 2):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 0):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 0):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + -1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "def dfs(x, last=-1, d=0):",
      "mutated_line": "def dfs(x, last=-2, d=0):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-2, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "def dfs(x, last=-1, d=0):",
      "mutated_line": "def dfs(x, last=-0, d=0):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-0, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "def dfs(x, last=-1, d=0):",
      "mutated_line": "def dfs(x, last=-0, d=0):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-0, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "def dfs(x, last=-1, d=0):",
      "mutated_line": "def dfs(x, last=--1, d=0):",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=--1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d * 2 == 0:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d * 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d + 2 == 0:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d + 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 2 == 1:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 1:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 2 == -1:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == -1:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 2 == 1:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 1:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if nxt == last:",
      "mutated_line": "if nxt != last:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt != last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "zerocnt = len(nums[0])",
      "mutated_line": "zerocnt = len(nums[1])",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[1])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "zerocnt = len(nums[0])",
      "mutated_line": "zerocnt = len(nums[-1])",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[-1])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "zerocnt = len(nums[0])",
      "mutated_line": "zerocnt = len(nums[1])",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[1])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] - nums[1] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] - nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] * nums[1] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] * nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[1] - nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] - nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = (nums[0] + nums[1]) * nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = (nums[0] + nums[1]) * nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "UOI",
      "lineno": 57,
      "original_line": "return ans if -1 not in ans else -1",
      "mutated_line": "return ans if +1 not in ans else -1",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if +1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return ans if -1 not in ans else -1",
      "mutated_line": "return ans if -1 not in ans else -2",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -2"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return ans if -1 not in ans else -1",
      "mutated_line": "return ans if -1 not in ans else -0",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -0"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return ans if -1 not in ans else -1",
      "mutated_line": "return ans if -1 not in ans else -0",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -0"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return ans if -1 not in ans else -1",
      "mutated_line": "return ans if -1 not in ans else --1",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else --1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = [-1] * n",
      "mutated_line": "ans = [-2] * n",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-2] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = [-1] * n",
      "mutated_line": "ans = [-0] * n",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-0] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = [-1] * n",
      "mutated_line": "ans = [-0] * n",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-0] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = [-1] * n",
      "mutated_line": "ans = [--1] * n",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [--1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 3 == 0:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 3 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 1 == 0:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 1 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 0 == 0:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 0 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 1 == 0:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 1 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % -2 == 0:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % -2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dfs(nxt, x, d + 1)",
      "mutated_line": "dfs(nxt, x, d - 1)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d - 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dfs(nxt, x, d + 1)",
      "mutated_line": "dfs(nxt, x, d * 1)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d * 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[1] + nums[3]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[3]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[1] + nums[1]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[1]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[1] + nums[0]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[0]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[1] + nums[1]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[1]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[1] + nums[-2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[-2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] - nums[1] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] - nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] * nums[1] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] * nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for num in nums[1]:",
      "mutated_line": "for num in nums[2]:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[2]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for num in nums[1]:",
      "mutated_line": "for num in nums[0]:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[0]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for num in nums[1]:",
      "mutated_line": "for num in nums[0]:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[0]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for num in nums[1]:",
      "mutated_line": "for num in nums[-1]:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[-1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for num in nums[2]:",
      "mutated_line": "for num in nums[3]:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[3]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for num in nums[2]:",
      "mutated_line": "for num in nums[1]:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[1]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for num in nums[2]:",
      "mutated_line": "for num in nums[0]:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[0]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for num in nums[2]:",
      "mutated_line": "for num in nums[1]:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[1]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for num in nums[2]:",
      "mutated_line": "for num in nums[-2]:",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[-2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "rest = nums[0]",
      "mutated_line": "rest = nums[1]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[1]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "rest = nums[0]",
      "mutated_line": "rest = nums[-1]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[-1]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "rest = nums[0]",
      "mutated_line": "rest = nums[1]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[1]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return ans if -1 not in ans else -1",
      "mutated_line": "return ans if -2 not in ans else -1",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -2 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return ans if -1 not in ans else -1",
      "mutated_line": "return ans if -0 not in ans else -1",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -0 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return ans if -1 not in ans else -1",
      "mutated_line": "return ans if -0 not in ans else -1",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -0 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return ans if -1 not in ans else -1",
      "mutated_line": "return ans if --1 not in ans else -1",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if --1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "nums[i % 3].append(i)",
      "mutated_line": "nums[i * 3].append(i)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i * 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "nums[i % 3].append(i)",
      "mutated_line": "nums[i + 3].append(i)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i + 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dfs(nxt, x, d + 1)",
      "mutated_line": "dfs(nxt, x, d + 2)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 2)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dfs(nxt, x, d + 1)",
      "mutated_line": "dfs(nxt, x, d + 0)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 0)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dfs(nxt, x, d + 1)",
      "mutated_line": "dfs(nxt, x, d + 0)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 0)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dfs(nxt, x, d + 1)",
      "mutated_line": "dfs(nxt, x, d + -1)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + -1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[1] + nums[1] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[1] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[-1] + nums[1] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[-1] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[1] + nums[1] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[1] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[2] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[2] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[0] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[0] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[0] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[0] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[-1] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[-1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[1] + nums[3]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[3]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[1] + nums[1]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[1]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[1] + nums[0]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[1] + nums[1]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[1]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[1] + nums[-2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[-2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nums[i % 3].append(i)",
      "mutated_line": "nums[i % 4].append(i)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 4].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nums[i % 3].append(i)",
      "mutated_line": "nums[i % 2].append(i)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 2].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nums[i % 3].append(i)",
      "mutated_line": "nums[i % 0].append(i)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 0].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nums[i % 3].append(i)",
      "mutated_line": "nums[i % 1].append(i)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 1].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "nums[i % 3].append(i)",
      "mutated_line": "nums[i % -3].append(i)",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % -3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[even_node] = nums[0].pop()",
      "mutated_line": "ans[even_node] = nums[1].pop()",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[1].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[even_node] = nums[0].pop()",
      "mutated_line": "ans[even_node] = nums[-1].pop()",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[-1].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[even_node] = nums[0].pop()",
      "mutated_line": "ans[even_node] = nums[1].pop()",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[1].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[1] + nums[1] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[1] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[-1] + nums[1] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[-1] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[1] + nums[1] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[1] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[2] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[2] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[0] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[0] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[0] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[0] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rest = nums[0] + nums[1] + nums[2]",
      "mutated_line": "rest = nums[0] + nums[-1] + nums[2]",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[0].pop()\n        rest = nums[0] + nums[-1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans[odd_node] = nums[0].pop()",
      "mutated_line": "ans[odd_node] = nums[1].pop()",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[1].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans[odd_node] = nums[0].pop()",
      "mutated_line": "ans[odd_node] = nums[-1].pop()",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[-1].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans[odd_node] = nums[0].pop()",
      "mutated_line": "ans[odd_node] = nums[1].pop()",
      "code": "def find_permutation_for_takahashi(n, edges):\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n    edge = [[] for _ in range(n)]\n    ans = [-1] * n\n    odd = []\n    even = []\n    nums = [[], [], []]\n    for i in range(1, n + 1):\n        nums[i % 3].append(i)\n\n    def dfs(x, last=-1, d=0):\n        if d % 2 == 0:\n            even.append(x)\n        else:\n            odd.append(x)\n        for nxt in edge[x]:\n            if nxt == last:\n                continue\n            dfs(nxt, x, d + 1)\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n    dfs(0)\n    zerocnt = len(nums[0])\n    if len(even) <= zerocnt:\n        for even_node in even:\n            ans[even_node] = nums[0].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    elif len(odd) <= zerocnt:\n        for odd_node in odd:\n            ans[odd_node] = nums[1].pop()\n        rest = nums[0] + nums[1] + nums[2]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n    else:\n        for num in nums[1]:\n            ans[even.pop()] = num\n        for num in nums[2]:\n            ans[odd.pop()] = num\n        rest = nums[0]\n        for even_node in even:\n            ans[even_node] = rest.pop()\n        for odd_node in odd:\n            ans[odd_node] = rest.pop()\n    return ans if -1 not in ans else -1"
    }
  ]
}