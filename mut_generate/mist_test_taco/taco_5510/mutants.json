{
  "task_id": "taco_5510",
  "entry_point": "maximize_exam_score",
  "mutant_count": 38,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ct = 0  # Current total time spent",
      "mutated_line": "for (ai, ti, i) in problems:",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 1\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ct = 0  # Current total time spent",
      "mutated_line": "for (ai, ti, i) in problems:",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = -1\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ct = 0  # Current total time spent",
      "mutated_line": "for (ai, ti, i) in problems:",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 1\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "ct += ti",
      "mutated_line": "ct -= ti",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct -= ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if ct + ti > T:",
      "mutated_line": "if ct + ti >= T:",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti >= T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if ct + ti > T:",
      "mutated_line": "if ct + ti <= T:",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti <= T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if ct + ti > T:",
      "mutated_line": "if ct + ti != T:",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti != T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "while h and h[0][0] < len(h):",
      "mutated_line": "while h or h[0][0] < len(h):",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h or h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "ct += ti",
      "mutated_line": "ct -= ti",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct -= ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "problem_indices = [i + 1 for _, _, i in h]",
      "mutated_line": "problem_indices = [i - 1 for (_, _, i) in h]",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i - 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "problem_indices = [i + 1 for _, _, i in h]",
      "mutated_line": "problem_indices = [i * 1 for (_, _, i) in h]",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i * 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if ct + ti > T:",
      "mutated_line": "if ct - ti > T:",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct - ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if ct + ti > T:",
      "mutated_line": "if ct * ti > T:",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct * ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif len(h) > ai:",
      "mutated_line": "elif len(h) >= ai:",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) >= ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif len(h) > ai:",
      "mutated_line": "elif len(h) <= ai:",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) <= ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif len(h) > ai:",
      "mutated_line": "elif len(h) != ai:",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) != ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while h and h[0][0] < len(h):",
      "mutated_line": "while h and h[0][0] <= len(h):",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] <= len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while h and h[0][0] < len(h):",
      "mutated_line": "while h and h[0][0] >= len(h):",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] >= len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while h and h[0][0] < len(h):",
      "mutated_line": "while h and h[0][0] != len(h):",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] != len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "problem_indices = [i + 1 for _, _, i in h]",
      "mutated_line": "problem_indices = [i + 2 for (_, _, i) in h]",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 2 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "problem_indices = [i + 1 for _, _, i in h]",
      "mutated_line": "problem_indices = [i + 0 for (_, _, i) in h]",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 0 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "problem_indices = [i + 1 for _, _, i in h]",
      "mutated_line": "problem_indices = [i + 0 for (_, _, i) in h]",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 0 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "problem_indices = [i + 1 for _, _, i in h]",
      "mutated_line": "problem_indices = [i + -1 for (_, _, i) in h]",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + -1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "heappush(h, (ai, -ti, i))",
      "mutated_line": "heappush(h, (ai, +ti, i))",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, +ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "problems.sort(key=lambda x: (x[1], -x[0]))",
      "mutated_line": "h = []",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], +x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while h and h[0][0] < len(h):",
      "mutated_line": "while h and h[0][1] < len(h):",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][1] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while h and h[0][0] < len(h):",
      "mutated_line": "while h and h[0][-1] < len(h):",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][-1] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while h and h[0][0] < len(h):",
      "mutated_line": "while h and h[0][1] < len(h):",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][1] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "problems.sort(key=lambda x: (x[1], -x[0]))",
      "mutated_line": "h = []",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[2], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "problems.sort(key=lambda x: (x[1], -x[0]))",
      "mutated_line": "h = []",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[0], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "problems.sort(key=lambda x: (x[1], -x[0]))",
      "mutated_line": "h = []",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[0], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "problems.sort(key=lambda x: (x[1], -x[0]))",
      "mutated_line": "h = []",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[-1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while h and h[0][0] < len(h):",
      "mutated_line": "while h and h[1][0] < len(h):",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[1][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while h and h[0][0] < len(h):",
      "mutated_line": "while h and h[-1][0] < len(h):",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[-1][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while h and h[0][0] < len(h):",
      "mutated_line": "while h and h[1][0] < len(h):",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[0]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[1][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "problems.sort(key=lambda x: (x[1], -x[0]))",
      "mutated_line": "h = []",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[1]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "problems.sort(key=lambda x: (x[1], -x[0]))",
      "mutated_line": "h = []",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[-1]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "problems.sort(key=lambda x: (x[1], -x[0]))",
      "mutated_line": "h = []",
      "code": "from heapq import heappush, heappop\n\ndef maximize_exam_score(n, T, problems):\n    problems.sort(key=lambda x: (x[1], -x[1]))\n    h = []\n    ct = 0\n    for (ai, ti, i) in problems:\n        if ct + ti > T:\n            break\n        elif len(h) > ai:\n            continue\n        ct += ti\n        heappush(h, (ai, -ti, i))\n        while h and h[0][0] < len(h):\n            (ai, ti, i) = heappop(h)\n            ct += ti\n    max_score = len(h)\n    num_problems = len(h)\n    problem_indices = [i + 1 for (_, _, i) in h]\n    return (max_score, num_problems, problem_indices)"
    }
  ]
}