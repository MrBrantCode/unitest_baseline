{
  "task_id": "taco_4925",
  "entry_point": "side",
  "mutant_count": 155,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) + (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) + (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) * ((point2[1] - point1[1]) * (point1[0] - point[0]))",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) * ((point2[1] - point1[1]) * (point1[0] - point[0]))\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "got = 0",
      "mutated_line": "got = 1",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 1\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "got = 0",
      "mutated_line": "got = -1",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = -1\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "got = 0",
      "mutated_line": "got = 1",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 1\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if req != got:",
      "mutated_line": "if req == got:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req == got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return +1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) / (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) / (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return point2[0] - point1[0] + (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return point2[0] - point1[0] + (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) ** (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) ** (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) / (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) / (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1] + (point1[0] - point[0]))",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1] + (point1[0] - point[0]))\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) ** (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) ** (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if P not in ans:",
      "mutated_line": "if P in ans:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return --1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] + point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] + point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return point2[0] * point1[0] * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return point2[0] * point1[0] * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] + point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] + point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] * point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] * point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] + point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] + point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - point2[1] * point1[1] * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - point2[1] * point1[1] * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] + point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] + point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] * point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] * point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n + i - 1) * n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) * n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[n + i - 1 + n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[n + i - 1 + n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[(i + 1) * n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) * n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[i + 1 + n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[i + 1 + n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "P = [point[0] - 1, point[1]]",
      "mutated_line": "P = [point[0] + 1, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] + 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "P = [point[0] - 1, point[1]]",
      "mutated_line": "P = [point[0] * 1, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] * 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 0 or side(point, point_after, P) < 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 or side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "got += 1",
      "mutated_line": "got -= 1",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got -= 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if P not in ans:",
      "mutated_line": "if P in ans:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n + i + 1) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i + 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n + i) * 1 % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i) * 1 % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[(i - 1) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i - 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[i * 1 % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[i * 1 % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "P = [point[0] - 1, point[1]]",
      "mutated_line": "P = [point[0] - 2, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 2, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "P = [point[0] - 1, point[1]]",
      "mutated_line": "P = [point[0] - 0, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 0, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "P = [point[0] - 1, point[1]]",
      "mutated_line": "P = [point[0] - 0, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 0, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "P = [point[0] - 1, point[1]]",
      "mutated_line": "P = [point[0] - -1, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - -1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "P = [point[0] - 1, point[1]]",
      "mutated_line": "P = [point[0] - 1, point[2]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[2]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "P = [point[0] - 1, point[1]]",
      "mutated_line": "P = [point[0] - 1, point[0]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[0]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "P = [point[0] - 1, point[1]]",
      "mutated_line": "P = [point[0] - 1, point[0]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[0]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "P = [point[0] - 1, point[1]]",
      "mutated_line": "P = [point[0] - 1, point[-1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[-1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) <= 0 and side(point, point_after, P) < 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) <= 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) >= 0 and side(point, point_after, P) < 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) >= 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) != 0 and side(point, point_after, P) < 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) != 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) <= 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) <= 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) >= 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) >= 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) != 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) != 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "got += 1",
      "mutated_line": "got += 2",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 2\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "got += 1",
      "mutated_line": "got += 0",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 0\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "got += 1",
      "mutated_line": "got += 0",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 0\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "got += 1",
      "mutated_line": "got += -1",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += -1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if got == req:",
      "mutated_line": "if got != req:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got != req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n + i - 1) * n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) * n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[n + i - 1 + n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[n + i - 1 + n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[(i + 1) * n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) * n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[i + 1 + n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[i + 1 + n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "P = [point[0] + 1, point[1]]",
      "mutated_line": "P = [point[0] - 1, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] - 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "P = [point[0] + 1, point[1]]",
      "mutated_line": "P = [point[0] * 1, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] * 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 0 or side(point, point_after, P) < 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 or side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "got += 1",
      "mutated_line": "got -= 1",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got -= 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[1] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[1] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[-1] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[-1] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[1] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[1] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[1]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[1]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[-1]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[-1]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[1]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[1]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[2] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[2] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[0] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[0] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[0] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[0] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[-1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[-1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[2]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[2]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[0]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[0]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[0]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[0]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[-1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[-1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[2] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[2] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[0] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[0] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[0] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[0] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[-1] - point1[1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[-1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[2]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[2]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[0]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[0]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[0]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[0]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[-1]) * (point1[0] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[-1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[1] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[1] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[-1] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[-1] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[1] - point[0])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[1] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[1])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[1])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[-1])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[-1])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])",
      "mutated_line": "return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[1])",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[1])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n - i - 1) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n - i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n * i - 1) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n * i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n + i - 2) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 2) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n + i - 0) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 0) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n + i - 0) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 0) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n + i - -1) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - -1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[(i + 2) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 2) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[(i + 0) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 0) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[(i + 0) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 0) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[(i + -1) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + -1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "P = [point[0] - 1, point[1]]",
      "mutated_line": "P = [point[1] - 1, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[1] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "P = [point[0] - 1, point[1]]",
      "mutated_line": "P = [point[-1] - 1, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[-1] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "P = [point[0] - 1, point[1]]",
      "mutated_line": "P = [point[1] - 1, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[1] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 1 and side(point, point_after, P) < 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 1 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < -1 and side(point, point_after, P) < 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < -1 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 1 and side(point, point_after, P) < 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 1 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 1:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 1:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < -1:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < -1:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 1:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 1:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n + i + 1) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i + 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n + i) * 1 % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i) * 1 % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[(i - 1) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i - 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[i * 1 % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[i * 1 % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "P = [point[0] + 1, point[1]]",
      "mutated_line": "P = [point[0] + 2, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 2, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "P = [point[0] + 1, point[1]]",
      "mutated_line": "P = [point[0] + 0, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 0, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "P = [point[0] + 1, point[1]]",
      "mutated_line": "P = [point[0] + 0, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 0, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "P = [point[0] + 1, point[1]]",
      "mutated_line": "P = [point[0] + -1, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + -1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "P = [point[0] + 1, point[1]]",
      "mutated_line": "P = [point[0] + 1, point[2]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[2]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "P = [point[0] + 1, point[1]]",
      "mutated_line": "P = [point[0] + 1, point[0]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[0]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "P = [point[0] + 1, point[1]]",
      "mutated_line": "P = [point[0] + 1, point[0]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[0]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "P = [point[0] + 1, point[1]]",
      "mutated_line": "P = [point[0] + 1, point[-1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[-1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) <= 0 and side(point, point_after, P) < 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) <= 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) >= 0 and side(point, point_after, P) < 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) >= 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) != 0 and side(point, point_after, P) < 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) != 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) <= 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) <= 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) >= 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) >= 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) != 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) != 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "got += 1",
      "mutated_line": "got += 2",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 2\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "got += 1",
      "mutated_line": "got += 0",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 0\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "got += 1",
      "mutated_line": "got += 0",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 0\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "got += 1",
      "mutated_line": "got += -1",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += -1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if got == req:",
      "mutated_line": "if got != req:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got != req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n - i - 1) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n - i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n * i - 1) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n * i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n + i - 2) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 2) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n + i - 0) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 0) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n + i - 0) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 0) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "point_before = vertices[(n + i - 1) % n]",
      "mutated_line": "point_before = vertices[(n + i - -1) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - -1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[(i + 2) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 2) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[(i + 0) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 0) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[(i + 0) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 0) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "point_after = vertices[(i + 1) % n]",
      "mutated_line": "point_after = vertices[(i + -1) % n]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + -1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "P = [point[0] + 1, point[1]]",
      "mutated_line": "P = [point[1] + 1, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[1] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "P = [point[0] + 1, point[1]]",
      "mutated_line": "P = [point[-1] + 1, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[-1] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "P = [point[0] + 1, point[1]]",
      "mutated_line": "P = [point[1] + 1, point[1]]",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[1] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 1 and side(point, point_after, P) < 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 1 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < -1 and side(point, point_after, P) < 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < -1 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 1 and side(point, point_after, P) < 0:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 1 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 1:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 1:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < -1:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < -1:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:",
      "mutated_line": "if side(point_before, point, P) < 0 and side(point, point_after, P) < 1:",
      "code": "def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef find_interior_points(vertices, num_points):\n    n = len(vertices)\n    req = num_points\n    got = 0\n    ans = []\n    for i in range(n):\n        point = vertices[i]\n        point_before = vertices[(n + i - 1) % n]\n        point_after = vertices[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    return ans\n    if req != got:\n        for i in range(n):\n            point = vertices[i]\n            point_before = vertices[(n + i - 1) % n]\n            point_after = vertices[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 1:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        return ans\n    return -1"
    }
  ]
}