{
  "task_id": "taco_18310",
  "entry_point": "calculate_endowed_programmer_time",
  "mutant_count": 64,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "index = 0",
      "mutated_line": "index = 1",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 1\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "index = 0",
      "mutated_line": "index = -1",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = -1\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "index = 0",
      "mutated_line": "index = 1",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 1\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while index < len(log_entries):",
      "mutated_line": "while index <= len(log_entries):",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index <= len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while index < len(log_entries):",
      "mutated_line": "while index >= len(log_entries):",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index >= len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while index < len(log_entries):",
      "mutated_line": "while index != len(log_entries):",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index != len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "index += 1",
      "mutated_line": "index -= 1",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index -= 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "index += n",
      "mutated_line": "index -= n",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index -= n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n == 0:",
      "mutated_line": "if n != 0:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n != 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "index += 1",
      "mutated_line": "index += 2",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 2\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "index += 1",
      "mutated_line": "index += 0",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 0\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "index += 1",
      "mutated_line": "index += 0",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 0\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "index += 1",
      "mutated_line": "index += -1",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += -1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if len(e) == 0:",
      "mutated_line": "if len(e) != 0:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) != 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 1:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n == 0:",
      "mutated_line": "if n == -1:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == -1:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 1:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[0]) * 60 - int(ta[1])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 - int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[0]) * 60 * int(ta[1])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 * int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if i == 0:",
      "mutated_line": "if i != 0:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i != 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(e) == 0:",
      "mutated_line": "if len(e) == 1:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 1:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(e) == 0:",
      "mutated_line": "if len(e) == -1:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == -1:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(e) == 0:",
      "mutated_line": "if len(e) == 1:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 1:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "a = log_entries[index:index + n]",
      "mutated_line": "a = log_entries[index:index - n]",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index - n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "a = log_entries[index:index + n]",
      "mutated_line": "a = log_entries[index:index * n]",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index * n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ta = ts.split(':')",
      "mutated_line": "ta = ts.split('')",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split('')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[0]) / 60 + int(ta[1])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) / 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[0]) + 60 + int(ta[1])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) + 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[0]) ** 60 + int(ta[1])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) ** 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 1:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i == 0:",
      "mutated_line": "if i == -1:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == -1:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 1:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if f == 'I':",
      "mutated_line": "if f != 'I':",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f != 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif f == 'I':",
      "mutated_line": "elif f != 'I':",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f != 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(1)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(-1)",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(-1)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(1)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[0]) * 61 + int(ta[1])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 61 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[0]) * 59 + int(ta[1])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 59 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[0]) * 0 + int(ta[1])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 0 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[0]) * 1 + int(ta[1])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 1 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[0]) * -60 + int(ta[1])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * -60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if f == 'I':",
      "mutated_line": "if f == '':",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == '':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "e[k] -= t - d[k]",
      "mutated_line": "e[k] += t - d[k]",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "e[k] += t - d[k]",
      "mutated_line": "e[k] -= t - d[k]",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif f == 'I':",
      "mutated_line": "elif f == '':",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == '':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 in d:",
      "mutated_line": "if 0 not in d:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 not in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "e[i] += t - d[i]",
      "mutated_line": "e[i] -= t - d[i]",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] -= t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[0]) * 60 + int(ta[2])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[2])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[0]) * 60 + int(ta[0])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[0])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[0]) * 60 + int(ta[0])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[0])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[0]) * 60 + int(ta[-1])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[-1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "e[k] -= t - d[k]",
      "mutated_line": "e[k] -= t + d[k]",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t + d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "e[k] -= t - d[k]",
      "mutated_line": "e[k] -= t * d[k]",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t * d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "e[k] += t - d[k]",
      "mutated_line": "e[k] += t + d[k]",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t + d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "e[k] += t - d[k]",
      "mutated_line": "e[k] += t * d[k]",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t * d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 in d:",
      "mutated_line": "if 1 in d:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 1 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 in d:",
      "mutated_line": "if -1 in d:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if -1 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 in d:",
      "mutated_line": "if 1 in d:",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 1 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "e[i] += t - d[i]",
      "mutated_line": "e[i] += t + d[i]",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t + d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "e[i] += t - d[i]",
      "mutated_line": "e[i] += t * d[i]",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[0]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t * d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[1]) * 60 + int(ta[1])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[1]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[-1]) * 60 + int(ta[1])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[-1]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = int(ta[0]) * 60 + int(ta[1])",
      "mutated_line": "t = int(ta[1]) * 60 + int(ta[1])",
      "code": "import collections\n\ndef calculate_endowed_programmer_time(log_entries):\n    results = []\n    index = 0\n    while index < len(log_entries):\n        n = int(log_entries[index])\n        if n == 0:\n            break\n        index += 1\n        a = log_entries[index:index + n]\n        index += n\n        d = {}\n        e = collections.defaultdict(int)\n        for entry in a:\n            (day, ts, f, i) = entry.split()\n            i = int(i)\n            ta = ts.split(':')\n            t = int(ta[1]) * 60 + int(ta[1])\n            if i == 0:\n                if f == 'I':\n                    for k in list(d.keys()):\n                        e[k] -= t - d[k]\n                    d[i] = t\n                else:\n                    del d[i]\n                    for k in list(d.keys()):\n                        e[k] += t - d[k]\n            elif f == 'I':\n                d[i] = t\n            else:\n                if 0 in d:\n                    e[i] += t - d[i]\n                del d[i]\n        if len(e) == 0:\n            results.append(0)\n        else:\n            results.append(max(e.values()))\n    return results"
    }
  ]
}