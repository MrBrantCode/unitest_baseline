{
  "task_id": "cf_51189",
  "entry_point": "findCheapestPrice",
  "mutant_count": 71,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][0] = 1",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 1\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][0] = -1",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = -1\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][0] = 1",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 1\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return +1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] / (T + 1) for _ in range(k + 2)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] / (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] + (T + 1) for _ in range(k + 2)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] + (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] ** (T + 1) for _ in range(k + 2)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] ** (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][1] = 0",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][1] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][-1] = 0",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][-1] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[0][1] = 0",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][1] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if city == dst:",
      "mutated_line": "if city != dst:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city != dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if time > T:",
      "mutated_line": "if time >= T:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time >= T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if time > T:",
      "mutated_line": "if time <= T:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time <= T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if time > T:",
      "mutated_line": "if time != T:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time != T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return --1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] * (T - 1) for _ in range(k + 2)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T - 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] * (T * 1) for _ in range(k + 2)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T * 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[1][0] = 0",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[1][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[-1][0] = 0",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[-1][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[0][0] = 0",
      "mutated_line": "dp[1][0] = 0",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[1][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(0, 0, src)]",
      "mutated_line": "pq = [(1, 0, src)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(1, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(0, 0, src)]",
      "mutated_line": "pq = [(-1, 0, src)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(-1, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(0, 0, src)]",
      "mutated_line": "pq = [(1, 0, src)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(1, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(0, 0, src)]",
      "mutated_line": "pq = [(0, 1, src)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 1, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(0, 0, src)]",
      "mutated_line": "pq = [(0, -1, src)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, -1, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "pq = [(0, 0, src)]",
      "mutated_line": "pq = [(0, 1, src)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 1, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if new_time <= T and new_price < dp[stops + 1][new_time]:",
      "mutated_line": "if new_time <= T or new_price < dp[stops + 1][new_time]:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T or new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] * (T + 2) for _ in range(k + 2)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 2) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] * (T + 0) for _ in range(k + 2)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 0) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] * (T + 0) for _ in range(k + 2)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 0) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] * (T + -1) for _ in range(k + 2)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + -1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] * (T + 1) for _ in range(k - 2)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k - 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] * (T + 1) for _ in range(k * 2)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k * 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "new_price, new_time, stops = price + w, time + t, 1",
      "mutated_line": "(new_price, new_time, stops) = (price - w, time + t, 1)",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price - w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "new_price, new_time, stops = price + w, time + t, 1",
      "mutated_line": "(new_price, new_time, stops) = (price * w, time + t, 1)",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price * w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "new_price, new_time, stops = price + w, time + t, 1",
      "mutated_line": "(new_price, new_time, stops) = (price + w, time - t, 1)",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time - t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "new_price, new_time, stops = price + w, time + t, 1",
      "mutated_line": "(new_price, new_time, stops) = (price + w, time * t, 1)",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time * t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "new_price, new_time, stops = price + w, time + t, 1",
      "mutated_line": "(new_price, new_time, stops) = (price + w, time + t, 2)",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 2)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "new_price, new_time, stops = price + w, time + t, 1",
      "mutated_line": "(new_price, new_time, stops) = (price + w, time + t, 0)",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 0)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "new_price, new_time, stops = price + w, time + t, 1",
      "mutated_line": "(new_price, new_time, stops) = (price + w, time + t, 0)",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 0)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "new_price, new_time, stops = price + w, time + t, 1",
      "mutated_line": "(new_price, new_time, stops) = (price + w, time + t, -1)",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, -1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if new_time <= T and new_price < dp[stops + 1][new_time]:",
      "mutated_line": "if new_time < T and new_price < dp[stops + 1][new_time]:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time < T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if new_time <= T and new_price < dp[stops + 1][new_time]:",
      "mutated_line": "if new_time > T and new_price < dp[stops + 1][new_time]:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time > T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if new_time <= T and new_price < dp[stops + 1][new_time]:",
      "mutated_line": "if new_time == T and new_price < dp[stops + 1][new_time]:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time == T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if new_time <= T and new_price < dp[stops + 1][new_time]:",
      "mutated_line": "if new_time <= T and new_price <= dp[stops + 1][new_time]:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price <= dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if new_time <= T and new_price < dp[stops + 1][new_time]:",
      "mutated_line": "if new_time <= T and new_price >= dp[stops + 1][new_time]:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price >= dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if new_time <= T and new_price < dp[stops + 1][new_time]:",
      "mutated_line": "if new_time <= T and new_price != dp[stops + 1][new_time]:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price != dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if stops < k:",
      "mutated_line": "if stops <= k:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops <= k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if stops < k:",
      "mutated_line": "if stops >= k:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops >= k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if stops < k:",
      "mutated_line": "if stops != k:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops != k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('')] * (T + 1) for _ in range(k + 2)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 3)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 3)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 1)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 1)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 0)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 0)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 1)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 1)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]",
      "mutated_line": "dp = [[float('inf')] * (T + 1) for _ in range(k + -2)]",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + -2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[stops + 1][new_time] = new_price",
      "mutated_line": "dp[stops - 1][new_time] = new_price",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops - 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[stops + 1][new_time] = new_price",
      "mutated_line": "dp[stops * 1][new_time] = new_price",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops * 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if new_time <= T and new_price < dp[stops + 1][new_time]:",
      "mutated_line": "if new_time <= T and new_price < dp[stops - 1][new_time]:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops - 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if new_time <= T and new_price < dp[stops + 1][new_time]:",
      "mutated_line": "if new_time <= T and new_price < dp[stops * 1][new_time]:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops * 1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[stops + 1][new_time] = new_price",
      "mutated_line": "dp[stops + 2][new_time] = new_price",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 2][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[stops + 1][new_time] = new_price",
      "mutated_line": "dp[stops + 0][new_time] = new_price",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 0][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[stops + 1][new_time] = new_price",
      "mutated_line": "dp[stops + 0][new_time] = new_price",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + 0][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[stops + 1][new_time] = new_price",
      "mutated_line": "dp[stops + -1][new_time] = new_price",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 1][new_time]:\n                dp[stops + -1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if new_time <= T and new_price < dp[stops + 1][new_time]:",
      "mutated_line": "if new_time <= T and new_price < dp[stops + 2][new_time]:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 2][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if new_time <= T and new_price < dp[stops + 1][new_time]:",
      "mutated_line": "if new_time <= T and new_price < dp[stops + 0][new_time]:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 0][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if new_time <= T and new_price < dp[stops + 1][new_time]:",
      "mutated_line": "if new_time <= T and new_price < dp[stops + 0][new_time]:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + 0][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if new_time <= T and new_price < dp[stops + 1][new_time]:",
      "mutated_line": "if new_time <= T and new_price < dp[stops + -1][new_time]:",
      "code": "import heapq\n\ndef findCheapestPrice(n, flights, src, dst, k, T):\n    graph = [[] for _ in range(n)]\n    for (u, v, w, t) in flights:\n        graph[u].append((v, w, t))\n    dp = [[float('inf')] * (T + 1) for _ in range(k + 2)]\n    dp[0][0] = 0\n    pq = [(0, 0, src)]\n    while pq:\n        (price, time, city) = heapq.heappop(pq)\n        if city == dst:\n            return price\n        if time > T:\n            continue\n        for (neighbor, w, t) in graph[city]:\n            (new_price, new_time, stops) = (price + w, time + t, 1)\n            if new_time <= T and new_price < dp[stops + -1][new_time]:\n                dp[stops + 1][new_time] = new_price\n                heapq.heappush(pq, (new_price, new_time, neighbor))\n                if stops < k:\n                    heapq.heappush(pq, (new_price, new_time, neighbor))\n    return -1"
    }
  ]
}