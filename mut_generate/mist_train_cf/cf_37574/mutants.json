{
  "task_id": "cf_37574",
  "entry_point": "shortestPath",
  "mutant_count": 94,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return +1"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row == rows - 1 or col == cols - 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 or col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(2, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(2, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(-1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 1), (-1, 0), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 1), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, -1), (-1, 0), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, -1), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 1), (-1, 0), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 1), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (+1, 0), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (+1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 1), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 1), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, -1), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, -1), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 1), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 1), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (1, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (1, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (-1, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (-1, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (1, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (1, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 2), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 2), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 0), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 0), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 0), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 0), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, -1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, -1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (1, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (1, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (-1, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (-1, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (1, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (1, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, +1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, +1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row != rows - 1 and col == cols - 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row != rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row == rows - 1 and col != cols - 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col != cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 <= new_row < rows or 0 <= new_col < cols or grid[new_row][new_col] == 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows or 0 <= new_col < cols or grid[new_row][new_col] == 1:\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[1]))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[1]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[-1]))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[-1]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[1]))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[1]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-2, 0), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-2, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-0, 0), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-0, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-0, 0), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-0, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (--1, 0), (0, 1), (0, -1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (--1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -2)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -2)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -0)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -0)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -0)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, --1)]",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, --1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = deque([(0, 0, 1)])  # (row, col, path_length)",
      "mutated_line": "queue = deque([(1, 0, 1)])",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(1, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = deque([(0, 0, 1)])  # (row, col, path_length)",
      "mutated_line": "queue = deque([(-1, 0, 1)])",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(-1, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = deque([(0, 0, 1)])  # (row, col, path_length)",
      "mutated_line": "queue = deque([(1, 0, 1)])",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(1, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = deque([(0, 0, 1)])  # (row, col, path_length)",
      "mutated_line": "queue = deque([(0, 1, 1)])",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 1, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = deque([(0, 0, 1)])  # (row, col, path_length)",
      "mutated_line": "queue = deque([(0, -1, 1)])",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, -1, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = deque([(0, 0, 1)])  # (row, col, path_length)",
      "mutated_line": "queue = deque([(0, 1, 1)])",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 1, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = deque([(0, 0, 1)])  # (row, col, path_length)",
      "mutated_line": "queue = deque([(0, 0, 2)])",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 2)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = deque([(0, 0, 1)])  # (row, col, path_length)",
      "mutated_line": "queue = deque([(0, 0, 0)])",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 0)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = deque([(0, 0, 1)])  # (row, col, path_length)",
      "mutated_line": "queue = deque([(0, 0, 0)])",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 0)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "queue = deque([(0, 0, 1)])  # (row, col, path_length)",
      "mutated_line": "queue = deque([(0, 0, -1)])",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, -1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row == rows + 1 and col == cols - 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows + 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row == rows * 1 and col == cols - 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows * 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row == rows - 1 and col == cols + 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols + 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row == rows - 1 and col == cols * 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols * 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "new_row, new_col = row + dr, col + dc",
      "mutated_line": "(new_row, new_col) = (row - dr, col + dc)",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row - dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "new_row, new_col = row + dr, col + dc",
      "mutated_line": "(new_row, new_col) = (row * dr, col + dc)",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row * dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "new_row, new_col = row + dr, col + dc",
      "mutated_line": "(new_row, new_col) = (row + dr, col - dc)",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col - dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "new_row, new_col = row + dr, col + dc",
      "mutated_line": "(new_row, new_col) = (row + dr, col * dc)",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col * dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 < new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 < new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 > new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 > new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 == new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 == new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 <= new_row < rows and 0 < new_col < cols and (grid[new_row][new_col] == 1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 < new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 <= new_row < rows and 0 > new_col < cols and (grid[new_row][new_col] == 1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 > new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 <= new_row < rows and 0 == new_col < cols and (grid[new_row][new_col] == 1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 == new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] != 1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] != 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "grid[new_row][new_col] = 0  # Mark as visited to avoid revisiting",
      "mutated_line": "grid[new_row][new_col] = 1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "grid[new_row][new_col] = 0  # Mark as visited to avoid revisiting",
      "mutated_line": "grid[new_row][new_col] = -1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = -1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "grid[new_row][new_col] = 0  # Mark as visited to avoid revisiting",
      "mutated_line": "grid[new_row][new_col] = 1",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row == rows - 2 and col == cols - 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 2 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row == rows - 0 and col == cols - 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 0 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row == rows - 0 and col == cols - 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 0 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row == rows - -1 and col == cols - 1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - -1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row == rows - 1 and col == cols - 2:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 2:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row == rows - 1 and col == cols - 0:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 0:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row == rows - 1 and col == cols - 0:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 0:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if row == rows - 1 and col == cols - 1:",
      "mutated_line": "if row == rows - 1 and col == cols - -1:",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - -1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 1 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 1 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if -1 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if -1 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 1 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 1 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 <= new_row < rows and 1 <= new_col < cols and (grid[new_row][new_col] == 1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 1 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 <= new_row < rows and -1 <= new_col < cols and (grid[new_row][new_col] == 1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and -1 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 <= new_row < rows and 1 <= new_col < cols and (grid[new_row][new_col] == 1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 1 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 2):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 2):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 0):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 0):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 0):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 0):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:",
      "mutated_line": "if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == -1):",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == -1):\n                queue.append((new_row, new_col, path_length + 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "queue.append((new_row, new_col, path_length + 1))",
      "mutated_line": "queue.append((new_row, new_col, path_length - 1))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length - 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "queue.append((new_row, new_col, path_length + 1))",
      "mutated_line": "queue.append((new_row, new_col, path_length * 1))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length * 1))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((new_row, new_col, path_length + 1))",
      "mutated_line": "queue.append((new_row, new_col, path_length + 2))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 2))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((new_row, new_col, path_length + 1))",
      "mutated_line": "queue.append((new_row, new_col, path_length + 0))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 0))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((new_row, new_col, path_length + 1))",
      "mutated_line": "queue.append((new_row, new_col, path_length + 0))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + 0))\n                grid[new_row][new_col] = 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((new_row, new_col, path_length + 1))",
      "mutated_line": "queue.append((new_row, new_col, path_length + -1))",
      "code": "from typing import List\nfrom collections import deque\n\ndef shortestPath(grid: List[List[int]]) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = deque([(0, 0, 1)])\n    while queue:\n        (row, col, path_length) = queue.popleft()\n        if row == rows - 1 and col == cols - 1:\n            return path_length\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and (grid[new_row][new_col] == 1):\n                queue.append((new_row, new_col, path_length + -1))\n                grid[new_row][new_col] = 0\n    return -1"
    }
  ]
}