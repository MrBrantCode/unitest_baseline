{
  "task_id": "cf_884",
  "entry_point": "find_shortest_path",
  "mutant_count": 125,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 1\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = -1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = -1\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 1\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return +1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if current_point == end:",
      "mutated_line": "if current_point != end:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point != end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if current_distance > distances[current_point]:",
      "mutated_line": "if current_distance >= distances[current_point]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance >= distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if current_distance > distances[current_point]:",
      "mutated_line": "if current_distance <= distances[current_point]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance <= distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if current_distance > distances[current_point]:",
      "mutated_line": "if current_distance != distances[current_point]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance != distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(-1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(-1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 2), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 2), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, -1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, -1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (-1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (-1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, +1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, +1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (2, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (2, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (-1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (-1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (+1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (+1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (2, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (2, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 2), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 2), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, -1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, -1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (+1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (+1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, +1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, +1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (2, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (2, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (-1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (-1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, +1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, +1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (+1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (+1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 2)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 2)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, -1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, -1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "mutated_line": "distances = {(i, j): float('') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "priority_queue = [(0, start)]",
      "mutated_line": "priority_queue = [(1, start)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(1, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "priority_queue = [(0, start)]",
      "mutated_line": "priority_queue = [(-1, start)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(-1, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "priority_queue = [(0, start)]",
      "mutated_line": "priority_queue = [(1, start)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(1, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) or 0 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) or 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -2), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -2), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, --1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, --1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-2, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-2, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (--1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (--1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-2, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-2, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (--1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (--1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -2), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -2), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, --1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, --1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -2), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -2), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, --1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, --1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-2, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-2, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (--1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (--1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] - movement[0], current_point[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] - movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] * movement[0], current_point[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] * movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] + movement[0], current_point[1] - movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] - movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] + movement[0], current_point[1] * movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] * movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 < new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 < new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 > new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 > new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 == new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 == new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 0 < new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 < new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 0 > new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 > new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 0 == new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 == new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "new_distance = current_distance + matrix[new_i][new_j]",
      "mutated_line": "if new_distance < distances[new_i, new_j]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance - matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "new_distance = current_distance + matrix[new_i][new_j]",
      "mutated_line": "if new_distance < distances[new_i, new_j]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance * matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if new_distance < distances[(new_i, new_j)]:",
      "mutated_line": "distances[new_i, new_j] = new_distance",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance <= distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if new_distance < distances[(new_i, new_j)]:",
      "mutated_line": "distances[new_i, new_j] = new_distance",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance >= distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if new_distance < distances[(new_i, new_j)]:",
      "mutated_line": "distances[new_i, new_j] = new_distance",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance != distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 1 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 1 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if -1 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if -1 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 1 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 1 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 1 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 1 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and -1 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and -1 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 1 <= new_j < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 1 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "mutated_line": "distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[1]))}",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[1]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "mutated_line": "distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[-1]))}",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[-1]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "mutated_line": "distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[1]))}",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[1]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[1] + movement[0], current_point[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[1] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[-1] + movement[0], current_point[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[-1] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[1] + movement[0], current_point[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[1] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] + movement[1], current_point[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[1], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] + movement[-1], current_point[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[-1], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] + movement[1], current_point[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[1], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] + movement[0], current_point[2] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[2] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] + movement[0], current_point[0] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[0] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] + movement[0], current_point[0] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[0] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] + movement[0], current_point[-1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[-1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[2])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[2])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[0])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[0])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[0])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[0])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_i, new_j = current_point[0] + movement[0], current_point[1] + movement[1]",
      "mutated_line": "(new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[-1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[-1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[1]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[1]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[-1]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[-1]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]):",
      "mutated_line": "if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[1]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path between two points in a two-dimensional array using Dijkstra's algorithm.\n    \n    Args:\n        matrix (list): A 2D matrix of non-negative integers.\n        start (tuple): The start point.\n        end (tuple): The end point.\n    \n    Returns:\n        int: The shortest distance from the start point to the end point. Returns -1 if there are no valid paths.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    distances = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_point) = heapq.heappop(priority_queue)\n        if current_point == end:\n            return current_distance\n        if current_distance > distances[current_point]:\n            continue\n        for movement in movements:\n            (new_i, new_j) = (current_point[0] + movement[0], current_point[1] + movement[1])\n            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[1]):\n                new_distance = current_distance + matrix[new_i][new_j]\n                if new_distance < distances[new_i, new_j]:\n                    distances[new_i, new_j] = new_distance\n                    heapq.heappush(priority_queue, (new_distance, (new_i, new_j)))\n    return -1"
    }
  ]
}