{
  "task_id": "cf_52406",
  "entry_point": "optimize_travel_cost",
  "mutant_count": 24,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_cost = float('inf')",
      "mutated_line": "min_cost = float('')",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "return min_cost if min_cost != float('inf') else -1",
      "mutated_line": "return min_cost if min_cost == float('inf') else -1",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost == float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "return min_cost if min_cost != float('inf') else -1",
      "mutated_line": "return min_cost if min_cost != float('inf') else +1",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else +1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_cost = float('inf')",
      "mutated_line": "min_cost = float('')",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if cost > min_cost:",
      "mutated_line": "if cost >= min_cost:",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost >= min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if cost > min_cost:",
      "mutated_line": "if cost <= min_cost:",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost <= min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if cost > min_cost:",
      "mutated_line": "if cost != min_cost:",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost != min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return min_cost if min_cost != float('inf') else -1",
      "mutated_line": "return min_cost if min_cost != float('inf') else -2",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -2"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return min_cost if min_cost != float('inf') else -1",
      "mutated_line": "return min_cost if min_cost != float('inf') else -0",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return min_cost if min_cost != float('inf') else -1",
      "mutated_line": "return min_cost if min_cost != float('inf') else -0",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return min_cost if min_cost != float('inf') else -1",
      "mutated_line": "return min_cost if min_cost != float('inf') else --1",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else --1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if next_city not in visited_cities:",
      "mutated_line": "if next_city in visited_cities:",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))",
      "mutated_line": "min_cost = min(min_cost, dijkstra(start_city, 1, {start_city}))",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 1, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))",
      "mutated_line": "min_cost = min(min_cost, dijkstra(start_city, -1, {start_city}))",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, -1, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))",
      "mutated_line": "min_cost = min(min_cost, dijkstra(start_city, 1, {start_city}))",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 1, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return min_cost if min_cost != float('inf') else -1",
      "mutated_line": "return min_cost if min_cost != float('') else -1",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if all(city in visited_cities for city in mandatory_cities):",
      "mutated_line": "if all((city not in visited_cities for city in mandatory_cities)):",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city not in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "new_cost = cost + costs[city][next_city][time_slot]",
      "mutated_line": "new_cost = cost - costs[city][next_city][time_slot]",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost - costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "new_cost = cost + costs[city][next_city][time_slot]",
      "mutated_line": "new_cost = cost * costs[city][next_city][time_slot]",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost * costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if new_cost <= max_budget:",
      "mutated_line": "if new_cost < max_budget:",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost < max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if new_cost <= max_budget:",
      "mutated_line": "if new_cost > max_budget:",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost > max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if new_cost <= max_budget:",
      "mutated_line": "if new_cost == max_budget:",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost == max_budget:\n                            new_visited = visited_cities | {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new_visited = visited_cities | {next_city}",
      "mutated_line": "new_visited = visited_cities & {next_city}",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities & {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new_visited = visited_cities | {next_city}",
      "mutated_line": "new_visited = visited_cities ^ {next_city}",
      "code": "import heapq\n\ndef optimize_travel_cost(costs, mandatory_cities, max_budget, n):\n\n    def dijkstra(current_city, current_cost, visited):\n        queue = [(current_cost, current_city, visited)]\n        min_cost = float('inf')\n        while queue:\n            (cost, city, visited_cities) = heapq.heappop(queue)\n            if cost > min_cost:\n                break\n            if all((city in visited_cities for city in mandatory_cities)):\n                min_cost = min(min_cost, cost)\n            for next_city in range(n):\n                if next_city not in visited_cities:\n                    for time_slot in range(len(costs[city][next_city])):\n                        new_cost = cost + costs[city][next_city][time_slot]\n                        if new_cost <= max_budget:\n                            new_visited = visited_cities ^ {next_city}\n                            heapq.heappush(queue, (new_cost, next_city, new_visited))\n        return min_cost\n    min_cost = float('inf')\n    for start_city in range(n):\n        min_cost = min(min_cost, dijkstra(start_city, 0, {start_city}))\n    return min_cost if min_cost != float('inf') else -1"
    }
  ]
}