{
  "task_id": "cf_83607",
  "entry_point": "quickselect_median",
  "mutant_count": 99,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if len(nums) % 2 == 1:",
      "mutated_line": "if len(nums) % 2 != 1:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 != 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"Selects a pivot element from the list.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "\"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(l) == 1:",
      "mutated_line": "if len(l) != 1:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) != 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if k < len(lows):",
      "mutated_line": "if k <= len(lows):",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k <= len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if k < len(lows):",
      "mutated_line": "if k >= len(lows):",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k >= len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if k < len(lows):",
      "mutated_line": "if k != len(lows):",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k != len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if len(nums) % 2 == 1:",
      "mutated_line": "if len(nums) * 2 == 1:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) * 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if len(nums) % 2 == 1:",
      "mutated_line": "if len(nums) + 2 == 1:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) + 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(nums) % 2 == 1:",
      "mutated_line": "if len(nums) % 2 == 2:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 2:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(nums) % 2 == 1:",
      "mutated_line": "if len(nums) % 2 == 0:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 0:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(nums) % 2 == 1:",
      "mutated_line": "if len(nums) % 2 == 0:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 0:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(nums) % 2 == 1:",
      "mutated_line": "if len(nums) % 2 == -1:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == -1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 / (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 / (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 + (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 + (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 ** (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 ** (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "assert len(l) != 0",
      "mutated_line": "assert len(l) == 0",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) == 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(l) == 1:",
      "mutated_line": "if len(l) == 2:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 2:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(l) == 1:",
      "mutated_line": "if len(l) == 0:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 0:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(l) == 1:",
      "mutated_line": "if len(l) == 0:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 0:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(l) == 1:",
      "mutated_line": "if len(l) == -1:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == -1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "assert k == 0",
      "mutated_line": "assert k != 0",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k != 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif k < len(lows) + len(pivots):",
      "mutated_line": "elif k <= len(lows) + len(pivots):",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k <= len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif k < len(lows) + len(pivots):",
      "mutated_line": "elif k >= len(lows) + len(pivots):",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k >= len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif k < len(lows) + len(pivots):",
      "mutated_line": "elif k != len(lows) + len(pivots):",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k != len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(nums) % 2 == 1:",
      "mutated_line": "if len(nums) % 3 == 1:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 3 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(nums) % 2 == 1:",
      "mutated_line": "if len(nums) % 1 == 1:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 1 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(nums) % 2 == 1:",
      "mutated_line": "if len(nums) % 0 == 1:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 0 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(nums) % 2 == 1:",
      "mutated_line": "if len(nums) % 1 == 1:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 1 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(nums) % 2 == 1:",
      "mutated_line": "if len(nums) % -2 == 1:",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % -2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return quickselect(nums, len(nums) // 2)",
      "mutated_line": "return quickselect(nums, len(nums) / 2)",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) / 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return quickselect(nums, len(nums) // 2)",
      "mutated_line": "return quickselect(nums, len(nums) * 2)",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) * 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 1.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 1.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return -0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return -0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 1 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 1 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return -0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return -0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) - quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) - quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) * quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) * quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "assert len(l) != 0",
      "mutated_line": "assert len(l) != 1",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 1\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "assert len(l) != 0",
      "mutated_line": "assert len(l) != -1",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != -1\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "assert len(l) != 0",
      "mutated_line": "assert len(l) != 1",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 1\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return l[len(l) // 2]",
      "mutated_line": "return l[len(l) / 2]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) / 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return l[len(l) // 2]",
      "mutated_line": "return l[len(l) * 2]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) * 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "assert k == 0",
      "mutated_line": "assert k == 1",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 1\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "assert k == 0",
      "mutated_line": "assert k == -1",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == -1\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "assert k == 0",
      "mutated_line": "assert k == 1",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 1\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return l[0]",
      "mutated_line": "return l[1]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[1]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return l[0]",
      "mutated_line": "return l[-1]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[-1]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return l[0]",
      "mutated_line": "return l[1]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[1]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "lows = [el for el in l if el < pivot]",
      "mutated_line": "lows = [el for el in l if el <= pivot]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el <= pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "lows = [el for el in l if el < pivot]",
      "mutated_line": "lows = [el for el in l if el >= pivot]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el >= pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "lows = [el for el in l if el < pivot]",
      "mutated_line": "lows = [el for el in l if el != pivot]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el != pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "highs = [el for el in l if el > pivot]",
      "mutated_line": "highs = [el for el in l if el >= pivot]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el >= pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "highs = [el for el in l if el > pivot]",
      "mutated_line": "highs = [el for el in l if el <= pivot]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el <= pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "highs = [el for el in l if el > pivot]",
      "mutated_line": "highs = [el for el in l if el != pivot]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el != pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "pivots = [el for el in l if el == pivot]",
      "mutated_line": "pivots = [el for el in l if el != pivot]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el != pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "elif k < len(lows) + len(pivots):",
      "mutated_line": "elif k < len(lows) - len(pivots):",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) - len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "elif k < len(lows) + len(pivots):",
      "mutated_line": "elif k < len(lows) * len(pivots):",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) * len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return quickselect(nums, len(nums) // 2)",
      "mutated_line": "return quickselect(nums, len(nums) // 3)",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 3)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return quickselect(nums, len(nums) // 2)",
      "mutated_line": "return quickselect(nums, len(nums) // 1)",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 1)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return quickselect(nums, len(nums) // 2)",
      "mutated_line": "return quickselect(nums, len(nums) // 0)",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 0)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return quickselect(nums, len(nums) // 2)",
      "mutated_line": "return quickselect(nums, len(nums) // 1)",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 1)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return quickselect(nums, len(nums) // 2)",
      "mutated_line": "return quickselect(nums, len(nums) // -2)",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // -2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return l[len(l) // 2]",
      "mutated_line": "return l[len(l) // 3]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 3]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return l[len(l) // 2]",
      "mutated_line": "return l[len(l) // 1]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 1]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return l[len(l) // 2]",
      "mutated_line": "return l[len(l) // 0]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 0]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return l[len(l) // 2]",
      "mutated_line": "return l[len(l) // 1]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 1]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return l[len(l) // 2]",
      "mutated_line": "return l[len(l) // -2]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // -2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "print(\"The provided list contains fewer than two elements!\")",
      "mutated_line": "print('')",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "print(\"The provided list contains one or more non-numeric items!\")",
      "mutated_line": "print('')",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return pivots[0]",
      "mutated_line": "return pivots[1]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[1]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return pivots[0]",
      "mutated_line": "return pivots[-1]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[-1]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return pivots[0]",
      "mutated_line": "return pivots[1]",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[1]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return quickselect(highs, k - len(lows) - len(pivots))",
      "mutated_line": "return quickselect(highs, k - len(lows) + len(pivots))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) + len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return quickselect(highs, k - len(lows) - len(pivots))",
      "mutated_line": "return quickselect(highs, (k - len(lows)) * len(pivots))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, (k - len(lows)) * len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 + 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 + 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 * 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 * 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "quickselect(nums, len(nums) // 2))",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) / 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) / 2))"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "quickselect(nums, len(nums) // 2))",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) * 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) * 2))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return quickselect(highs, k - len(lows) - len(pivots))",
      "mutated_line": "return quickselect(highs, k + len(lows) - len(pivots))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k + len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return quickselect(highs, k - len(lows) - len(pivots))",
      "mutated_line": "return quickselect(highs, k * len(lows) - len(pivots))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k * len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) / 2 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) / 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) * 2 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) * 2 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 2) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 2) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 0) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 0) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 0) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 0) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - -1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - -1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "quickselect(nums, len(nums) // 2))",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 3))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 3))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "quickselect(nums, len(nums) // 2))",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 1))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 1))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "quickselect(nums, len(nums) // 2))",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 0))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 0))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "quickselect(nums, len(nums) // 2))",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 1))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // 1))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "quickselect(nums, len(nums) // 2))",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // -2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 2 - 1) + quickselect(nums, len(nums) // -2))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 3 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 3 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 1 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 1 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 0 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 0 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // 1 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // 1 - 1) + quickselect(nums, len(nums) // 2))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 0.5 * (quickselect(nums, len(nums) // 2 - 1) +",
      "mutated_line": "return 0.5 * (quickselect(nums, len(nums) // -2 - 1) + quickselect(nums, len(nums) // 2))",
      "code": "def quickselect_median(nums: list) -> float:\n    \"\"\"Calculates the median of a list without using built-in sorting functions or sorting the data.\"\"\"\n\n    def pivot_fn(l):\n        \"\"\"Selects a pivot element from the list.\"\"\"\n        try:\n            assert len(l) != 0\n            return l[len(l) // 2]\n        except AssertionError:\n            print('The provided list contains fewer than two elements!')\n            return None\n        except TypeError:\n            print('The provided list contains one or more non-numeric items!')\n            return None\n\n    def quickselect(l: list, k: int) -> float:\n        \"\"\"Finds the k-th smallest element in the list using the QuickSelect algorithm.\"\"\"\n        if len(l) == 1:\n            assert k == 0\n            return l[0]\n        pivot = pivot_fn(l)\n        lows = [el for el in l if el < pivot]\n        highs = [el for el in l if el > pivot]\n        pivots = [el for el in l if el == pivot]\n        if k < len(lows):\n            return quickselect(lows, k)\n        elif k < len(lows) + len(pivots):\n            return pivots[0]\n        else:\n            return quickselect(highs, k - len(lows) - len(pivots))\n    if len(nums) % 2 == 1:\n        return quickselect(nums, len(nums) // 2)\n    else:\n        return 0.5 * (quickselect(nums, len(nums) // -2 - 1) + quickselect(nums, len(nums) // 2))"
    }
  ]
}