{
  "task_id": "cf_58577",
  "entry_point": "entrance",
  "mutant_count": 160,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [0] / ((m << 1) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] / ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [0] + ((m << 1) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] + ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [0] ** ((m << 1) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] ** ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [0] / ((m << 1) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] / ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [0] + ((m << 1) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] + ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [0] ** ((m << 1) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] ** ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 2",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 2\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 0",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 0\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 0",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 0\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = -1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = -1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) * mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) * mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return comb(m << 1, m) - comb(m << 1, m - n - 1) + mod + mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return comb(m << 1, m) - comb(m << 1, m - n - 1) + mod + mod"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [0] * ((m << 1) - 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) - 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [0] * ((m << 1) * 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) * 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [0] * ((m << 1) - 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) - 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [0] * ((m << 1) * 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) * 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[1] = factorial[1] = inverse[0] = inverse[1] = 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[1] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[-1] = factorial[1] = inverse[0] = inverse[1] = 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[-1] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[1] = factorial[1] = inverse[0] = inverse[1] = 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[1] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[2] = inverse[0] = inverse[1] = 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[2] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[0] = inverse[0] = inverse[1] = 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[0] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[0] = inverse[0] = inverse[1] = 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[0] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[-1] = inverse[0] = inverse[1] = 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[-1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[1] = inverse[1] = inverse[1] = 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[1] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[1] = inverse[-1] = inverse[1] = 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[-1] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[1] = inverse[1] = inverse[1] = 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[1] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[1] = inverse[0] = inverse[2] = 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[2] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[1] = inverse[0] = inverse[0] = 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[0] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[1] = inverse[0] = inverse[0] = 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[0] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1",
      "mutated_line": "factorial[0] = factorial[1] = inverse[0] = inverse[-1] = 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[-1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(3, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(1, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(0, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(1, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(-2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) - 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) * 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "factorial[i] = (factorial[i - 1] * i) % mod",
      "mutated_line": "factorial[i] = factorial[i - 1] * i * mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i * mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "factorial[i] = (factorial[i - 1] * i) % mod",
      "mutated_line": "factorial[i] = factorial[i - 1] * i + mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i + mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inverse[i] = (inverse[mod % i] * (mod - mod // i)) % mod",
      "mutated_line": "inverse[i] = inverse[mod % i] * (mod - mod // i) * mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) * mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inverse[i] = (inverse[mod % i] * (mod - mod // i)) % mod",
      "mutated_line": "inverse[i] = inverse[mod % i] * (mod - mod // i) + mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) + mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(3, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(1, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(0, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(1, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(-2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) - 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) * 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inverse[i] = (inverse[i - 1] * inverse[i]) % mod",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] * mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inverse[i] = (inverse[i - 1] * inverse[i]) % mod",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] + mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n < k and k < 0:",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k and k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return (factorial[n] * inverse[k] % mod) * inverse[n - k] % mod",
      "mutated_line": "return factorial[n] * inverse[k] % mod * inverse[n - k] * mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] * mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return (factorial[n] * inverse[k] % mod) * inverse[n - k] % mod",
      "mutated_line": "return factorial[n] * inverse[k] % mod * inverse[n - k] + mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] + mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) - mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) - mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1)) * mod % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1)) * mod % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [1] * ((m << 1) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [1] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [-1] * ((m << 1) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [-1] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [1] * ((m << 1) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [1] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [0] * ((m << 1) + 2)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 2)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [0] * ((m << 1) + 0)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 0)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [0] * ((m << 1) + 0)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 0)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [0] * ((m << 1) + -1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + -1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [1] * ((m << 1) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [1] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [-1] * ((m << 1) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [-1] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [1] * ((m << 1) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [1] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [0] * ((m << 1) + 2)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 2)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [0] * ((m << 1) + 0)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 0)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [0] * ((m << 1) + 0)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 0)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [0] * ((m << 1) + -1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + -1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 2):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 0):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 0):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + -1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "factorial[i] = (factorial[i - 1] * i) % mod",
      "mutated_line": "factorial[i] = factorial[i - 1] / i % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] / i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "factorial[i] = (factorial[i - 1] * i) % mod",
      "mutated_line": "factorial[i] = (factorial[i - 1] + i) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = (factorial[i - 1] + i) % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "factorial[i] = (factorial[i - 1] * i) % mod",
      "mutated_line": "factorial[i] = factorial[i - 1] ** i % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] ** i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inverse[i] = (inverse[mod % i] * (mod - mod // i)) % mod",
      "mutated_line": "inverse[i] = inverse[mod % i] / (mod - mod // i) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] / (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inverse[i] = (inverse[mod % i] * (mod - mod // i)) % mod",
      "mutated_line": "inverse[i] = (inverse[mod % i] + (mod - mod // i)) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = (inverse[mod % i] + (mod - mod // i)) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inverse[i] = (inverse[mod % i] * (mod - mod // i)) % mod",
      "mutated_line": "inverse[i] = inverse[mod % i] ** (mod - mod // i) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] ** (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 2):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 0):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 0):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + -1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inverse[i] = (inverse[i - 1] * inverse[i]) % mod",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] / inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inverse[i] = (inverse[i - 1] * inverse[i]) % mod",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = (inverse[i - 1] + inverse[i]) % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inverse[i] = (inverse[i - 1] * inverse[i]) % mod",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] ** inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n <= k or k < 0:",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n <= k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n >= k or k < 0:",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n >= k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n != k or k < 0:",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n != k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n < k or k <= 0:",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k <= 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n < k or k >= 0:",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k >= 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n < k or k != 0:",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k != 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 1\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return -1\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 1\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return (factorial[n] * inverse[k] % mod) * inverse[n - k] % mod",
      "mutated_line": "return factorial[n] * inverse[k] % mod / inverse[n - k] % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod / inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return (factorial[n] * inverse[k] % mod) * inverse[n - k] % mod",
      "mutated_line": "return (factorial[n] * inverse[k] % mod + inverse[n - k]) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return (factorial[n] * inverse[k] % mod + inverse[n - k]) % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return (factorial[n] * inverse[k] % mod) * inverse[n - k] % mod",
      "mutated_line": "return (factorial[n] * inverse[k] % mod) ** inverse[n - k] % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return (factorial[n] * inverse[k] % mod) ** inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) + comb(m << 1, m - n - 1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) + comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) * comb(m << 1, m - n - 1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) * comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [0] * ((m << 2) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 2) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [0] * ((m << 0) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 0) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [0] * ((m << 0) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 0) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "factorial = [0] * ((m << 1) + 1)",
      "mutated_line": "factorial = [0] * ((m << -1) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << -1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [0] * ((m << 2) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 2) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [0] * ((m << 0) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 0) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [0] * ((m << 0) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 0) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "inverse = [0] * ((m << 1) + 1)",
      "mutated_line": "inverse = [0] * ((m << -1) + 1)",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << -1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 2) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 0) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 0) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "for i in range(2, (m << 1) + 1):",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << -1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inverse[i] = (inverse[mod % i] * (mod - mod // i)) % mod",
      "mutated_line": "inverse[i] = inverse[mod % i] * (mod + mod // i) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod + mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inverse[i] = (inverse[mod % i] * (mod - mod // i)) % mod",
      "mutated_line": "inverse[i] = inverse[mod % i] * (mod * (mod // i)) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod * (mod // i)) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 2) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 0) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 0) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(2, (m << 1) + 1):",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << -1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n < k or k < 1:",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 1:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n < k or k < -1:",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < -1:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n < k or k < 1:",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 1:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return (factorial[n] * inverse[k] % mod) * inverse[n - k] % mod",
      "mutated_line": "return factorial[n] * inverse[k] * mod * inverse[n - k] % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] * mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return (factorial[n] * inverse[k] % mod) * inverse[n - k] % mod",
      "mutated_line": "return (factorial[n] * inverse[k] + mod) * inverse[n - k] % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return (factorial[n] * inverse[k] + mod) * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "factorial[i] = (factorial[i - 1] * i) % mod",
      "mutated_line": "factorial[i] = factorial[i + 1] * i % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i + 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "factorial[i] = (factorial[i - 1] * i) % mod",
      "mutated_line": "factorial[i] = factorial[i * 1] * i % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i * 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inverse[i] = (inverse[mod % i] * (mod - mod // i)) % mod",
      "mutated_line": "inverse[i] = inverse[mod * i] * (mod - mod // i) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod * i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inverse[i] = (inverse[mod % i] * (mod - mod // i)) % mod",
      "mutated_line": "inverse[i] = inverse[mod + i] * (mod - mod // i) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod + i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inverse[i] = (inverse[mod % i] * (mod - mod // i)) % mod",
      "mutated_line": "inverse[i] = inverse[mod % i] * (mod - mod / i) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod / i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "inverse[i] = (inverse[mod % i] * (mod - mod // i)) % mod",
      "mutated_line": "inverse[i] = inverse[mod % i] * (mod - mod * i) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod * i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inverse[i] = (inverse[i - 1] * inverse[i]) % mod",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i + 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "inverse[i] = (inverse[i - 1] * inverse[i]) % mod",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i * 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return (factorial[n] * inverse[k] % mod) * inverse[n - k] % mod",
      "mutated_line": "return factorial[n] / inverse[k] % mod * inverse[n - k] % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] / inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return (factorial[n] * inverse[k] % mod) * inverse[n - k] % mod",
      "mutated_line": "return (factorial[n] + inverse[k]) % mod * inverse[n - k] % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return (factorial[n] + inverse[k]) % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return (factorial[n] * inverse[k] % mod) * inverse[n - k] % mod",
      "mutated_line": "return factorial[n] ** inverse[k] % mod * inverse[n - k] % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] ** inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return (factorial[n] * inverse[k] % mod) * inverse[n - k] % mod",
      "mutated_line": "return factorial[n] * inverse[k] % mod * inverse[n + k] % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n + k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return (factorial[n] * inverse[k] % mod) * inverse[n - k] % mod",
      "mutated_line": "return factorial[n] * inverse[k] % mod * inverse[n * k] % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n * k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << 1, m - n + 1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n + 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << 1, (m - n) * 1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, (m - n) * 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "factorial[i] = (factorial[i - 1] * i) % mod",
      "mutated_line": "factorial[i] = factorial[i - 2] * i % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 2] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "factorial[i] = (factorial[i - 1] * i) % mod",
      "mutated_line": "factorial[i] = factorial[i - 0] * i % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 0] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "factorial[i] = (factorial[i - 1] * i) % mod",
      "mutated_line": "factorial[i] = factorial[i - 0] * i % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 0] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "factorial[i] = (factorial[i - 1] * i) % mod",
      "mutated_line": "factorial[i] = factorial[i - -1] * i % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - -1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inverse[i] = (inverse[i - 1] * inverse[i]) % mod",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 2] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inverse[i] = (inverse[i - 1] * inverse[i]) % mod",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 0] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inverse[i] = (inverse[i - 1] * inverse[i]) % mod",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 0] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inverse[i] = (inverse[i - 1] * inverse[i]) % mod",
      "mutated_line": "",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - -1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 2, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 2, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 0, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 0, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 0, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 0, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << -1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << -1, m) - comb(m << 1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << 2, m - n - 1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 2, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << 0, m - n - 1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 0, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << 0, m - n - 1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 0, m - n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << -1, m - n - 1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << -1, m - n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << 1, m + n - 1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m + n - 1) + mod) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << 1, m * n - 1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m * n - 1) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 2) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 2) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 0) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 0) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 0) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - 0) + mod) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (comb(m << 1, m) - comb(m << 1, m - n - 1) + mod) % mod",
      "mutated_line": "return (comb(m << 1, m) - comb(m << 1, m - n - -1) + mod) % mod",
      "code": "def entrance(m, n, mod):\n    factorial = [0] * ((m << 1) + 1)\n    inverse = [0] * ((m << 1) + 1)\n    factorial[0] = factorial[1] = inverse[0] = inverse[1] = 1\n    for i in range(2, (m << 1) + 1):\n        factorial[i] = factorial[i - 1] * i % mod\n        inverse[i] = inverse[mod % i] * (mod - mod // i) % mod\n    for i in range(2, (m << 1) + 1):\n        inverse[i] = inverse[i - 1] * inverse[i] % mod\n\n    def comb(n, k):\n        if n < k or k < 0:\n            return 0\n        return factorial[n] * inverse[k] % mod * inverse[n - k] % mod\n    return (comb(m << 1, m) - comb(m << 1, m - n - -1) + mod) % mod"
    }
  ]
}