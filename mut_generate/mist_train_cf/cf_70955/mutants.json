{
  "task_id": "cf_70955",
  "entry_point": "multi_category_logloss",
  "mutant_count": 20,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\"\"\"\n    actual_classes = np.array(actual_classes) - 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "actual_classes = np.array(actual_classes) - 1  # subtract 1 because Python uses 0-based indexing",
      "mutated_line": "actual_classes = np.array(actual_classes) + 1",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) + 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "actual_classes = np.array(actual_classes) - 1  # subtract 1 because Python uses 0-based indexing",
      "mutated_line": "actual_classes = np.array(actual_classes) * 1",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) * 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1",
      "mutated_line": "actual_classes_one_hot[np.arange(n_samples), actual_classes] = 2",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 2\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1",
      "mutated_line": "actual_classes_one_hot[np.arange(n_samples), actual_classes] = 0",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 0\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1",
      "mutated_line": "actual_classes_one_hot[np.arange(n_samples), actual_classes] = 0",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 0\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1",
      "mutated_line": "actual_classes_one_hot[np.arange(n_samples), actual_classes] = -1",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = -1\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples",
      "mutated_line": "logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) * n_samples",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) * n_samples\n    return logloss"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples",
      "mutated_line": "logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) // n_samples",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) // n_samples\n    return logloss"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "actual_classes = np.array(actual_classes) - 1  # subtract 1 because Python uses 0-based indexing",
      "mutated_line": "actual_classes = np.array(actual_classes) - 2",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 2\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "actual_classes = np.array(actual_classes) - 1  # subtract 1 because Python uses 0-based indexing",
      "mutated_line": "actual_classes = np.array(actual_classes) - 0",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 0\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "actual_classes = np.array(actual_classes) - 1  # subtract 1 because Python uses 0-based indexing",
      "mutated_line": "actual_classes = np.array(actual_classes) - 0",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 0\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "actual_classes = np.array(actual_classes) - 1  # subtract 1 because Python uses 0-based indexing",
      "mutated_line": "actual_classes = np.array(actual_classes) - -1",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - -1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples",
      "mutated_line": "logloss = +np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = +np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n_categories = len(forecasted_probabilities[0])",
      "mutated_line": "n_categories = len(forecasted_probabilities[1])",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[1])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n_categories = len(forecasted_probabilities[0])",
      "mutated_line": "n_categories = len(forecasted_probabilities[-1])",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[-1])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n_categories = len(forecasted_probabilities[0])",
      "mutated_line": "n_categories = len(forecasted_probabilities[1])",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[1])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples",
      "mutated_line": "logloss = -np.sum(np.log(forecasted_probabilities) / actual_classes_one_hot) / n_samples",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) / actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples",
      "mutated_line": "logloss = -np.sum(np.log(forecasted_probabilities) + actual_classes_one_hot) / n_samples",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) + actual_classes_one_hot) / n_samples\n    return logloss"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "logloss = -np.sum(np.log(forecasted_probabilities) * actual_classes_one_hot) / n_samples",
      "mutated_line": "logloss = -np.sum(np.log(forecasted_probabilities) ** actual_classes_one_hot) / n_samples",
      "code": "import numpy as np\n\ndef multi_category_logloss(actual_classes, forecasted_probabilities):\n    \"\"\"\n    Compute the multi-category logarithmic loss (or cross-entropy loss).\n\n    Parameters:\n    actual_classes (list): A list of true class labels (1-indexed).\n    forecasted_probabilities (2D list): A 2D list of predicted probabilities for each class.\n\n    Returns:\n    float: The average logarithmic loss.\n    \"\"\"\n    actual_classes = np.array(actual_classes) - 1\n    forecasted_probabilities = np.array(forecasted_probabilities)\n    n_samples = len(actual_classes)\n    n_categories = len(forecasted_probabilities[0])\n    actual_classes_one_hot = np.zeros((n_samples, n_categories))\n    actual_classes_one_hot[np.arange(n_samples), actual_classes] = 1\n    logloss = -np.sum(np.log(forecasted_probabilities) ** actual_classes_one_hot) / n_samples\n    return logloss"
    }
  ]
}