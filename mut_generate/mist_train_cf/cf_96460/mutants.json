{
  "task_id": "cf_96460",
  "entry_point": "generate_permutations",
  "mutant_count": 28,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "used = [False] * len(nums)",
      "mutated_line": "used = [False] / len(nums)",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] / len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "used = [False] * len(nums)",
      "mutated_line": "used = [False] + len(nums)",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] + len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "used = [False] * len(nums)",
      "mutated_line": "used = [False] ** len(nums)",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] ** len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if len(current_permutation) == len(nums):",
      "mutated_line": "if len(current_permutation) != len(nums):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) != len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "used = [False] * len(nums)",
      "mutated_line": "used = [True] * len(nums)",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [True] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] and (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] and (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "used[i] = True",
      "mutated_line": "used[i] = False",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = False\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "used[i] = False",
      "mutated_line": "used[i] = True",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = True\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 or nums[i] == nums[i - 1] or (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 or nums[i] == nums[i - 1] or (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i >= 0 and nums[i] == nums[i - 1] and (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i >= 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i <= 0 and nums[i] == nums[i - 1] and (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i <= 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i != 0 and nums[i] == nums[i - 1] and (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i != 0 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] != nums[i - 1] and (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] != nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 1 and nums[i] == nums[i - 1] and (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 1 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > -1 and nums[i] == nums[i - 1] and (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > -1 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 1 and nums[i] == nums[i - 1] and (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 1 and nums[i] == nums[i - 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i + 1] and (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i + 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i * 1] and (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i * 1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i + 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i + 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i * 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i * 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 2] and (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 2] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 0] and (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 0] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 0] and (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 0] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - -1] and (not used[i - 1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - -1] and (not used[i - 1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 2])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 2])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 0])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 0])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 0])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - 0])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):",
      "mutated_line": "if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - -1])):",
      "code": "def generate_permutations(nums):\n    nums.sort()\n    permutations = []\n    current_permutation = []\n    used = [False] * len(nums)\n\n    def backtrack():\n        if len(current_permutation) == len(nums):\n            permutations.append(current_permutation.copy())\n        else:\n            for i in range(len(nums)):\n                if used[i] or (i > 0 and nums[i] == nums[i - 1] and (not used[i - -1])):\n                    continue\n                used[i] = True\n                current_permutation.append(nums[i])\n                backtrack()\n                used[i] = False\n                current_permutation.pop()\n    backtrack()\n    return permutations"
    }
  ]
}