{
  "task_id": "cf_45291",
  "entry_point": "arrange_matrix",
  "mutant_count": 41,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def arrange_matrix(mat):\n    \"\"\"\"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rearrangements = 0",
      "mutated_line": "rearrangements = 1",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 1\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rearrangements = 0",
      "mutated_line": "rearrangements = -1",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = -1\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rearrangements = 0",
      "mutated_line": "rearrangements = 1",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 1\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "\"\"\"Check if the matrix is sorted column-wise.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return False\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': -1, '': -1, 'total_rearrangements': 0}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, '': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': -1, 'rearrange_with': -1, '': 0}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, '': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': +1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': +1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': -1, 'rearrange_with': +1, 'total_rearrangements': 0}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': +1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 1}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 1}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': -1}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': -1}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 1}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 1}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "result['total_rearrangements'] = rearrangements",
      "mutated_line": "result[''] = rearrangements",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result[''] = rearrangements\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if column != sorted(column):",
      "mutated_line": "if column == sorted(column):",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column == sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': -2, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -2, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': -0, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -0, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': -0, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -0, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': --1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': --1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': -1, 'rearrange_with': -2, 'total_rearrangements': 0}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -2, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': -1, 'rearrange_with': -0, 'total_rearrangements': 0}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -0, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': -1, 'rearrange_with': -0, 'total_rearrangements': 0}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -0, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}",
      "mutated_line": "result = {'row_index': -1, 'rearrange_with': --1, 'total_rearrangements': 0}",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': --1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for j in range(i + 1, len(mat)):",
      "mutated_line": "for j in range(i - 1, len(mat)):",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i - 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for j in range(i + 1, len(mat)):",
      "mutated_line": "for j in range(i * 1, len(mat)):",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i * 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "rearrangements += 1",
      "mutated_line": "rearrangements -= 1",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements -= 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return True\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(i + 1, len(mat)):",
      "mutated_line": "for j in range(i + 2, len(mat)):",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 2, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(i + 1, len(mat)):",
      "mutated_line": "for j in range(i + 0, len(mat)):",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 0, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(i + 1, len(mat)):",
      "mutated_line": "for j in range(i + 0, len(mat)):",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 0, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(i + 1, len(mat)):",
      "mutated_line": "for j in range(i + -1, len(mat)):",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + -1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "rearrangements += 1",
      "mutated_line": "rearrangements += 2",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 2\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "rearrangements += 1",
      "mutated_line": "rearrangements += 0",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 0\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "rearrangements += 1",
      "mutated_line": "rearrangements += 0",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 0\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "rearrangements += 1",
      "mutated_line": "rearrangements += -1",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += -1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for col_idx in range(len(matrix[0])):",
      "mutated_line": "for col_idx in range(len(matrix[1])):",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[1])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for col_idx in range(len(matrix[0])):",
      "mutated_line": "for col_idx in range(len(matrix[-1])):",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[-1])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for col_idx in range(len(matrix[0])):",
      "mutated_line": "for col_idx in range(len(matrix[1])):",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[1])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result['row_index'] = i",
      "mutated_line": "result[''] = i",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result[''] = i\n                result['rearrange_with'] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "result['rearrange_with'] = j",
      "mutated_line": "result[''] = j",
      "code": "def arrange_matrix(mat):\n    \"\"\"\n    This function analyzes a given matrix to identify unsorted rows and \n    find potential rearrangement possibilities to sort the matrix column-wise.\n    \n    Args:\n    mat (list): A 2D list representing the input matrix.\n\n    Returns:\n    dict: A dictionary containing the index of the row that needs rearranging, \n    the index of the row with which it should be swapped, and the total number of rearrangements needed.\n    If the matrix is already sorted or no such row exists, return {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}.\n    \"\"\"\n\n    def is_sorted(matrix):\n        \"\"\"Check if the matrix is sorted column-wise.\"\"\"\n        for col_idx in range(len(matrix[0])):\n            column = [row[col_idx] for row in matrix]\n            if column != sorted(column):\n                return False\n        return True\n    result = {'row_index': -1, 'rearrange_with': -1, 'total_rearrangements': 0}\n    rearrangements = 0\n    for i in range(len(mat)):\n        if is_sorted(mat):\n            break\n        for j in range(i + 1, len(mat)):\n            swapped_mat = [row[:] for row in mat]\n            (swapped_mat[i], swapped_mat[j]) = (swapped_mat[j], swapped_mat[i])\n            if is_sorted(swapped_mat):\n                result['row_index'] = i\n                result[''] = j\n                rearrangements += 1\n                (mat[i], mat[j]) = (mat[j], mat[i])\n                break\n    result['total_rearrangements'] = rearrangements\n    return result"
    }
  ]
}