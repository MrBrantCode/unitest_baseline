{
  "task_id": "cf_44089",
  "entry_point": "min_non_overlapping_periods",
  "mutant_count": 27,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[0] > chosen_periods[-1][1]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] > chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[0] < chosen_periods[-1][1]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] < chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[0] == chosen_periods[-1][1]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] == chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "chosen_periods = [periods[0]]",
      "mutated_line": "chosen_periods = [periods[1]]",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[1]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "chosen_periods = [periods[0]]",
      "mutated_line": "chosen_periods = [periods[-1]]",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[-1]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "chosen_periods = [periods[0]]",
      "mutated_line": "chosen_periods = [periods[1]]",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[1]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for period in periods[1:]:",
      "mutated_line": "for period in periods[2:]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[2:]:\n        if period[0] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for period in periods[1:]:",
      "mutated_line": "for period in periods[0:]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[0:]:\n        if period[0] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for period in periods[1:]:",
      "mutated_line": "for period in periods[0:]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[0:]:\n        if period[0] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for period in periods[1:]:",
      "mutated_line": "for period in periods[-1:]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[-1:]:\n        if period[0] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[1] >= chosen_periods[-1][1]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[1] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[-1] >= chosen_periods[-1][1]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[-1] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[1] >= chosen_periods[-1][1]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[1] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[0] >= chosen_periods[-1][2]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-1][2]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[0] >= chosen_periods[-1][0]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-1][0]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[0] >= chosen_periods[-1][0]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-1][0]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[0] >= chosen_periods[-1][-1]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-1][-1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "periods.sort(key=lambda x: x[1])",
      "mutated_line": "periods.sort(key=lambda x: x[2])",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[2])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "periods.sort(key=lambda x: x[1])",
      "mutated_line": "periods.sort(key=lambda x: x[0])",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[0])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "periods.sort(key=lambda x: x[1])",
      "mutated_line": "periods.sort(key=lambda x: x[0])",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[0])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "periods.sort(key=lambda x: x[1])",
      "mutated_line": "periods.sort(key=lambda x: x[-1])",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[-1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[0] >= chosen_periods[+1][1]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[+1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[0] >= chosen_periods[-2][1]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-2][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[0] >= chosen_periods[-0][1]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-0][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[0] >= chosen_periods[-0][1]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[-0][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if period[0] >= chosen_periods[-1][1]:",
      "mutated_line": "if period[0] >= chosen_periods[--1][1]:",
      "code": "def min_non_overlapping_periods(periods):\n    \"\"\"\n    This function takes a list of periods as input and returns the smallest number of non-overlapping periods \n    that cover the full range of the given periods. The function also returns the actual non-overlapping periods.\n\n    Args:\n        periods (list): A list of periods where each period is a list of two integers representing the start and end of the period.\n\n    Returns:\n        tuple: A tuple containing the smallest number of non-overlapping periods and the actual non-overlapping periods.\n    \"\"\"\n    periods.sort(key=lambda x: x[1])\n    chosen_periods = [periods[0]]\n    for period in periods[1:]:\n        if period[0] >= chosen_periods[--1][1]:\n            chosen_periods.append(period)\n    return (len(chosen_periods), chosen_periods)"
    }
  ]
}