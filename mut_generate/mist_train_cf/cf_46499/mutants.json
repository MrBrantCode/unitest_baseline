{
  "task_id": "cf_46499",
  "entry_point": "sphere_volume",
  "mutant_count": 109,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / 3 * math.pi / radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi / radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / 3 * math.pi + radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi + radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return (4 / 3 * math.pi) ** radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return (4 / 3 * math.pi) ** radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return total_volume - intersections",
      "mutated_line": "return total_volume + intersections",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume + intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return total_volume - intersections",
      "mutated_line": "return total_volume * intersections",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume * intersections"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / 3 / math.pi * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 / math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return (4 / 3 + math.pi) * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return (4 / 3 + math.pi) * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return (4 / 3) ** math.pi * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return (4 / 3) ** math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / 3 * math.pi * (radius * 3)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * (radius * 3)\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / 3 * math.pi * (radius + 3)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * (radius + 3)\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return distance_centers < (self.radius + other.radius)",
      "mutated_line": "return distance_centers <= self.radius + other.radius",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers <= self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return distance_centers < (self.radius + other.radius)",
      "mutated_line": "return distance_centers >= self.radius + other.radius",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers >= self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "return distance_centers < (self.radius + other.radius)",
      "mutated_line": "return distance_centers != self.radius + other.radius",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers != self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 * 3 * math.pi * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 * 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 // 3 * math.pi * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 // 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / 3 * math.pi * radius ** 4",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 4\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / 3 * math.pi * radius ** 2",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 2\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / 3 * math.pi * radius ** 0",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 0\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / 3 * math.pi * radius ** 1",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 1\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / 3 * math.pi * radius ** -3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** -3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 - (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 - (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt(((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2) * (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt(((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2) * (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return distance_centers < (self.radius + other.radius)",
      "mutated_line": "return distance_centers < self.radius - other.radius",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius - other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return distance_centers < (self.radius + other.radius)",
      "mutated_line": "return distance_centers < self.radius * other.radius",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius * other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 5 / 3 * math.pi * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 5 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 3 / 3 * math.pi * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 3 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 0 / 3 * math.pi * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 0 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 1 / 3 * math.pi * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 1 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return -4 / 3 * math.pi * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return -4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / 4 * math.pi * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 4 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / 2 * math.pi * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 2 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / 0 * math.pi * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 0 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / 1 * math.pi * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 1 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return (4/3) * math.pi * (radius ** 3)",
      "mutated_line": "return 4 / -3 * math.pi * radius ** 3",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / -3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 - (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 - (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 * (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 * (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) * 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) * 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2] + 2))",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2] + 2))\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[4]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[4]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[2]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[2]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[0]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[0]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[1]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[1]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[-3]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[-3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) * 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) * 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt(self.center[0] - other.center[0] + 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt(self.center[0] - other.center[0] + 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) * 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) * 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1] + 2) + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1] + 2) + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] + other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] + other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] * other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] * other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 3)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 3)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 1)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 1)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 0)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 0)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 1)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 1)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** -2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** -2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[1], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[1], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[-1], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[-1], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[1], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[1], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[0], sphere[2], sphere[2]), sphere[3]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[2], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[0], sphere[0], sphere[2]), sphere[3]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[0], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[0], sphere[0], sphere[2]), sphere[3]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[0], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[0], sphere[-1], sphere[2]), sphere[3]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[-1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[3]), sphere[3]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[3]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[1]), sphere[3]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[1]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[0]), sphere[3]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[0]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[1]), sphere[3]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[1]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]",
      "mutated_line": "spheres_obj = [Sphere((sphere[0], sphere[1], sphere[-2]), sphere[3]) for sphere in spheres]",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[-2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "intersections = sum([s1.intersects(s2) for s1, s2 in combinations(spheres_obj, 2)])",
      "mutated_line": "intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 3)])",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 3)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "intersections = sum([s1.intersects(s2) for s1, s2 in combinations(spheres_obj, 2)])",
      "mutated_line": "intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 1)])",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 1)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "intersections = sum([s1.intersects(s2) for s1, s2 in combinations(spheres_obj, 2)])",
      "mutated_line": "intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 0)])",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 0)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "intersections = sum([s1.intersects(s2) for s1, s2 in combinations(spheres_obj, 2)])",
      "mutated_line": "intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 1)])",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 1)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "intersections = sum([s1.intersects(s2) for s1, s2 in combinations(spheres_obj, 2)])",
      "mutated_line": "intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, -2)])",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, -2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] + other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] + other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] * other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] * other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 3 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 3 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 1 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 1 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 0 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 0 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 1 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 1 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** -2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** -2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] + other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] + other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] * other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] * other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 3 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 3 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 1 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 1 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 0 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 0 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 1 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 1 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** -2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** -2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[3] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[3] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[1] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[1] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[0] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[0] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[1] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[1] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[-2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[-2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[3]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[3]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[1]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[1]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[0]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[0]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[1]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[1]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[-2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[-2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[1] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[1] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[-1] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[-1] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[1] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[1] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[1]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[1]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[-1]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[-1]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[1]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[1]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[2] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[2] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[0] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[0] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[0] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[0] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[-1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[-1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[2]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[2]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[0]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[0]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[0]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[0]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "mutated_line": "distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[-1]) ** 2 + (self.center[2] - other.center[2]) ** 2)",
      "code": "import math\nfrom itertools import combinations\n\ndef sphere_volume(radius):\n    return 4 / 3 * math.pi * radius ** 3\n\nclass Sphere:\n\n    def __init__(self, center, radius):\n        self.center = center\n        self.radius = radius\n\n    def intersects(self, other):\n        distance_centers = math.sqrt((self.center[0] - other.center[0]) ** 2 + (self.center[1] - other.center[-1]) ** 2 + (self.center[2] - other.center[2]) ** 2)\n        return distance_centers < self.radius + other.radius\n\ndef calculate_total_exterior_space(spheres):\n    spheres_obj = [Sphere((sphere[0], sphere[1], sphere[2]), sphere[3]) for sphere in spheres]\n    total_volume = sum([sphere_volume(sphere.radius) for sphere in spheres_obj])\n    intersections = sum([s1.intersects(s2) for (s1, s2) in combinations(spheres_obj, 2)])\n    return total_volume - intersections"
    }
  ]
}