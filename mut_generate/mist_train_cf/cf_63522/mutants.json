{
  "task_id": "cf_63522",
  "entry_point": "longest_path",
  "mutant_count": 120,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if length == layer and product == target:",
      "mutated_line": "if length == layer or product == target:",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer or product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(1, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(-1, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(-1, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(1, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, +1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, +1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 1), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 1), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, -1), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, -1), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 1), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 1), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (1, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (1, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (-1, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (-1, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (1, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (1, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 2, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 2, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 0, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 0, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 0, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 0, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, -1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, -1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 1), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 1), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, -1), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, -1), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 1), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 1), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (1, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (1, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (-1, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (-1, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (1, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (1, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 1, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 1, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, -1, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, -1, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 1, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 1, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, +1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, +1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (1, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (1, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (-1, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (-1, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (1, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (1, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 1, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 1, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, -1, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, -1, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 1, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 1, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 2), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 2), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 0), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 0), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 0), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 0), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, -1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, -1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (+1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (+1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 1, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 1, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, -1, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, -1, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 1, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 1, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 1), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 1), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, -1), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, -1), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 1), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 1), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (2, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (2, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (0, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (0, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (0, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (0, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (-1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (-1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 1, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 1, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, -1, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, -1, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 1, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 1, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 1)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 1)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, -1)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, -1)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 1)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 1)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if length == layer and product == target:",
      "mutated_line": "if length != layer and product == target:",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length != layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if length == layer and product == target:",
      "mutated_line": "if length == layer and product != target:",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product != target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 <= new_x < layer or 0 <= new_y < x or 0 <= new_z < y or ((new_x, new_y, new_z) not in visited) or (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer or 0 <= new_y < x or 0 <= new_z < y or ((new_x, new_y, new_z) not in visited) or (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "layer, x, y = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(layer, x, y) = (len(cube), len(cube[1]), len(cube[0][0]))",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[1]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "layer, x, y = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(layer, x, y) = (len(cube), len(cube[-1]), len(cube[0][0]))",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[-1]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "layer, x, y = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(layer, x, y) = (len(cube), len(cube[1]), len(cube[0][0]))",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[1]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "layer, x, y = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(layer, x, y) = (len(cube), len(cube[0]), len(cube[0][1]))",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][1]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "layer, x, y = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(layer, x, y) = (len(cube), len(cube[0]), len(cube[0][-1]))",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][-1]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "layer, x, y = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(layer, x, y) = (len(cube), len(cube[0]), len(cube[0][1]))",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][1]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -2, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -2, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -0, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -0, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -0, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -0, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, --1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, --1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -2), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -2), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -0), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -0), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -0), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -0), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, --1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, --1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-2, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-2, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-0, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-0, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-0, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-0, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]",
      "mutated_line": "directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (--1, 0, 0), (1, 0, 0)]",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (--1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "new_x, new_y, new_z = x + dir_x, y + dir_y, z + dir_z",
      "mutated_line": "(new_x, new_y, new_z) = (x - dir_x, y + dir_y, z + dir_z)",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x - dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "new_x, new_y, new_z = x + dir_x, y + dir_y, z + dir_z",
      "mutated_line": "(new_x, new_y, new_z) = (x * dir_x, y + dir_y, z + dir_z)",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x * dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "new_x, new_y, new_z = x + dir_x, y + dir_y, z + dir_z",
      "mutated_line": "(new_x, new_y, new_z) = (x + dir_x, y - dir_y, z + dir_z)",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y - dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "new_x, new_y, new_z = x + dir_x, y + dir_y, z + dir_z",
      "mutated_line": "(new_x, new_y, new_z) = (x + dir_x, y * dir_y, z + dir_z)",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y * dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "new_x, new_y, new_z = x + dir_x, y + dir_y, z + dir_z",
      "mutated_line": "(new_x, new_y, new_z) = (x + dir_x, y + dir_y, z - dir_z)",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z - dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "new_x, new_y, new_z = x + dir_x, y + dir_y, z + dir_z",
      "mutated_line": "(new_x, new_y, new_z) = (x + dir_x, y + dir_y, z * dir_z)",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z * dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 < new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 < new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 > new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 > new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 == new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 == new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 <= new_x < layer and 0 < new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 < new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 <= new_x < layer and 0 > new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 > new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 <= new_x < layer and 0 == new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 == new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 <= new_x < layer and 0 <= new_y < x and (0 < new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 < new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 <= new_x < layer and 0 <= new_y < x and (0 > new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 > new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 <= new_x < layer and 0 <= new_y < x and (0 == new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 == new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "(new_x, new_y, new_z) not in visited and product * cube[new_x][new_y][new_z] <= target):",
      "mutated_line": "if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "(new_x, new_y, new_z) not in visited and product * cube[new_x][new_y][new_z] <= target):",
      "mutated_line": "if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] < target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] < target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "(new_x, new_y, new_z) not in visited and product * cube[new_x][new_y][new_z] <= target):",
      "mutated_line": "if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] > target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] > target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "(new_x, new_y, new_z) not in visited and product * cube[new_x][new_y][new_z] <= target):",
      "mutated_line": "if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] == target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] == target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "layer, x, y = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(layer, x, y) = (len(cube), len(cube[0]), len(cube[1][0]))",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[1][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "layer, x, y = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(layer, x, y) = (len(cube), len(cube[0]), len(cube[-1][0]))",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[-1][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "layer, x, y = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(layer, x, y) = (len(cube), len(cube[0]), len(cube[1][0]))",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[1][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 1 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 1 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if -1 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if -1 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 1 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 1 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 <= new_x < layer and 1 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 1 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 <= new_x < layer and -1 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and -1 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 <= new_x < layer and 1 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 1 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 <= new_x < layer and 0 <= new_y < x and (1 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (1 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 <= new_x < layer and 0 <= new_y < x and (-1 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (-1 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (0 <= new_x < layer and 0 <= new_y < x and 0 <= new_z < y and",
      "mutated_line": "if 0 <= new_x < layer and 0 <= new_y < x and (1 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (1 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(new_x, new_y, new_z) not in visited and product * cube[new_x][new_y][new_z] <= target):",
      "mutated_line": "if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product / cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product / cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(new_x, new_y, new_z) not in visited and product * cube[new_x][new_y][new_z] <= target):",
      "mutated_line": "if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product + cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product + cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(new_x, new_y, new_z) not in visited and product * cube[new_x][new_y][new_z] <= target):",
      "mutated_line": "if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product ** cube[new_x][new_y][new_z] <= target):",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product ** cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dfs(new_x, new_y, new_z, length+1, product * cube[new_x][new_y][new_z])",
      "mutated_line": "dfs(new_x, new_y, new_z, length - 1, product * cube[new_x][new_y][new_z])",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length - 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dfs(new_x, new_y, new_z, length+1, product * cube[new_x][new_y][new_z])",
      "mutated_line": "dfs(new_x, new_y, new_z, length * 1, product * cube[new_x][new_y][new_z])",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length * 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dfs(new_x, new_y, new_z, length+1, product * cube[new_x][new_y][new_z])",
      "mutated_line": "dfs(new_x, new_y, new_z, length + 1, product / cube[new_x][new_y][new_z])",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product / cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dfs(new_x, new_y, new_z, length+1, product * cube[new_x][new_y][new_z])",
      "mutated_line": "dfs(new_x, new_y, new_z, length + 1, product + cube[new_x][new_y][new_z])",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product + cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dfs(new_x, new_y, new_z, length+1, product * cube[new_x][new_y][new_z])",
      "mutated_line": "dfs(new_x, new_y, new_z, length + 1, product ** cube[new_x][new_y][new_z])",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product ** cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dfs(i, j, k, 1, cube[i][j][k])",
      "mutated_line": "dfs(i, j, k, 2, cube[i][j][k])",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 2, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dfs(i, j, k, 1, cube[i][j][k])",
      "mutated_line": "dfs(i, j, k, 0, cube[i][j][k])",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 0, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dfs(i, j, k, 1, cube[i][j][k])",
      "mutated_line": "dfs(i, j, k, 0, cube[i][j][k])",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 0, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dfs(i, j, k, 1, cube[i][j][k])",
      "mutated_line": "dfs(i, j, k, -1, cube[i][j][k])",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, -1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dfs(new_x, new_y, new_z, length+1, product * cube[new_x][new_y][new_z])",
      "mutated_line": "dfs(new_x, new_y, new_z, length + 2, product * cube[new_x][new_y][new_z])",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 2, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dfs(new_x, new_y, new_z, length+1, product * cube[new_x][new_y][new_z])",
      "mutated_line": "dfs(new_x, new_y, new_z, length + 0, product * cube[new_x][new_y][new_z])",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 0, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dfs(new_x, new_y, new_z, length+1, product * cube[new_x][new_y][new_z])",
      "mutated_line": "dfs(new_x, new_y, new_z, length + 0, product * cube[new_x][new_y][new_z])",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + 0, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dfs(new_x, new_y, new_z, length+1, product * cube[new_x][new_y][new_z])",
      "mutated_line": "dfs(new_x, new_y, new_z, length + -1, product * cube[new_x][new_y][new_z])",
      "code": "def longest_path(cube, target):\n    (layer, x, y) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1), (-1, 0, 0), (1, 0, 0)]\n    (visited, path, results) = (set(), [], [])\n\n    def dfs(x, y, z, length, product):\n        if length == layer and product == target:\n            results.append(path[:])\n            return\n        for (dir_x, dir_y, dir_z) in directions:\n            (new_x, new_y, new_z) = (x + dir_x, y + dir_y, z + dir_z)\n            if 0 <= new_x < layer and 0 <= new_y < x and (0 <= new_z < y) and ((new_x, new_y, new_z) not in visited) and (product * cube[new_x][new_y][new_z] <= target):\n                visited.add((new_x, new_y, new_z))\n                path.append(cube[new_x][new_y][new_z])\n                dfs(new_x, new_y, new_z, length + -1, product * cube[new_x][new_y][new_z])\n                path.pop()\n                visited.remove((new_x, new_y, new_z))\n    for i in range(layer):\n        for j in range(x):\n            for k in range(y):\n                visited.add((i, j, k))\n                path.append(cube[i][j][k])\n                dfs(i, j, k, 1, cube[i][j][k])\n                path.pop()\n                visited.remove((i, j, k))\n    return max(results, key=len) if results else []"
    }
  ]
}