{
  "task_id": "cf_46956",
  "entry_point": "DynamicMinFinder",
  "mutant_count": 11,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if len(min_heap) == 0:",
      "mutated_line": "if len(min_heap) != 0:",
      "code": "import heapq\n\ndef DynamicMinFinder(data):\n    min_heap = []\n    heapq.heapify(min_heap)\n\n    def add_element(element):\n        heapq.heappush(min_heap, element)\n\n    def find_min():\n        if len(min_heap) != 0:\n            return None\n        return min_heap[0]\n\n    def delete_min():\n        if len(min_heap) == 0:\n            return None\n        return heapq.heappop(min_heap)\n    for num in data:\n        add_element(num)\n    return (find_min, delete_min)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(min_heap) == 0:",
      "mutated_line": "if len(min_heap) != 0:",
      "code": "import heapq\n\ndef DynamicMinFinder(data):\n    min_heap = []\n    heapq.heapify(min_heap)\n\n    def add_element(element):\n        heapq.heappush(min_heap, element)\n\n    def find_min():\n        if len(min_heap) == 0:\n            return None\n        return min_heap[0]\n\n    def delete_min():\n        if len(min_heap) != 0:\n            return None\n        return heapq.heappop(min_heap)\n    for num in data:\n        add_element(num)\n    return (find_min, delete_min)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if len(min_heap) == 0:",
      "mutated_line": "if len(min_heap) == 1:",
      "code": "import heapq\n\ndef DynamicMinFinder(data):\n    min_heap = []\n    heapq.heapify(min_heap)\n\n    def add_element(element):\n        heapq.heappush(min_heap, element)\n\n    def find_min():\n        if len(min_heap) == 1:\n            return None\n        return min_heap[0]\n\n    def delete_min():\n        if len(min_heap) == 0:\n            return None\n        return heapq.heappop(min_heap)\n    for num in data:\n        add_element(num)\n    return (find_min, delete_min)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if len(min_heap) == 0:",
      "mutated_line": "if len(min_heap) == -1:",
      "code": "import heapq\n\ndef DynamicMinFinder(data):\n    min_heap = []\n    heapq.heapify(min_heap)\n\n    def add_element(element):\n        heapq.heappush(min_heap, element)\n\n    def find_min():\n        if len(min_heap) == -1:\n            return None\n        return min_heap[0]\n\n    def delete_min():\n        if len(min_heap) == 0:\n            return None\n        return heapq.heappop(min_heap)\n    for num in data:\n        add_element(num)\n    return (find_min, delete_min)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if len(min_heap) == 0:",
      "mutated_line": "if len(min_heap) == 1:",
      "code": "import heapq\n\ndef DynamicMinFinder(data):\n    min_heap = []\n    heapq.heapify(min_heap)\n\n    def add_element(element):\n        heapq.heappush(min_heap, element)\n\n    def find_min():\n        if len(min_heap) == 1:\n            return None\n        return min_heap[0]\n\n    def delete_min():\n        if len(min_heap) == 0:\n            return None\n        return heapq.heappop(min_heap)\n    for num in data:\n        add_element(num)\n    return (find_min, delete_min)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min_heap[0]",
      "mutated_line": "return min_heap[1]",
      "code": "import heapq\n\ndef DynamicMinFinder(data):\n    min_heap = []\n    heapq.heapify(min_heap)\n\n    def add_element(element):\n        heapq.heappush(min_heap, element)\n\n    def find_min():\n        if len(min_heap) == 0:\n            return None\n        return min_heap[1]\n\n    def delete_min():\n        if len(min_heap) == 0:\n            return None\n        return heapq.heappop(min_heap)\n    for num in data:\n        add_element(num)\n    return (find_min, delete_min)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min_heap[0]",
      "mutated_line": "return min_heap[-1]",
      "code": "import heapq\n\ndef DynamicMinFinder(data):\n    min_heap = []\n    heapq.heapify(min_heap)\n\n    def add_element(element):\n        heapq.heappush(min_heap, element)\n\n    def find_min():\n        if len(min_heap) == 0:\n            return None\n        return min_heap[-1]\n\n    def delete_min():\n        if len(min_heap) == 0:\n            return None\n        return heapq.heappop(min_heap)\n    for num in data:\n        add_element(num)\n    return (find_min, delete_min)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min_heap[0]",
      "mutated_line": "return min_heap[1]",
      "code": "import heapq\n\ndef DynamicMinFinder(data):\n    min_heap = []\n    heapq.heapify(min_heap)\n\n    def add_element(element):\n        heapq.heappush(min_heap, element)\n\n    def find_min():\n        if len(min_heap) == 0:\n            return None\n        return min_heap[1]\n\n    def delete_min():\n        if len(min_heap) == 0:\n            return None\n        return heapq.heappop(min_heap)\n    for num in data:\n        add_element(num)\n    return (find_min, delete_min)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(min_heap) == 0:",
      "mutated_line": "if len(min_heap) == 1:",
      "code": "import heapq\n\ndef DynamicMinFinder(data):\n    min_heap = []\n    heapq.heapify(min_heap)\n\n    def add_element(element):\n        heapq.heappush(min_heap, element)\n\n    def find_min():\n        if len(min_heap) == 0:\n            return None\n        return min_heap[0]\n\n    def delete_min():\n        if len(min_heap) == 1:\n            return None\n        return heapq.heappop(min_heap)\n    for num in data:\n        add_element(num)\n    return (find_min, delete_min)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(min_heap) == 0:",
      "mutated_line": "if len(min_heap) == -1:",
      "code": "import heapq\n\ndef DynamicMinFinder(data):\n    min_heap = []\n    heapq.heapify(min_heap)\n\n    def add_element(element):\n        heapq.heappush(min_heap, element)\n\n    def find_min():\n        if len(min_heap) == 0:\n            return None\n        return min_heap[0]\n\n    def delete_min():\n        if len(min_heap) == -1:\n            return None\n        return heapq.heappop(min_heap)\n    for num in data:\n        add_element(num)\n    return (find_min, delete_min)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(min_heap) == 0:",
      "mutated_line": "if len(min_heap) == 1:",
      "code": "import heapq\n\ndef DynamicMinFinder(data):\n    min_heap = []\n    heapq.heapify(min_heap)\n\n    def add_element(element):\n        heapq.heappush(min_heap, element)\n\n    def find_min():\n        if len(min_heap) == 0:\n            return None\n        return min_heap[0]\n\n    def delete_min():\n        if len(min_heap) == 1:\n            return None\n        return heapq.heappop(min_heap)\n    for num in data:\n        add_element(num)\n    return (find_min, delete_min)"
    }
  ]
}