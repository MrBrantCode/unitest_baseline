{
  "task_id": "cf_42389",
  "entry_point": "findMaximizedCapital",
  "mutant_count": 20,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "while projects and projects[0][1] <= W:",
      "mutated_line": "while projects or projects[0][1] <= W:",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects or projects[0][1] <= W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "W -= heapq.heappop(available_projects)",
      "mutated_line": "W += heapq.heappop(available_projects)",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][1] <= W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W += heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while projects and projects[0][1] <= W:",
      "mutated_line": "while projects and projects[0][1] < W:",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][1] < W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while projects and projects[0][1] <= W:",
      "mutated_line": "while projects and projects[0][1] > W:",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][1] > W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while projects and projects[0][1] <= W:",
      "mutated_line": "while projects and projects[0][1] == W:",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][1] == W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "profit, capital = projects.pop(0)",
      "mutated_line": "(profit, capital) = projects.pop(1)",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][1] <= W:\n            (profit, capital) = projects.pop(1)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "profit, capital = projects.pop(0)",
      "mutated_line": "(profit, capital) = projects.pop(-1)",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][1] <= W:\n            (profit, capital) = projects.pop(-1)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "profit, capital = projects.pop(0)",
      "mutated_line": "(profit, capital) = projects.pop(1)",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][1] <= W:\n            (profit, capital) = projects.pop(1)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "heapq.heappush(available_projects, -profit)",
      "mutated_line": "heapq.heappush(available_projects, +profit)",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][1] <= W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, +profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "projects = sorted(zip(Profits, Capital), key=lambda x: x[1])",
      "mutated_line": "projects = sorted(zip(Profits, Capital), key=lambda x: x[2])",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[2])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][1] <= W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "projects = sorted(zip(Profits, Capital), key=lambda x: x[1])",
      "mutated_line": "projects = sorted(zip(Profits, Capital), key=lambda x: x[0])",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[0])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][1] <= W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "projects = sorted(zip(Profits, Capital), key=lambda x: x[1])",
      "mutated_line": "projects = sorted(zip(Profits, Capital), key=lambda x: x[0])",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[0])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][1] <= W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "projects = sorted(zip(Profits, Capital), key=lambda x: x[1])",
      "mutated_line": "projects = sorted(zip(Profits, Capital), key=lambda x: x[-1])",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[-1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][1] <= W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while projects and projects[0][1] <= W:",
      "mutated_line": "while projects and projects[0][2] <= W:",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][2] <= W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while projects and projects[0][1] <= W:",
      "mutated_line": "while projects and projects[0][0] <= W:",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][0] <= W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while projects and projects[0][1] <= W:",
      "mutated_line": "while projects and projects[0][0] <= W:",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][0] <= W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while projects and projects[0][1] <= W:",
      "mutated_line": "while projects and projects[0][-1] <= W:",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[0][-1] <= W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while projects and projects[0][1] <= W:",
      "mutated_line": "while projects and projects[1][1] <= W:",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[1][1] <= W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while projects and projects[0][1] <= W:",
      "mutated_line": "while projects and projects[-1][1] <= W:",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[-1][1] <= W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while projects and projects[0][1] <= W:",
      "mutated_line": "while projects and projects[1][1] <= W:",
      "code": "import heapq\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    n = len(Profits)\n    projects = sorted(zip(Profits, Capital), key=lambda x: x[1])\n    available_projects = []\n    for _ in range(k):\n        while projects and projects[1][1] <= W:\n            (profit, capital) = projects.pop(0)\n            heapq.heappush(available_projects, -profit)\n        if available_projects:\n            W -= heapq.heappop(available_projects)\n        else:\n            break\n    return W"
    }
  ]
}