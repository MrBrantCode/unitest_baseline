{
  "task_id": "cf_39129",
  "entry_point": "entrance",
  "mutant_count": 34,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "obj.position += obj.velocity * time_step",
      "mutated_line": "obj.position -= obj.velocity * time_step",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position -= obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "obj.velocity += acceleration * time_step",
      "mutated_line": "obj.velocity -= acceleration * time_step",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity -= acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "num_steps = int(duration / time_step)",
      "mutated_line": "num_steps = int(duration * time_step)",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration * time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "num_steps = int(duration / time_step)",
      "mutated_line": "num_steps = int(duration // time_step)",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration // time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "obj.position += obj.velocity * time_step",
      "mutated_line": "obj.position += obj.velocity / time_step",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity / time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "obj.position += obj.velocity * time_step",
      "mutated_line": "obj.position += obj.velocity + time_step",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity + time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "obj.position += obj.velocity * time_step",
      "mutated_line": "obj.position += obj.velocity ** time_step",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity ** time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "obj.velocity += acceleration * time_step",
      "mutated_line": "obj.velocity += acceleration / time_step",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration / time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "obj.velocity += acceleration * time_step",
      "mutated_line": "obj.velocity += acceleration + time_step",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration + time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "obj.velocity += acceleration * time_step",
      "mutated_line": "obj.velocity += acceleration ** time_step",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration ** time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if other_obj != obj:",
      "mutated_line": "if other_obj == obj:",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj == obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "acceleration += force_magnitude / obj.mass * force_direction",
      "mutated_line": "acceleration -= force_magnitude / obj.mass * force_direction",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration -= force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "displacement = other_obj.position - obj.position",
      "mutated_line": "displacement = other_obj.position + obj.position",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position + obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "displacement = other_obj.position - obj.position",
      "mutated_line": "displacement = other_obj.position * obj.position",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position * obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "force_magnitude = (obj.mass * other_obj.mass) / distance**2",
      "mutated_line": "force_magnitude = obj.mass * other_obj.mass * distance ** 2",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass * distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "force_magnitude = (obj.mass * other_obj.mass) / distance**2",
      "mutated_line": "force_magnitude = obj.mass * other_obj.mass // distance ** 2",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass // distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "force_direction = displacement / distance",
      "mutated_line": "force_direction = displacement * distance",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement * distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "force_direction = displacement / distance",
      "mutated_line": "force_direction = displacement // distance",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement // distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "acceleration += force_magnitude / obj.mass * force_direction",
      "mutated_line": "acceleration += force_magnitude / obj.mass / force_direction",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass / force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "acceleration += force_magnitude / obj.mass * force_direction",
      "mutated_line": "acceleration += force_magnitude / obj.mass + force_direction",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass + force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "acceleration += force_magnitude / obj.mass * force_direction",
      "mutated_line": "acceleration += (force_magnitude / obj.mass) ** force_direction",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += (force_magnitude / obj.mass) ** force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "force_magnitude = (obj.mass * other_obj.mass) / distance**2",
      "mutated_line": "force_magnitude = obj.mass / other_obj.mass / distance ** 2",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass / other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "force_magnitude = (obj.mass * other_obj.mass) / distance**2",
      "mutated_line": "force_magnitude = (obj.mass + other_obj.mass) / distance ** 2",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = (obj.mass + other_obj.mass) / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "force_magnitude = (obj.mass * other_obj.mass) / distance**2",
      "mutated_line": "force_magnitude = obj.mass ** other_obj.mass / distance ** 2",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass ** other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "force_magnitude = (obj.mass * other_obj.mass) / distance**2",
      "mutated_line": "force_magnitude = obj.mass * other_obj.mass / (distance * 2)",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / (distance * 2)\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "force_magnitude = (obj.mass * other_obj.mass) / distance**2",
      "mutated_line": "force_magnitude = obj.mass * other_obj.mass / (distance + 2)",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / (distance + 2)\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "acceleration += force_magnitude / obj.mass * force_direction",
      "mutated_line": "acceleration += force_magnitude * obj.mass * force_direction",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude * obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "acceleration += force_magnitude / obj.mass * force_direction",
      "mutated_line": "acceleration += force_magnitude // obj.mass * force_direction",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 2\n            force_direction = displacement / distance\n            acceleration += force_magnitude // obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "force_magnitude = (obj.mass * other_obj.mass) / distance**2",
      "mutated_line": "force_magnitude = obj.mass * other_obj.mass / distance ** 3",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 3\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "force_magnitude = (obj.mass * other_obj.mass) / distance**2",
      "mutated_line": "force_magnitude = obj.mass * other_obj.mass / distance ** 1",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 1\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "force_magnitude = (obj.mass * other_obj.mass) / distance**2",
      "mutated_line": "force_magnitude = obj.mass * other_obj.mass / distance ** 0",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 0\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "force_magnitude = (obj.mass * other_obj.mass) / distance**2",
      "mutated_line": "force_magnitude = obj.mass * other_obj.mass / distance ** 1",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** 1\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "force_magnitude = (obj.mass * other_obj.mass) / distance**2",
      "mutated_line": "force_magnitude = obj.mass * other_obj.mass / distance ** -2",
      "code": "def entrance(masses, initial_positions, initial_velocities, duration, time_step):\n    \"\"\"\n    Simulate the motion of celestial objects over a specified duration.\n\n    Parameters:\n    masses (list): List of masses of celestial objects.\n    initial_positions (list): List of initial positions of celestial objects.\n    initial_velocities (list): List of initial velocities of celestial objects.\n    duration (float): Duration of the simulation.\n    time_step (float): Time step for the simulation.\n\n    Returns:\n    positions_over_time (list): List of positions of celestial objects at each time step.\n    \"\"\"\n    celestial_objects = [CelestialObject(mass, position, velocity) for (mass, position, velocity) in zip(masses, initial_positions, initial_velocities)]\n    num_steps = int(duration / time_step)\n    positions_over_time = []\n    for _ in range(num_steps):\n        positions = [obj.position.tolist() for obj in celestial_objects]\n        positions_over_time.append(positions)\n        _update_positions(celestial_objects, time_step)\n    return positions_over_time\n\ndef _update_positions(celestial_objects, time_step):\n    for obj in celestial_objects:\n        acceleration = _calculate_acceleration(obj, celestial_objects)\n        obj.position += obj.velocity * time_step\n        obj.velocity += acceleration * time_step\n\ndef _calculate_acceleration(obj, celestial_objects):\n    acceleration = np.zeros_like(obj.position)\n    for other_obj in celestial_objects:\n        if other_obj != obj:\n            displacement = other_obj.position - obj.position\n            distance = np.linalg.norm(displacement)\n            force_magnitude = obj.mass * other_obj.mass / distance ** -2\n            force_direction = displacement / distance\n            acceleration += force_magnitude / obj.mass * force_direction\n    return acceleration\n\nclass CelestialObject:\n\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)"
    }
  ]
}