{
  "task_id": "cf_29902",
  "entry_point": "shortest_path",
  "mutant_count": 13,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "import heapq\n\ndef shortest_path(graph, start, target):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 1\n    queue = [(0, start)]\n    parent = {start: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == target:\n            path = []\n            while current_node:\n                path.append(current_node)\n                current_node = parent[current_node]\n            path.reverse()\n            return (path, distances[target])\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n                parent[neighbor] = current_node\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = -1",
      "code": "import heapq\n\ndef shortest_path(graph, start, target):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = -1\n    queue = [(0, start)]\n    parent = {start: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == target:\n            path = []\n            while current_node:\n                path.append(current_node)\n                current_node = parent[current_node]\n            path.reverse()\n            return (path, distances[target])\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n                parent[neighbor] = current_node\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "import heapq\n\ndef shortest_path(graph, start, target):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 1\n    queue = [(0, start)]\n    parent = {start: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == target:\n            path = []\n            while current_node:\n                path.append(current_node)\n                current_node = parent[current_node]\n            path.reverse()\n            return (path, distances[target])\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n                parent[neighbor] = current_node\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if current_node == target:",
      "mutated_line": "if current_node != target:",
      "code": "import heapq\n\ndef shortest_path(graph, start, target):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [(0, start)]\n    parent = {start: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node != target:\n            path = []\n            while current_node:\n                path.append(current_node)\n                current_node = parent[current_node]\n            path.reverse()\n            return (path, distances[target])\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n                parent[neighbor] = current_node\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "distances = {node: float('inf') for node in graph}",
      "mutated_line": "distances = {node: float('') for node in graph}",
      "code": "import heapq\n\ndef shortest_path(graph, start, target):\n    distances = {node: float('') for node in graph}\n    distances[start] = 0\n    queue = [(0, start)]\n    parent = {start: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == target:\n            path = []\n            while current_node:\n                path.append(current_node)\n                current_node = parent[current_node]\n            path.reverse()\n            return (path, distances[target])\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n                parent[neighbor] = current_node\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue = [(0, start)]",
      "mutated_line": "queue = [(1, start)]",
      "code": "import heapq\n\ndef shortest_path(graph, start, target):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [(1, start)]\n    parent = {start: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == target:\n            path = []\n            while current_node:\n                path.append(current_node)\n                current_node = parent[current_node]\n            path.reverse()\n            return (path, distances[target])\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n                parent[neighbor] = current_node\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue = [(0, start)]",
      "mutated_line": "queue = [(-1, start)]",
      "code": "import heapq\n\ndef shortest_path(graph, start, target):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [(-1, start)]\n    parent = {start: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == target:\n            path = []\n            while current_node:\n                path.append(current_node)\n                current_node = parent[current_node]\n            path.reverse()\n            return (path, distances[target])\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n                parent[neighbor] = current_node\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue = [(0, start)]",
      "mutated_line": "queue = [(1, start)]",
      "code": "import heapq\n\ndef shortest_path(graph, start, target):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [(1, start)]\n    parent = {start: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == target:\n            path = []\n            while current_node:\n                path.append(current_node)\n                current_node = parent[current_node]\n            path.reverse()\n            return (path, distances[target])\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n                parent[neighbor] = current_node\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "distance = current_distance + weight",
      "mutated_line": "distance = current_distance - weight",
      "code": "import heapq\n\ndef shortest_path(graph, start, target):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [(0, start)]\n    parent = {start: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == target:\n            path = []\n            while current_node:\n                path.append(current_node)\n                current_node = parent[current_node]\n            path.reverse()\n            return (path, distances[target])\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance - weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n                parent[neighbor] = current_node\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "distance = current_distance + weight",
      "mutated_line": "distance = current_distance * weight",
      "code": "import heapq\n\ndef shortest_path(graph, start, target):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [(0, start)]\n    parent = {start: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == target:\n            path = []\n            while current_node:\n                path.append(current_node)\n                current_node = parent[current_node]\n            path.reverse()\n            return (path, distances[target])\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance * weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n                parent[neighbor] = current_node\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance <= distances[neighbor]:",
      "code": "import heapq\n\ndef shortest_path(graph, start, target):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [(0, start)]\n    parent = {start: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == target:\n            path = []\n            while current_node:\n                path.append(current_node)\n                current_node = parent[current_node]\n            path.reverse()\n            return (path, distances[target])\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance <= distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n                parent[neighbor] = current_node\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance >= distances[neighbor]:",
      "code": "import heapq\n\ndef shortest_path(graph, start, target):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [(0, start)]\n    parent = {start: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == target:\n            path = []\n            while current_node:\n                path.append(current_node)\n                current_node = parent[current_node]\n            path.reverse()\n            return (path, distances[target])\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance >= distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n                parent[neighbor] = current_node\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance != distances[neighbor]:",
      "code": "import heapq\n\ndef shortest_path(graph, start, target):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [(0, start)]\n    parent = {start: None}\n    while queue:\n        (current_distance, current_node) = heapq.heappop(queue)\n        if current_node == target:\n            path = []\n            while current_node:\n                path.append(current_node)\n                current_node = parent[current_node]\n            path.reverse()\n            return (path, distances[target])\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance != distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n                parent[neighbor] = current_node\n    return None"
    }
  ]
}