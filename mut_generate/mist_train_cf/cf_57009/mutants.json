{
  "task_id": "cf_57009",
  "entry_point": "delete",
  "mutant_count": 20,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if root.key > x:",
      "mutated_line": "if root.key >= x:",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key >= x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if root.key > x:",
      "mutated_line": "if root.key <= x:",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key <= x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if root.key > x:",
      "mutated_line": "if root.key != x:",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key != x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while(current.left is not None):",
      "mutated_line": "while current.left is None:",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if node is None:",
      "mutated_line": "if node is not None:",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is not None:\n        return 0\n    if node.left is None and node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if node.left is None and node.right is None:",
      "mutated_line": "if node.left is None or node.right is None:",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None or node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif root.key < x:",
      "mutated_line": "elif root.key <= x:",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key <= x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif root.key < x:",
      "mutated_line": "elif root.key >= x:",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key >= x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif root.key < x:",
      "mutated_line": "elif root.key != x:",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key != x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 1\n    if node.left is None and node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return -1\n    if node.left is None and node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 1\n    if node.left is None and node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if node.left is None and node.right is None:",
      "mutated_line": "if node.left is not None and node.right is None:",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is not None and node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if node.left is None and node.right is None:",
      "mutated_line": "if node.left is None and node.right is not None:",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is not None:\n        return 1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return 2\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return 0\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return 0\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return -1\n    else:\n        return count_leaves(node.left) + count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return count_leaves(node.left) + count_leaves(node.right)",
      "mutated_line": "return count_leaves(node.left) - count_leaves(node.right)",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) - count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return count_leaves(node.left) + count_leaves(node.right)",
      "mutated_line": "return count_leaves(node.left) * count_leaves(node.right)",
      "code": "def delete(root, x):\n    if not root:\n        return root\n    if root.key > x:\n        root.left = delete(root.left, x)\n    elif root.key < x:\n        root.right = delete(root.right, x)\n    else:\n        if not root.right:\n            return root.left\n        elif not root.left:\n            return root.right\n        temp = min_value_node(root.right)\n        root.key = temp.key\n        root.right = delete(root.right, temp.key)\n    return root\n\ndef min_value_node(root):\n    current = root\n    while current.left is not None:\n        current = current.left\n    return current\n\nclass Node:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef count_leaves(node):\n    if node is None:\n        return 0\n    if node.left is None and node.right is None:\n        return 1\n    else:\n        return count_leaves(node.left) * count_leaves(node.right)\n\ndef delete_and_count_leaves(root, x):\n    root = delete(root, x)\n    return count_leaves(root)"
    }
  ]
}