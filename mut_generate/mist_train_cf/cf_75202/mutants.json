{
  "task_id": "cf_75202",
  "entry_point": "numComponents",
  "mutant_count": 35,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.rank = [0] * n",
      "mutated_line": "self.rank = [0] / n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] / n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.rank = [0] * n",
      "mutated_line": "self.rank = [0] + n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] + n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.rank = [0] * n",
      "mutated_line": "self.rank = [0] ** n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] ** n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.weights = [0] * n",
      "mutated_line": "self.weights = [0] / n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] / n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.weights = [0] * n",
      "mutated_line": "self.weights = [0] + n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] + n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.weights = [0] * n",
      "mutated_line": "self.weights = [0] ** n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] ** n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if self.parent[x] != x:",
      "mutated_line": "if self.parent[x] == x:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] == x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if rootx != rooty:",
      "mutated_line": "if rootx == rooty:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx == rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "self.weights[rootx] += self.weights[rooty] + weight",
      "mutated_line": "self.weights[rootx] -= self.weights[rooty] + weight",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] -= self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if self.rank[rootx] < self.rank[rooty]:",
      "mutated_line": "if self.rank[rootx] <= self.rank[rooty]:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] <= self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if self.rank[rootx] < self.rank[rooty]:",
      "mutated_line": "if self.rank[rootx] >= self.rank[rooty]:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] >= self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if self.rank[rootx] < self.rank[rooty]:",
      "mutated_line": "if self.rank[rootx] != self.rank[rooty]:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] != self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "self.weights[rootx] += self.weights[rooty] + weight",
      "mutated_line": "self.weights[rootx] += self.weights[rooty] - weight",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] - weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "self.weights[rootx] += self.weights[rooty] + weight",
      "mutated_line": "self.weights[rootx] += self.weights[rooty] * weight",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] * weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if self.rank[rootx] == self.rank[rooty]:",
      "mutated_line": "if self.rank[rootx] != self.rank[rooty]:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] != self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "self.rank[rootx] += 1",
      "mutated_line": "self.rank[rootx] -= 1",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] -= 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.rank = [0] * n",
      "mutated_line": "self.rank = [1] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [1] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.rank = [0] * n",
      "mutated_line": "self.rank = [-1] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [-1] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.rank = [0] * n",
      "mutated_line": "self.rank = [1] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [1] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.weights = [0] * n",
      "mutated_line": "self.weights = [1] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [1] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.weights = [0] * n",
      "mutated_line": "self.weights = [-1] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [-1] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.weights = [0] * n",
      "mutated_line": "self.weights = [1] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [1] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.rank[rootx] += 1",
      "mutated_line": "self.rank[rootx] += 2",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 2\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.rank[rootx] += 1",
      "mutated_line": "self.rank[rootx] += 0",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 0\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.rank[rootx] += 1",
      "mutated_line": "self.rank[rootx] += 0",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 0\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "self.rank[rootx] += 1",
      "mutated_line": "self.rank[rootx] += -1",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += -1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "for ai, bi, wi in sorted(edges, key = lambda x : -x[2]):",
      "mutated_line": "for (ai, bi, wi) in sorted(edges, key=lambda x: +x[2]):",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: +x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "return len([weight for weight in self.weights if weight > k])",
      "mutated_line": "return len([weight for weight in self.weights if weight >= k])",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight >= k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "return len([weight for weight in self.weights if weight > k])",
      "mutated_line": "return len([weight for weight in self.weights if weight <= k])",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight <= k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "return len([weight for weight in self.weights if weight > k])",
      "mutated_line": "return len([weight for weight in self.weights if weight != k])",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight != k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ai, bi, wi in sorted(edges, key = lambda x : -x[2]):",
      "mutated_line": "for (ai, bi, wi) in sorted(edges, key=lambda x: -x[3]):",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[3]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ai, bi, wi in sorted(edges, key = lambda x : -x[2]):",
      "mutated_line": "for (ai, bi, wi) in sorted(edges, key=lambda x: -x[1]):",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[1]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ai, bi, wi in sorted(edges, key = lambda x : -x[2]):",
      "mutated_line": "for (ai, bi, wi) in sorted(edges, key=lambda x: -x[0]):",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[0]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ai, bi, wi in sorted(edges, key = lambda x : -x[2]):",
      "mutated_line": "for (ai, bi, wi) in sorted(edges, key=lambda x: -x[1]):",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[1]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for ai, bi, wi in sorted(edges, key = lambda x : -x[2]):",
      "mutated_line": "for (ai, bi, wi) in sorted(edges, key=lambda x: -x[-2]):",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.weights = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y, weight):\n        (rootx, rooty) = (self.find(x), self.find(y))\n        if rootx != rooty:\n            if self.rank[rootx] < self.rank[rooty]:\n                (rootx, rooty) = (rooty, rootx)\n            self.parent[rooty] = rootx\n            self.weights[rootx] += self.weights[rooty] + weight\n            if self.rank[rootx] == self.rank[rooty]:\n                self.rank[rootx] += 1\n\n    def components(self, k):\n        return len([weight for weight in self.weights if weight > k])\n\ndef numComponents(n, edges, k):\n    uf = UnionFind(n)\n    for (ai, bi, wi) in sorted(edges, key=lambda x: -x[-2]):\n        uf.union(ai, bi, wi)\n    return uf.components(k)"
    }
  ]
}