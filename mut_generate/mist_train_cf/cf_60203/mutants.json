{
  "task_id": "cf_60203",
  "entry_point": "smallestRepunitDivByK",
  "mutant_count": 127,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "Node = namedtuple('Node', 'val, length, ones, zeros')",
      "mutated_line": "Node = namedtuple('', 'val, length, ones, zeros')",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "Node = namedtuple('Node', 'val, length, ones, zeros')",
      "mutated_line": "Node = namedtuple('Node', '')",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', '')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == 0 and K % 5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 and K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 != 0 or K % 5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 != 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == 0 or K % 5 != 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 != 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mod = node.val % K",
      "mutated_line": "mod = node.val * K",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val * K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mod = node.val % K",
      "mutated_line": "mod = node.val + K",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val + K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if mod == 0:",
      "mutated_line": "if mod != 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod != 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if mod not in visited:",
      "mutated_line": "if mod in visited:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (+1, -1, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (+1, -1, -1)"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, +1, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, +1, -1)"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -1, +1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, +1)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K * 2 == 0 or K % 5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K * 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K + 2 == 0 or K % 5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K + 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == 1 or K % 5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 1 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == -1 or K % 5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == -1 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == 1 or K % 5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 1 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == 0 or K * 5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K * 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == 0 or K + 5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K + 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == 0 or K % 5 == 1:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 1:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == 0 or K % 5 == -1:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == -1:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == 0 or K % 5 == 1:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 1:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (+1, -1, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (+1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, +1, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, +1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -1, +1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, +1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(2, 1, 1, 0))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(2, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(0, 1, 1, 0))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(0, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(0, 1, 1, 0))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(0, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(-1, 1, 1, 0))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(-1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(1, 2, 1, 0))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 2, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(1, 0, 1, 0))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 0, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(1, 0, 1, 0))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 0, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(1, -1, 1, 0))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, -1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(1, 1, 2, 0))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 2, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(1, 1, 0, 0))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 0, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(1, 1, 0, 0))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 0, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(1, 1, -1, 0))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, -1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(1, 1, 1, 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 1))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(1, 1, 1, -1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, -1))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue.append(Node(1, 1, 1, 0))",
      "mutated_line": "queue.append(Node(1, 1, 1, 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 1))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if mod == 0:",
      "mutated_line": "if mod == 1:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 1:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if mod == 0:",
      "mutated_line": "if mod == -1:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == -1:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if mod == 0:",
      "mutated_line": "if mod == 1:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 1:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-2, -1, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-2, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-0, -1, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-0, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-0, -1, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-0, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (--1, -1, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (--1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -2, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -2, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -0, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -0, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -0, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -0, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, --1, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, --1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -1, -2)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -2)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -1, -0)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -1, -0)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -1, --1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, --1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 3 == 0 or K % 5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 3 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 1 == 0 or K % 5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 1 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 0 == 0 or K % 5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 0 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 1 == 0 or K % 5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 1 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % -2 == 0 or K % 5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % -2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == 0 or K % 6 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 6 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == 0 or K % 4 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 4 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == 0 or K % 0 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 0 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == 0 or K % 1 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 1 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if K % 2 == 0 or K % 5 == 0:",
      "mutated_line": "if K % 2 == 0 or K % -5 == 0:",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % -5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-2, -1, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-2, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-0, -1, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-0, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-0, -1, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-0, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (--1, -1, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (--1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -2, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -2, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -0, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -0, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -0, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -0, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, --1, -1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, --1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -1, -2)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -2)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -1, -0)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -0)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -1, -0)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -0)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, -1, -1",
      "mutated_line": "return (-1, -1, --1)",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, --1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 10 * K, node.length + 1, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 * K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 10 + K, node.length + 1, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 + K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 10 % K, node.length - 1, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length - 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 10 % K, node.length * 1, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length * 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros - 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros - 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros * 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros * 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 1) * K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) * K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node(mod * 10 + 1 + K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node(mod * 10 + 1 + K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 1) % K, node.length - 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length - 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 1) % K, node.length * 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length * 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones - 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones - 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones * 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones * 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod / 10 % K, node.length + 1, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod / 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node((mod + 10) % K, node.length + 1, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node((mod + 10) % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod ** 10 % K, node.length + 1, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod ** 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 10 % K, node.length + 2, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 2, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 10 % K, node.length + 0, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 0, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 10 % K, node.length + 0, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 0, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 10 % K, node.length + -1, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + -1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 2))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 2))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 0))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 0))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 0))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 0))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + -1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + -1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 - 1) % K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 - 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node(mod * 10 * 1 % K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node(mod * 10 * 1 % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 1) % K, node.length + 2, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 2, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 1) % K, node.length + 0, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 0, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 1) % K, node.length + 0, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 0, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 1) % K, node.length + -1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + -1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 2, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 2, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 0, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 0, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 0, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 0, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + -1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + -1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 11 % K, node.length + 1, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 11 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 9 % K, node.length + 1, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 9 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 0 % K, node.length + 1, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 0 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * 1 % K, node.length + 1, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 1 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue.append(Node((mod*10)%K, node.length+1, node.ones, node.zeros+1))",
      "mutated_line": "queue.append(Node(mod * -10 % K, node.length + 1, node.ones, node.zeros + 1))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * -10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod / 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod / 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod + 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod + 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod ** 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod ** 10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 2) % K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 2) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 0) % K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 0) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + 0) % K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + 0) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 10 + -1) % K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 10 + -1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 11 + 1) % K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 11 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 9 + 1) % K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 9 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 0 + 1) % K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 0 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * 1 + 1) % K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * 1 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(Node((mod*10+1)%K, node.length+1, node.ones+1, node.zeros))",
      "mutated_line": "queue.append(Node((mod * -10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))",
      "code": "from collections import deque, namedtuple\nNode = namedtuple('Node', 'val, length, ones, zeros')\n\ndef smallestRepunitDivByK(K):\n    if K % 2 == 0 or K % 5 == 0:\n        return (-1, -1, -1)\n    visited = set()\n    queue = deque()\n    queue.append(Node(1, 1, 1, 0))\n    while queue:\n        node = queue.popleft()\n        mod = node.val % K\n        if mod == 0:\n            return (node.length, node.ones, node.zeros)\n        if mod not in visited:\n            visited.add(mod)\n            queue.append(Node(mod * 10 % K, node.length + 1, node.ones, node.zeros + 1))\n            queue.append(Node((mod * -10 + 1) % K, node.length + 1, node.ones + 1, node.zeros))\n    return (-1, -1, -1)"
    }
  ]
}