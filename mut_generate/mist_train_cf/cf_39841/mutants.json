{
  "task_id": "cf_39841",
  "entry_point": "lattice_const_to_lammps_box",
  "mutant_count": 81,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "tilts = (b * cos(gamma), 0, 0)",
      "mutated_line": "tilts = (b / cos(gamma), 0, 0)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b / cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "tilts = (b * cos(gamma), 0, 0)",
      "mutated_line": "tilts = (b + cos(gamma), 0, 0)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b + cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "tilts = (b * cos(gamma), 0, 0)",
      "mutated_line": "tilts = (b ** cos(gamma), 0, 0)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b ** cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tilts = (b * cos(gamma), 0, 0)",
      "mutated_line": "tilts = (b * cos(gamma), 1, 0)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 1, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tilts = (b * cos(gamma), 0, 0)",
      "mutated_line": "tilts = (b * cos(gamma), -1, 0)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), -1, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tilts = (b * cos(gamma), 0, 0)",
      "mutated_line": "tilts = (b * cos(gamma), 1, 0)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 1, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tilts = (b * cos(gamma), 0, 0)",
      "mutated_line": "tilts = (b * cos(gamma), 0, 1)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 1)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tilts = (b * cos(gamma), 0, 0)",
      "mutated_line": "tilts = (b * cos(gamma), 0, -1)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, -1)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tilts = (b * cos(gamma), 0, 0)",
      "mutated_line": "tilts = (b * cos(gamma), 0, 1)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 1)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "bounds = ((0, a), (0, b * sin(gamma)), (0, c))",
      "mutated_line": "bounds = ((1, a), (0, b * sin(gamma)), (0, c))",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((1, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "bounds = ((0, a), (0, b * sin(gamma)), (0, c))",
      "mutated_line": "bounds = ((-1, a), (0, b * sin(gamma)), (0, c))",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((-1, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "bounds = ((0, a), (0, b * sin(gamma)), (0, c))",
      "mutated_line": "bounds = ((1, a), (0, b * sin(gamma)), (0, c))",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((1, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "bounds = ((0, a), (0, b * sin(gamma)), (0, c))",
      "mutated_line": "bounds = ((0, a), (1, b * sin(gamma)), (0, c))",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (1, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "bounds = ((0, a), (0, b * sin(gamma)), (0, c))",
      "mutated_line": "bounds = ((0, a), (-1, b * sin(gamma)), (0, c))",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (-1, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "bounds = ((0, a), (0, b * sin(gamma)), (0, c))",
      "mutated_line": "bounds = ((0, a), (1, b * sin(gamma)), (0, c))",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (1, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "bounds = ((0, a), (0, b * sin(gamma)), (0, c))",
      "mutated_line": "bounds = ((0, a), (0, b / sin(gamma)), (0, c))",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b / sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "bounds = ((0, a), (0, b * sin(gamma)), (0, c))",
      "mutated_line": "bounds = ((0, a), (0, b + sin(gamma)), (0, c))",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b + sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "bounds = ((0, a), (0, b * sin(gamma)), (0, c))",
      "mutated_line": "bounds = ((0, a), (0, b ** sin(gamma)), (0, c))",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b ** sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "bounds = ((0, a), (0, b * sin(gamma)), (0, c))",
      "mutated_line": "bounds = ((0, a), (0, b * sin(gamma)), (1, c))",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (1, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "bounds = ((0, a), (0, b * sin(gamma)), (0, c))",
      "mutated_line": "bounds = ((0, a), (0, b * sin(gamma)), (-1, c))",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (-1, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "bounds = ((0, a), (0, b * sin(gamma)), (0, c))",
      "mutated_line": "bounds = ((0, a), (0, b * sin(gamma)), (1, c))",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (1, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "[a, b * cos(gamma), c * cos(beta)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b / cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "[a, b * cos(gamma), c * cos(beta)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b + cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "[a, b * cos(gamma), c * cos(beta)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b ** cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "[a, b * cos(gamma), c * cos(beta)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c / cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "[a, b * cos(gamma), c * cos(beta)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c + cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "[a, b * cos(gamma), c * cos(beta)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c ** cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [1, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [-1, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [1, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b / sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b + sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b ** sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) * sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) // sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [1, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [-1, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [1, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 1, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, -1, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 1, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c / sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c + sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c ** sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c / (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), (c + (cos(alpha) - cos(beta) * cos(gamma))) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c ** (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) + cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) * (cos(beta) * cos(gamma))) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 + ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt((1 - cos(beta) ** 2) * ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) / cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - (cos(beta) + cos(gamma))) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "[0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)],",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) ** cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 + cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 * cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma) * 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma) + 2))]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(2 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(0 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(0 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(-1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) * 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - (cos(beta) + 2) - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) * sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) // sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 3)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 1)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 0)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 1)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** -2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 3 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 1 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 0 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 1 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** -2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) + cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - (cos(alpha) * (cos(beta) * cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) / cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - (cos(beta) + cos(gamma))) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "[0, 0, c * sqrt(1 - cos(beta)**2 - ((cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma))**2)]",
      "mutated_line": "return (bounds, tilts, rotation_matrix)",
      "code": "import numpy as np\nfrom math import sin, cos, sqrt\n\ndef lattice_const_to_lammps_box(lengths, angles):\n    (a, b, c) = lengths\n    (alpha, beta, gamma) = angles\n    bounds = ((0, a), (0, b * sin(gamma)), (0, c))\n    tilts = (b * cos(gamma), 0, 0)\n    rotation_matrix = np.array([[a, b * cos(gamma), c * cos(beta)], [0, b * sin(gamma), c * (cos(alpha) - cos(beta) * cos(gamma)) / sin(gamma)], [0, 0, c * sqrt(1 - cos(beta) ** 2 - ((cos(alpha) - cos(beta) ** cos(gamma)) / sin(gamma)) ** 2)]])\n    return (bounds, tilts, rotation_matrix)"
    }
  ]
}