{
  "task_id": "cf_9608",
  "entry_point": "segmented_sieve",
  "mutant_count": 91,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "is_prime = [True] * (B - A + 1)",
      "mutated_line": "is_prime = [True] / (B - A + 1)",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] / (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "is_prime = [True] * (B - A + 1)",
      "mutated_line": "is_prime = [True] + (B - A + 1)",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] + (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "is_prime = [True] * (B - A + 1)",
      "mutated_line": "is_prime = [True] ** (B - A + 1)",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] ** (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prime[0] = prime[1] = False",
      "mutated_line": "prime[0] = prime[1] = True",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = True\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "p = 2",
      "mutated_line": "while p * p <= n:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "p = 2",
      "mutated_line": "while p * p <= n:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 1\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "p = 2",
      "mutated_line": "while p * p <= n:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 0\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "p = 2",
      "mutated_line": "while p * p <= n:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 1\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "p = 2",
      "mutated_line": "while p * p <= n:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = -2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while p*p <= n:",
      "mutated_line": "while p * p < n:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p < n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while p*p <= n:",
      "mutated_line": "while p * p > n:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p > n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while p*p <= n:",
      "mutated_line": "while p * p == n:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p == n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "p += 1",
      "mutated_line": "p -= 1",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p -= 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "is_prime = [True] * (B - A + 1)",
      "mutated_line": "is_prime = [True] * (B - A - 1)",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A - 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "is_prime = [True] * (B - A + 1)",
      "mutated_line": "is_prime = [True] * ((B - A) * 1)",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * ((B - A) * 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if prime <= limit:",
      "mutated_line": "if prime < limit:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime < limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if prime <= limit:",
      "mutated_line": "if prime > limit:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime > limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if prime <= limit:",
      "mutated_line": "if prime == limit:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime == limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(A, B + 1):",
      "mutated_line": "for i in range(A, B - 1):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B - 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(A, B + 1):",
      "mutated_line": "for i in range(A, B * 1):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B * 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "prime = [True for _ in range(n+1)]",
      "mutated_line": "prime = [False for _ in range(n + 1)]",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [False for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prime[0] = prime[1] = False",
      "mutated_line": "prime[1] = prime[1] = False",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[1] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prime[0] = prime[1] = False",
      "mutated_line": "prime[-1] = prime[1] = False",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[-1] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prime[0] = prime[1] = False",
      "mutated_line": "prime[1] = prime[1] = False",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[1] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prime[0] = prime[1] = False",
      "mutated_line": "prime[0] = prime[2] = False",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[2] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prime[0] = prime[1] = False",
      "mutated_line": "prime[0] = prime[0] = False",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[0] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prime[0] = prime[1] = False",
      "mutated_line": "prime[0] = prime[0] = False",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[0] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prime[0] = prime[1] = False",
      "mutated_line": "prime[0] = prime[-1] = False",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[-1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "while p*p <= n:",
      "mutated_line": "while p / p <= n:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p / p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "while p*p <= n:",
      "mutated_line": "while p + p <= n:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p + p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "while p*p <= n:",
      "mutated_line": "while p ** p <= n:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p ** p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "p += 1",
      "mutated_line": "p += 2",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 2\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 0\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 0\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "p += 1",
      "mutated_line": "p += -1",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += -1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for p in range(2, n+1):",
      "mutated_line": "for p in range(3, n + 1):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(3, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for p in range(2, n+1):",
      "mutated_line": "for p in range(1, n + 1):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(1, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for p in range(2, n+1):",
      "mutated_line": "for p in range(0, n + 1):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(0, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for p in range(2, n+1):",
      "mutated_line": "for p in range(1, n + 1):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(1, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for p in range(2, n+1):",
      "mutated_line": "for p in range(-2, n + 1):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(-2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "for p in range(2, n+1):",
      "mutated_line": "for p in range(2, n - 1):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n - 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "for p in range(2, n+1):",
      "mutated_line": "for p in range(2, n * 1):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n * 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "is_prime = [True] * (B - A + 1)",
      "mutated_line": "is_prime = [False] * (B - A + 1)",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [False] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "is_prime = [True] * (B - A + 1)",
      "mutated_line": "is_prime = [True] * (B + A + 1)",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B + A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "is_prime = [True] * (B - A + 1)",
      "mutated_line": "is_prime = [True] * (B * A + 1)",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B * A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "is_prime = [True] * (B - A + 1)",
      "mutated_line": "is_prime = [True] * (B - A + 2)",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 2)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "is_prime = [True] * (B - A + 1)",
      "mutated_line": "is_prime = [True] * (B - A + 0)",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 0)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "is_prime = [True] * (B - A + 1)",
      "mutated_line": "is_prime = [True] * (B - A + 0)",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 0)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "is_prime = [True] * (B - A + 1)",
      "mutated_line": "is_prime = [True] * (B - A + -1)",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + -1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "start = math.ceil(A / prime) * prime",
      "mutated_line": "start = math.ceil(A / prime) / prime",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) / prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "start = math.ceil(A / prime) * prime",
      "mutated_line": "start = math.ceil(A / prime) + prime",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) + prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "start = math.ceil(A / prime) * prime",
      "mutated_line": "start = math.ceil(A / prime) ** prime",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) ** prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if start == prime:",
      "mutated_line": "if start != prime:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start != prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "start += prime",
      "mutated_line": "start -= prime",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start -= prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(A, B + 1):",
      "mutated_line": "for i in range(A, B + 2):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 2):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(A, B + 1):",
      "mutated_line": "for i in range(A, B + 0):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 0):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(A, B + 1):",
      "mutated_line": "for i in range(A, B + 0):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 0):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(A, B + 1):",
      "mutated_line": "for i in range(A, B + -1):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + -1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if is_prime[i - A]:",
      "mutated_line": "if is_prime[i + A]:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i + A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if is_prime[i - A]:",
      "mutated_line": "if is_prime[i * A]:",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i * A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for p in range(2, n+1):",
      "mutated_line": "for p in range(2, n + 2):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 2):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for p in range(2, n+1):",
      "mutated_line": "for p in range(2, n + 0):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 0):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for p in range(2, n+1):",
      "mutated_line": "for p in range(2, n + 0):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 0):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for p in range(2, n+1):",
      "mutated_line": "for p in range(2, n + -1):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + -1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(start, B + 1, prime):",
      "mutated_line": "for i in range(start, B - 1, prime):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B - 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(start, B + 1, prime):",
      "mutated_line": "for i in range(start, B * 1, prime):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B * 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "is_prime[i - A] = False",
      "mutated_line": "is_prime[i - A] = True",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = True\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "prime = [True for _ in range(n+1)]",
      "mutated_line": "prime = [True for _ in range(n - 1)]",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n - 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "prime = [True for _ in range(n+1)]",
      "mutated_line": "prime = [True for _ in range(n * 1)]",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n * 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(p*p, n+1, p):",
      "mutated_line": "for i in range(p / p, n + 1, p):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p / p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(p*p, n+1, p):",
      "mutated_line": "for i in range(p + p, n + 1, p):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p + p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(p*p, n+1, p):",
      "mutated_line": "for i in range(p ** p, n + 1, p):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p ** p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(p*p, n+1, p):",
      "mutated_line": "for i in range(p * p, n - 1, p):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n - 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(p*p, n+1, p):",
      "mutated_line": "for i in range(p * p, n * 1, p):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n * 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "prime[i] = False",
      "mutated_line": "prime[i] = True",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = True\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "start = math.ceil(A / prime) * prime",
      "mutated_line": "start = math.ceil(A * prime) * prime",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A * prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "start = math.ceil(A / prime) * prime",
      "mutated_line": "start = math.ceil(A // prime) * prime",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A // prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(start, B + 1, prime):",
      "mutated_line": "for i in range(start, B + 2, prime):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 2, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(start, B + 1, prime):",
      "mutated_line": "for i in range(start, B + 0, prime):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 0, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(start, B + 1, prime):",
      "mutated_line": "for i in range(start, B + 0, prime):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 0, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(start, B + 1, prime):",
      "mutated_line": "for i in range(start, B + -1, prime):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + -1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "is_prime[i - A] = False",
      "mutated_line": "is_prime[i + A] = False",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i + A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "is_prime[i - A] = False",
      "mutated_line": "is_prime[i * A] = False",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i * A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "prime = [True for _ in range(n+1)]",
      "mutated_line": "prime = [True for _ in range(n + 2)]",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 2)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "prime = [True for _ in range(n+1)]",
      "mutated_line": "prime = [True for _ in range(n + 0)]",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 0)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "prime = [True for _ in range(n+1)]",
      "mutated_line": "prime = [True for _ in range(n + 0)]",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 0)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "prime = [True for _ in range(n+1)]",
      "mutated_line": "prime = [True for _ in range(n + -1)]",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + -1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(p*p, n+1, p):",
      "mutated_line": "for i in range(p * p, n + 2, p):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 2, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(p*p, n+1, p):",
      "mutated_line": "for i in range(p * p, n + 0, p):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 0, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(p*p, n+1, p):",
      "mutated_line": "for i in range(p * p, n + 0, p):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + 0, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(p*p, n+1, p):",
      "mutated_line": "for i in range(p * p, n + -1, p):",
      "code": "import math\n\ndef segmented_sieve(A, B):\n    limit = int(math.sqrt(B))\n    primes = sieve(limit)\n    is_prime = [True] * (B - A + 1)\n    for prime in primes:\n        if prime <= limit:\n            start = math.ceil(A / prime) * prime\n            if start == prime:\n                start += prime\n            for i in range(start, B + 1, prime):\n                is_prime[i - A] = False\n    primes_list = []\n    for i in range(A, B + 1):\n        if is_prime[i - A]:\n            primes_list.append(i)\n    return primes_list\n\ndef sieve(n):\n    prime = [True for _ in range(n + 1)]\n    prime[0] = prime[1] = False\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n + -1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(p)\n    return primes"
    }
  ]
}