{
  "task_id": "cf_51347",
  "entry_point": "entance",
  "mutant_count": 85,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'+': Operator(1, 'L'),",
      "mutated_line": "operators = {'': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'-': Operator(1, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'*': Operator(2, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'/': Operator(2, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'^': Operator(3, 'R'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "'(': Operator(0, ''),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "')': Operator(0, ''),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), '': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), '': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "output = ''",
      "mutated_line": "output = 'MUTATED'",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = 'MUTATED'\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "output += stack.pop()",
      "mutated_line": "output -= stack.pop()",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output -= stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'+': Operator(1, 'L'),",
      "mutated_line": "operators = {'+': Operator(2, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(2, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'+': Operator(1, 'L'),",
      "mutated_line": "operators = {'+': Operator(0, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(0, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'+': Operator(1, 'L'),",
      "mutated_line": "operators = {'+': Operator(0, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(0, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'+': Operator(1, 'L'),",
      "mutated_line": "operators = {'+': Operator(-1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(-1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'+': Operator(1, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, ''), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, ''), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'-': Operator(1, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(2, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(2, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'-': Operator(1, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(0, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(0, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'-': Operator(1, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(0, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(0, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'-': Operator(1, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(-1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(-1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'-': Operator(1, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, ''), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, ''), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'*': Operator(2, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(3, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(3, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'*': Operator(2, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(1, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(1, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'*': Operator(2, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(0, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(0, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'*': Operator(2, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(1, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(1, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'*': Operator(2, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(-2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(-2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'*': Operator(2, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, ''), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, ''), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'/': Operator(2, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(3, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(3, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'/': Operator(2, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(1, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(1, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'/': Operator(2, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(0, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(0, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'/': Operator(2, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(1, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(1, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'/': Operator(2, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(-2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(-2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'/': Operator(2, 'L'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, ''), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, ''), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'^': Operator(3, 'R'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(4, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(4, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'^': Operator(3, 'R'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(2, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(2, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'^': Operator(3, 'R'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(0, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(0, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'^': Operator(3, 'R'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(1, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(1, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'^': Operator(3, 'R'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(-3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(-3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'^': Operator(3, 'R'),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, ''), '(': Operator(0, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, ''), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "'(': Operator(0, ''),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(1, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(1, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "'(': Operator(0, ''),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(-1, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(-1, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "'(': Operator(0, ''),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(1, ''), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(1, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "'(': Operator(0, ''),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, 'MUTATED'), ')': Operator(0, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, 'MUTATED'), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "')': Operator(0, ''),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(1, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(1, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "')': Operator(0, ''),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(-1, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(-1, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "')': Operator(0, ''),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(1, '')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(1, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "')': Operator(0, ''),",
      "mutated_line": "operators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, 'MUTATED')}",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, 'MUTATED')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if char not in operators:",
      "mutated_line": "if char in operators:",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "output += char",
      "mutated_line": "output -= char",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output -= char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif char == '(':",
      "mutated_line": "elif char != '(':",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char != '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif char == '(':",
      "mutated_line": "elif char == '':",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif char == ')':",
      "mutated_line": "elif char != ')':",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char != ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif char == ')':",
      "mutated_line": "elif char == '':",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == '':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack or stack[-1] != '(':",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack or stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "output += stack.pop()",
      "mutated_line": "output -= stack.pop()",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output -= stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack or (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack or (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "output += stack.pop()",
      "mutated_line": "output -= stack.pop()",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output -= stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack and stack[-1] == '(':",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] == '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) and (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) and (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack and stack[-1] != '':",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and ((operators[char].associativity == 'L' or operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and ((operators[char].associativity == 'L' or operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' or operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' or operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack and stack[+1] != '(':",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[+1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity != 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity != 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence < operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence < operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence > operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence > operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence == operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence == operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity != 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity != 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence <= operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence <= operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence >= operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence >= operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence != operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence != operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack and stack[-2] != '(':",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-2] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack and stack[-0] != '(':",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-0] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack and stack[-0] != '(':",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-0] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while stack and stack[-1] != '(':",
      "mutated_line": "while stack and stack[--1] != '(':",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[--1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == '' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == '' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == '' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == '' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[+1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[+1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[+1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[+1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-2]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-2]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-0]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-0]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-0]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-0]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[--1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[--1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-2]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-2]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-0]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-0]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-0]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-0]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while stack and ((operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence) or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[-1]].precedence)):",
      "mutated_line": "while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[--1]].precedence)):",
      "code": "class Operator:\n\n    def __init__(self, precedence, associativity):\n        self.precedence = precedence\n        self.associativity = associativity\noperators = {'+': Operator(1, 'L'), '-': Operator(1, 'L'), '*': Operator(2, 'L'), '/': Operator(2, 'L'), '^': Operator(3, 'R'), '(': Operator(0, ''), ')': Operator(0, '')}\n\ndef entance(expression):\n    output = ''\n    stack = []\n    for char in expression:\n        if char.isspace():\n            continue\n        if char not in operators:\n            output += char\n        elif char == '(':\n            stack.append(char)\n        elif char == ')':\n            while stack and stack[-1] != '(':\n                output += stack.pop()\n            stack.pop()\n        else:\n            while stack and (operators[char].associativity == 'L' and operators[char].precedence <= operators[stack[-1]].precedence or (operators[char].associativity == 'R' and operators[char].precedence < operators[stack[--1]].precedence)):\n                output += stack.pop()\n            stack.append(char)\n    while stack:\n        output += stack.pop()\n    return output"
    }
  ]
}