{
  "task_id": "cf_62412",
  "entry_point": "check_anagram_samples",
  "mutant_count": 39,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\"\"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(2, length // 2 + 1):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(2, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(0, length // 2 + 1):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(0, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(0, length // 2 + 1):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(0, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(-1, length // 2 + 1):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(-1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(1, length // 2 - 1):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 - 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(1, length // 2 * 1):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 * 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if length % size != 0:  # if can't evenly partition, skip",
      "mutated_line": "if length % size == 0:",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size == 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(1, length / 2 + 1):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length / 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(1, length * 2 + 1):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length * 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(1, length // 2 + 2):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 2):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(1, length // 2 + 0):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 0):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(1, length // 2 + 0):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 0):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(1, length // 2 + -1):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + -1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if length % size != 0:  # if can't evenly partition, skip",
      "mutated_line": "if length * size != 0:",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length * size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if length % size != 0:  # if can't evenly partition, skip",
      "mutated_line": "if length + size != 0:",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length + size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if length % size != 0:  # if can't evenly partition, skip",
      "mutated_line": "if length % size != 1:",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 1:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if length % size != 0:  # if can't evenly partition, skip",
      "mutated_line": "if length % size != -1:",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != -1:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if length % size != 0:  # if can't evenly partition, skip",
      "mutated_line": "if length % size != 1:",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 1:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return False\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(1, length // 3 + 1):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 3 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(1, length // 1 + 1):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 1 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(1, length // 0 + 1):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 0 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(1, length // 1 + 1):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 1 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for size in range(1, length // 2 + 1):  # size of partition",
      "mutated_line": "for size in range(1, length // -2 + 1):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // -2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if all(count == partition_counts[0] for count in partition_counts[1:]):",
      "mutated_line": "if all((count != partition_counts[0] for count in partition_counts[1:])):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count != partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "partition_counts = [Counter(text[i:i+size]) for i in range(0, length, size)]",
      "mutated_line": "partition_counts = [Counter(text[i:i + size]) for i in range(1, length, size)]",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(1, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "partition_counts = [Counter(text[i:i+size]) for i in range(0, length, size)]",
      "mutated_line": "partition_counts = [Counter(text[i:i + size]) for i in range(-1, length, size)]",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(-1, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "partition_counts = [Counter(text[i:i+size]) for i in range(0, length, size)]",
      "mutated_line": "partition_counts = [Counter(text[i:i + size]) for i in range(1, length, size)]",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(1, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "partition_counts = [Counter(text[i:i+size]) for i in range(0, length, size)]",
      "mutated_line": "partition_counts = [Counter(text[i:i - size]) for i in range(0, length, size)]",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i - size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "partition_counts = [Counter(text[i:i+size]) for i in range(0, length, size)]",
      "mutated_line": "partition_counts = [Counter(text[i:i * size]) for i in range(0, length, size)]",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i * size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if all(count == partition_counts[0] for count in partition_counts[1:]):",
      "mutated_line": "if all((count == partition_counts[1] for count in partition_counts[1:])):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[1] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if all(count == partition_counts[0] for count in partition_counts[1:]):",
      "mutated_line": "if all((count == partition_counts[-1] for count in partition_counts[1:])):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[-1] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if all(count == partition_counts[0] for count in partition_counts[1:]):",
      "mutated_line": "if all((count == partition_counts[1] for count in partition_counts[1:])):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[1] for count in partition_counts[1:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if all(count == partition_counts[0] for count in partition_counts[1:]):",
      "mutated_line": "if all((count == partition_counts[0] for count in partition_counts[2:])):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[2:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if all(count == partition_counts[0] for count in partition_counts[1:]):",
      "mutated_line": "if all((count == partition_counts[0] for count in partition_counts[0:])):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[0:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if all(count == partition_counts[0] for count in partition_counts[1:]):",
      "mutated_line": "if all((count == partition_counts[0] for count in partition_counts[0:])):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[0:])):\n            return True\n    return False"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if all(count == partition_counts[0] for count in partition_counts[1:]):",
      "mutated_line": "if all((count == partition_counts[0] for count in partition_counts[-1:])):",
      "code": "from collections import Counter\n\ndef check_anagram_samples(text: str) -> bool:\n    \"\"\" Given a string, decide if it can be partitioned into two or more substrings which are anagrams of each other \"\"\"\n    length = len(text)\n    for size in range(1, length // 2 + 1):\n        if length % size != 0:\n            continue\n        partition_counts = [Counter(text[i:i + size]) for i in range(0, length, size)]\n        if all((count == partition_counts[0] for count in partition_counts[-1:])):\n            return True\n    return False"
    }
  ]
}