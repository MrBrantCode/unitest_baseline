{
  "task_id": "cf_80500",
  "entry_point": "heaviest_combination",
  "mutant_count": 27,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "best_weight = 0",
      "mutated_line": "best_weight = 1",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 1\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "best_weight = 0",
      "mutated_line": "best_weight = -1",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = -1\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "best_weight = 0",
      "mutated_line": "best_weight = 1",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 1\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(2**len(objects)):",
      "mutated_line": "for i in range(2 * len(objects)):",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 * len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(2**len(objects)):",
      "mutated_line": "for i in range(2 + len(objects)):",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 + len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "weight = 0",
      "mutated_line": "weight = 1",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 1\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "weight = 0",
      "mutated_line": "weight = -1",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = -1\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "weight = 0",
      "mutated_line": "weight = 1",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 1\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if weight > best_weight and weight <= limit:",
      "mutated_line": "if weight > best_weight or weight <= limit:",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight or weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2**len(objects)):",
      "mutated_line": "for i in range(3 ** len(objects)):",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(3 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2**len(objects)):",
      "mutated_line": "for i in range(1 ** len(objects)):",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(1 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2**len(objects)):",
      "mutated_line": "for i in range(0 ** len(objects)):",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(0 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2**len(objects)):",
      "mutated_line": "for i in range(1 ** len(objects)):",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(1 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2**len(objects)):",
      "mutated_line": "for i in range(-2 ** len(objects)):",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(-2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if (i >> j) & 1:",
      "mutated_line": "if i >> j | 1:",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j | 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "weight += weights[j]",
      "mutated_line": "weight -= weights[j]",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight -= weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if weight > best_weight and weight <= limit:",
      "mutated_line": "if weight >= best_weight and weight <= limit:",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight >= best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if weight > best_weight and weight <= limit:",
      "mutated_line": "if weight <= best_weight and weight <= limit:",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight <= best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if weight > best_weight and weight <= limit:",
      "mutated_line": "if weight != best_weight and weight <= limit:",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight != best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if weight > best_weight and weight <= limit:",
      "mutated_line": "if weight > best_weight and weight < limit:",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight < limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if weight > best_weight and weight <= limit:",
      "mutated_line": "if weight > best_weight and weight > limit:",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight > limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if weight > best_weight and weight <= limit:",
      "mutated_line": "if weight > best_weight and weight == limit:",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight == limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (i >> j) & 1:",
      "mutated_line": "if i >> j & 2:",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 2:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (i >> j) & 1:",
      "mutated_line": "if i >> j & 0:",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 0:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (i >> j) & 1:",
      "mutated_line": "if i >> j & 0:",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & 0:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if (i >> j) & 1:",
      "mutated_line": "if i >> j & -1:",
      "code": "def heaviest_combination(objects, weights, limit):\n    \"\"\"\n    Returns the combination of objects that results in the heaviest weight without exceeding the given limit.\n    \n    Args:\n        objects (list): A list of object names.\n        weights (list): A list of corresponding object weights.\n        limit (float): A weight limit.\n    \n    Returns:\n        list: The heaviest combination of objects within the limit.\n    \"\"\"\n    best_weight = 0\n    best_combination = []\n    for i in range(2 ** len(objects)):\n        combination = []\n        weight = 0\n        for j in range(len(objects)):\n            if i >> j & -1:\n                combination.append(objects[j])\n                weight += weights[j]\n        if weight > best_weight and weight <= limit:\n            best_weight = weight\n            best_combination = combination\n    return best_combination"
    }
  ]
}