{
  "task_id": "cf_99061",
  "entry_point": "heuristic",
  "mutant_count": 191,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVE_COST_STRAIGHT = 10",
      "mutated_line": "MOVE_COST_STRAIGHT = 11",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 11\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVE_COST_STRAIGHT = 10",
      "mutated_line": "MOVE_COST_STRAIGHT = 9",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 9\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVE_COST_STRAIGHT = 10",
      "mutated_line": "MOVE_COST_STRAIGHT = 0",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 0\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVE_COST_STRAIGHT = 10",
      "mutated_line": "MOVE_COST_STRAIGHT = 1",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 1\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOVE_COST_STRAIGHT = 10",
      "mutated_line": "MOVE_COST_STRAIGHT = -10",
      "code": "import heapq\nMOVE_COST_STRAIGHT = -10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOVE_COST_DIAGONAL = 14",
      "mutated_line": "MOVE_COST_DIAGONAL = 15",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 15\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOVE_COST_DIAGONAL = 14",
      "mutated_line": "MOVE_COST_DIAGONAL = 13",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 13\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOVE_COST_DIAGONAL = 14",
      "mutated_line": "MOVE_COST_DIAGONAL = 0",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 0\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOVE_COST_DIAGONAL = 14",
      "mutated_line": "MOVE_COST_DIAGONAL = 1",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 1\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOVE_COST_DIAGONAL = 14",
      "mutated_line": "MOVE_COST_DIAGONAL = -14",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = -14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) - (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) - (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) * ((MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy))",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) * ((MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy))\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dx = abs(position[0] - goal[0])",
      "mutated_line": "dx = abs(position[0] + goal[0])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] + goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dx = abs(position[0] - goal[0])",
      "mutated_line": "dx = abs(position[0] * goal[0])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] * goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dy = abs(position[1] - goal[1])",
      "mutated_line": "dy = abs(position[1] + goal[1])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] + goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dy = abs(position[1] - goal[1])",
      "mutated_line": "dy = abs(position[1] * goal[1])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] * goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT / (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT / (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT + (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT + (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT ** (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT ** (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) / min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) / min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT + min(dx, dy))",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT + min(dx, dy))\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) ** min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) ** min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "g_scores = {start: 0}",
      "mutated_line": "g_scores = {start: 1}",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 1}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "g_scores = {start: 0}",
      "mutated_line": "g_scores = {start: -1}",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: -1}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "g_scores = {start: 0}",
      "mutated_line": "g_scores = {start: 1}",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 1}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if current == goal:",
      "mutated_line": "if current != goal:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current != goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx - dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx - dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx * dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx * dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL + 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL + 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) + MOVE_COST_DIAGONAL * (2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + MOVE_COST_DIAGONAL * (2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(open_set, (0, start))",
      "mutated_line": "heapq.heappush(open_set, (1, start))",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (1, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(open_set, (0, start))",
      "mutated_line": "heapq.heappush(open_set, (-1, start))",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (-1, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(open_set, (0, start))",
      "mutated_line": "heapq.heappush(open_set, (1, start))",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (1, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "current = heapq.heappop(open_set)[1]",
      "mutated_line": "current = heapq.heappop(open_set)[2]",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[2]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "current = heapq.heappop(open_set)[1]",
      "mutated_line": "current = heapq.heappop(open_set)[0]",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[0]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "current = heapq.heappop(open_set)[1]",
      "mutated_line": "current = heapq.heappop(open_set)[0]",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[0]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "current = heapq.heappop(open_set)[1]",
      "mutated_line": "current = heapq.heappop(open_set)[-1]",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[-1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while current in came_from:",
      "mutated_line": "while current not in came_from:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current not in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) and grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) and grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)",
      "mutated_line": "tentative_g_score = g_scores[current] - (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] - (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)",
      "mutated_line": "tentative_g_score = g_scores[current] * (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] * (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):",
      "mutated_line": "if neighbor in closed_set or tentative_g_score >= g_scores.get(neighbor, float('inf')):",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set or tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if tentative_g_score < g_scores.get(neighbor, float('inf')):",
      "mutated_line": "if tentative_g_score <= g_scores.get(neighbor, float('inf')):",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score <= g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if tentative_g_score < g_scores.get(neighbor, float('inf')):",
      "mutated_line": "if tentative_g_score >= g_scores.get(neighbor, float('inf')):",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if tentative_g_score < g_scores.get(neighbor, float('inf')):",
      "mutated_line": "if tentative_g_score != g_scores.get(neighbor, float('inf')):",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score != g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx = abs(position[0] - goal[0])",
      "mutated_line": "dx = abs(position[1] - goal[0])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[1] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx = abs(position[0] - goal[0])",
      "mutated_line": "dx = abs(position[-1] - goal[0])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[-1] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx = abs(position[0] - goal[0])",
      "mutated_line": "dx = abs(position[1] - goal[0])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[1] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx = abs(position[0] - goal[0])",
      "mutated_line": "dx = abs(position[0] - goal[1])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[1])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx = abs(position[0] - goal[0])",
      "mutated_line": "dx = abs(position[0] - goal[-1])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[-1])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dx = abs(position[0] - goal[0])",
      "mutated_line": "dx = abs(position[0] - goal[1])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[1])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dy = abs(position[1] - goal[1])",
      "mutated_line": "dy = abs(position[2] - goal[1])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[2] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dy = abs(position[1] - goal[1])",
      "mutated_line": "dy = abs(position[0] - goal[1])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[0] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dy = abs(position[1] - goal[1])",
      "mutated_line": "dy = abs(position[0] - goal[1])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[0] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dy = abs(position[1] - goal[1])",
      "mutated_line": "dy = abs(position[-1] - goal[1])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[-1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dy = abs(position[1] - goal[1])",
      "mutated_line": "dy = abs(position[1] - goal[2])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[2])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dy = abs(position[1] - goal[1])",
      "mutated_line": "dy = abs(position[1] - goal[0])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[0])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dy = abs(position[1] - goal[1])",
      "mutated_line": "dy = abs(position[1] - goal[0])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[0])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dy = abs(position[1] - goal[1])",
      "mutated_line": "dy = abs(position[1] - goal[-1])",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[-1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 / MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 / MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - (2 + MOVE_COST_STRAIGHT)) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - (2 + MOVE_COST_STRAIGHT)) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 ** MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 ** MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(1, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(1, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(-1, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(1, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(1, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, +1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, +1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (1, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (1, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (-1, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (-1, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (1, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (1, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 2), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 2), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, -1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, -1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (+1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (+1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 1), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 1), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, -1), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, -1), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 1), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 1), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (2, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (2, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (0, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (0, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (0, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (0, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (-1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (-1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, -1), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, -1), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (+1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (+1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, +1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, +1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (2, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (2, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (0, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (0, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (0, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (0, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, +1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, +1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (+1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (+1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 2), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 2), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 0), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 0), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 0), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 0), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, -1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, -1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (2, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (2, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (0, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (0, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (0, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (0, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (-1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (-1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 2)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 2)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 0)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 0)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 0)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, -1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, -1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "neighbor = (current[0] + dx, current[1] + dy)",
      "mutated_line": "neighbor = (current[0] - dx, current[1] + dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] - dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "neighbor = (current[0] + dx, current[1] + dy)",
      "mutated_line": "neighbor = (current[0] * dx, current[1] + dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] * dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "neighbor = (current[0] + dx, current[1] + dy)",
      "mutated_line": "neighbor = (current[0] + dx, current[1] - dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] - dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "neighbor = (current[0] + dx, current[1] + dy)",
      "mutated_line": "neighbor = (current[0] + dx, current[1] * dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] * dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):",
      "mutated_line": "if neighbor not in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor not in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):",
      "mutated_line": "if neighbor in closed_set and tentative_g_score > g_scores.get(neighbor, float('inf')):",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score > g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):",
      "mutated_line": "if neighbor in closed_set and tentative_g_score < g_scores.get(neighbor, float('inf')):",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score < g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):",
      "mutated_line": "if neighbor in closed_set and tentative_g_score == g_scores.get(neighbor, float('inf')):",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score == g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)",
      "mutated_line": "f_scores[neighbor] = tentative_g_score - heuristic(neighbor, goal)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score - heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)",
      "mutated_line": "f_scores[neighbor] = tentative_g_score * heuristic(neighbor, goal)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score * heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 3 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 3 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 1 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 1 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 0 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 0 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 1 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 1 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "mutated_line": "return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - -2 * MOVE_COST_STRAIGHT) * min(dx, dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - -2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -2), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -2), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -0), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -0), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -0), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -0), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, --1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, --1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-2, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-2, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-0, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-0, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-0, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-0, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (--1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (--1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-2, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-2, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-0, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-0, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-0, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-0, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (--1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (--1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -2), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -2), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -0), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -0), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -0), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -0), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, --1), (1, -1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, --1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -2), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -2), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -0), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -0), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -0), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -0), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, --1), (-1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, --1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-2, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-2, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-0, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-0, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-0, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-0, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (--1, 1), (1, 1)]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (--1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) or 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) or 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)",
      "mutated_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 and dy == 0 else MOVE_COST_DIAGONAL)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 and dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "neighbor = (current[0] + dx, current[1] + dy)",
      "mutated_line": "neighbor = (current[1] + dx, current[1] + dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[1] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "neighbor = (current[0] + dx, current[1] + dy)",
      "mutated_line": "neighbor = (current[-1] + dx, current[1] + dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[-1] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "neighbor = (current[0] + dx, current[1] + dy)",
      "mutated_line": "neighbor = (current[1] + dx, current[1] + dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[1] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "neighbor = (current[0] + dx, current[1] + dy)",
      "mutated_line": "neighbor = (current[0] + dx, current[2] + dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[2] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "neighbor = (current[0] + dx, current[1] + dy)",
      "mutated_line": "neighbor = (current[0] + dx, current[0] + dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[0] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "neighbor = (current[0] + dx, current[1] + dy)",
      "mutated_line": "neighbor = (current[0] + dx, current[0] + dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[0] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "neighbor = (current[0] + dx, current[1] + dy)",
      "mutated_line": "neighbor = (current[0] + dx, current[-1] + dy)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[-1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 < neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 < neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 > neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 > neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 == neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 == neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 < neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 < neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 > neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 > neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 == neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 == neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[2]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[2]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[0]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[0]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[0]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[0]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[-1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[-1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)",
      "mutated_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx != 0 or dy == 0 else MOVE_COST_DIAGONAL)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx != 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)",
      "mutated_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy != 0 else MOVE_COST_DIAGONAL)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy != 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if tentative_g_score < g_scores.get(neighbor, float('inf')):",
      "mutated_line": "if tentative_g_score < g_scores.get(neighbor, float('')):",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (1 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (1 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (-1 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (-1 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (1 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (1 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 1 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 1 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and -1 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and -1 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 1 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 1 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[1]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[1]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[-1]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[-1]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[1]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[1]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)",
      "mutated_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 1 or dy == 0 else MOVE_COST_DIAGONAL)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 1 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)",
      "mutated_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == -1 or dy == 0 else MOVE_COST_DIAGONAL)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == -1 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)",
      "mutated_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 1 or dy == 0 else MOVE_COST_DIAGONAL)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 1 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)",
      "mutated_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 1 else MOVE_COST_DIAGONAL)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 1 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)",
      "mutated_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == -1 else MOVE_COST_DIAGONAL)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == -1 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)",
      "mutated_line": "tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 1 else MOVE_COST_DIAGONAL)",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 1 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):",
      "mutated_line": "if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('')):",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[1] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[1] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[-1] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[-1] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[1] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[1] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[2] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[2] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[0] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[0] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[0] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[0] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[-1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[-1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[1])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[1])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[-1])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[-1])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[0])) or grid_map[neighbor[0]][neighbor[1]]:",
      "mutated_line": "if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[1])) or grid_map[neighbor[0]][neighbor[1]]:",
      "code": "import heapq\nMOVE_COST_STRAIGHT = 10\nMOVE_COST_DIAGONAL = 14\n\ndef heuristic(position, goal):\n    dx = abs(position[0] - goal[0])\n    dy = abs(position[1] - goal[1])\n    return MOVE_COST_STRAIGHT * (dx + dy) + (MOVE_COST_DIAGONAL - 2 * MOVE_COST_STRAIGHT) * min(dx, dy)\n\ndef astar(start, goal, grid_map):\n    open_set = []\n    closed_set = set()\n    heapq.heappush(open_set, (0, start))\n    g_scores = {start: 0}\n    f_scores = {start: heuristic(start, goal)}\n    came_from = {start: None}\n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.reverse()\n            return path\n        closed_set.add(current)\n        for (dx, dy) in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)]:\n            neighbor = (current[0] + dx, current[1] + dy)\n            if not (0 <= neighbor[0] < len(grid_map) and 0 <= neighbor[1] < len(grid_map[1])) or grid_map[neighbor[0]][neighbor[1]]:\n                continue\n            tentative_g_score = g_scores[current] + (MOVE_COST_STRAIGHT if dx == 0 or dy == 0 else MOVE_COST_DIAGONAL)\n            if neighbor in closed_set and tentative_g_score >= g_scores.get(neighbor, float('inf')):\n                continue\n            if tentative_g_score < g_scores.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_scores[neighbor] = tentative_g_score\n                f_scores[neighbor] = tentative_g_score + heuristic(neighbor, goal)\n                heapq.heappush(open_set, (f_scores[neighbor], neighbor))\n    return None"
    }
  ]
}