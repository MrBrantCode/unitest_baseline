{
  "task_id": "cf_26169",
  "entry_point": "closest_string_match",
  "mutant_count": 43,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "min_string = \"\"",
      "mutated_line": "min_string = 'MUTATED'",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = 'MUTATED'\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(s1) > len(s2):",
      "mutated_line": "if len(s1) >= len(s2):",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) >= len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(s1) > len(s2):",
      "mutated_line": "if len(s1) <= len(s2):",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) <= len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if len(s1) > len(s2):",
      "mutated_line": "if len(s1) != len(s2):",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) != len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "min_distance = float(\"inf\")",
      "mutated_line": "min_string = ''",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if distance < min_distance:",
      "mutated_line": "if distance <= min_distance:",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance <= min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if distance < min_distance:",
      "mutated_line": "if distance >= min_distance:",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance >= min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if distance < min_distance:",
      "mutated_line": "if distance != min_distance:",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance != min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distances = range(len(s1) + 1)",
      "mutated_line": "for (i2, c2) in enumerate(s2):",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) - 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "distances = range(len(s1) + 1)",
      "mutated_line": "for (i2, c2) in enumerate(s2):",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) * 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "return distances[-1]",
      "mutated_line": "return distances[+1]",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[+1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances = range(len(s1) + 1)",
      "mutated_line": "for (i2, c2) in enumerate(s2):",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 2)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances = range(len(s1) + 1)",
      "mutated_line": "for (i2, c2) in enumerate(s2):",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 0)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances = range(len(s1) + 1)",
      "mutated_line": "for (i2, c2) in enumerate(s2):",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 0)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "distances = range(len(s1) + 1)",
      "mutated_line": "for (i2, c2) in enumerate(s2):",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + -1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distances_ = [i2+1]",
      "mutated_line": "distances_ = [i2 - 1]",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 - 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distances_ = [i2+1]",
      "mutated_line": "distances_ = [i2 * 1]",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 * 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if c1 == c2:",
      "mutated_line": "if c1 != c2:",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 != c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return distances[-1]",
      "mutated_line": "return distances[-2]",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-2]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return distances[-1]",
      "mutated_line": "return distances[-0]",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-0]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return distances[-1]",
      "mutated_line": "return distances[-0]",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-0]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return distances[-1]",
      "mutated_line": "return distances[--1]",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[--1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distances_ = [i2+1]",
      "mutated_line": "distances_ = [i2 + 2]",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 2]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distances_ = [i2+1]",
      "mutated_line": "distances_ = [i2 + 0]",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 0]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distances_ = [i2+1]",
      "mutated_line": "distances_ = [i2 + 0]",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 0]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distances_ = [i2+1]",
      "mutated_line": "distances_ = [i2 + -1]",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + -1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(1 - min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 - min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(1 * min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 * min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(2 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(2 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(0 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(0 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(0 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(0 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(-1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(-1 + min((distances[i1], distances[i1 + 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(1 + min((distances[i1], distances[i1 - 1], distances_[-1])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 - 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(1 + min((distances[i1], distances[i1 * 1], distances_[-1])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 * 1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[+1])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[+1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(1 + min((distances[i1], distances[i1 + 2], distances_[-1])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 2], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(1 + min((distances[i1], distances[i1 + 0], distances_[-1])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 0], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(1 + min((distances[i1], distances[i1 + 0], distances_[-1])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 0], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(1 + min((distances[i1], distances[i1 + -1], distances_[-1])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + -1], distances_[-1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-2])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-2])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-0])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-0])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-0])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[-0])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "1 + min((distances[i1], distances[i1 + 1], distances_[-1])))",
      "mutated_line": "distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[--1])))",
      "code": "def closest_string_match(string, strings):\n\n    def levenshtein_distance(s1, s2):\n        if len(s1) > len(s2):\n            (s1, s2) = (s2, s1)\n        distances = range(len(s1) + 1)\n        for (i2, c2) in enumerate(s2):\n            distances_ = [i2 + 1]\n            for (i1, c1) in enumerate(s1):\n                if c1 == c2:\n                    distances_.append(distances[i1])\n                else:\n                    distances_.append(1 + min((distances[i1], distances[i1 + 1], distances_[--1])))\n            distances = distances_\n        return distances[-1]\n    min_distance = float('inf')\n    min_string = ''\n    for s in strings:\n        distance = levenshtein_distance(string, s)\n        if distance < min_distance:\n            min_distance = distance\n            min_string = s\n    return min_string"
    }
  ]
}