{
  "task_id": "cf_74026",
  "entry_point": "validate_string",
  "mutant_count": 29,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def validate_string(s):\n    \"\"\"\"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "return len(stack) == 0",
      "mutated_line": "return len(stack) != 0",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) != 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "openers = {'(', '[', '{'}",
      "mutated_line": "openers = {'', '[', '{'}",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "openers = {'(', '[', '{'}",
      "mutated_line": "openers = {'(', '', '{'}",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "openers = {'(', '[', '{'}",
      "mutated_line": "openers = {'(', '[', ''}",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', ''}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closers = {')': '(', ']': '[', '}': '{'}",
      "mutated_line": "closers = {'': '(', ']': '[', '}': '{'}",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {'': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closers = {')': '(', ']': '[', '}': '{'}",
      "mutated_line": "closers = {')': '(', '': '[', '}': '{'}",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', '': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closers = {')': '(', ']': '[', '}': '{'}",
      "mutated_line": "closers = {')': '(', ']': '[', '': '{'}",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closers = {')': '(', ']': '[', '}': '{'}",
      "mutated_line": "closers = {')': '', ']': '[', '}': '{'}",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closers = {')': '(', ']': '[', '}': '{'}",
      "mutated_line": "closers = {')': '(', ']': '', '}': '{'}",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "closers = {')': '(', ']': '[', '}': '{'}",
      "mutated_line": "closers = {')': '(', ']': '[', '}': ''}",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': ''}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return len(stack) == 0",
      "mutated_line": "return len(stack) == 1",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return len(stack) == 0",
      "mutated_line": "return len(stack) == -1",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return len(stack) == 0",
      "mutated_line": "return len(stack) == 1",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if c in alpha_counts:",
      "mutated_line": "if c not in alpha_counts:",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c not in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif c in openers:",
      "mutated_line": "elif c not in openers:",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c not in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return True\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "alpha_counts[c] = 1",
      "mutated_line": "alpha_counts[c] = 2",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 2\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "alpha_counts[c] = 1",
      "mutated_line": "alpha_counts[c] = 0",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 0\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "alpha_counts[c] = 1",
      "mutated_line": "alpha_counts[c] = 0",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 0\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "alpha_counts[c] = 1",
      "mutated_line": "alpha_counts[c] = -1",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = -1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif c in closers:",
      "mutated_line": "elif c not in closers:",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c not in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if len(stack) == 0 or stack.pop() != closers[c]:",
      "mutated_line": "if len(stack) == 0 and stack.pop() != closers[c]:",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 and stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(stack) == 0 or stack.pop() != closers[c]:",
      "mutated_line": "if len(stack) != 0 or stack.pop() != closers[c]:",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) != 0 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(stack) == 0 or stack.pop() != closers[c]:",
      "mutated_line": "if len(stack) == 0 or stack.pop() == closers[c]:",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() == closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 0 or stack.pop() != closers[c]:\n                return True\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(stack) == 0 or stack.pop() != closers[c]:",
      "mutated_line": "if len(stack) == 1 or stack.pop() != closers[c]:",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 1 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(stack) == 0 or stack.pop() != closers[c]:",
      "mutated_line": "if len(stack) == -1 or stack.pop() != closers[c]:",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == -1 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(stack) == 0 or stack.pop() != closers[c]:",
      "mutated_line": "if len(stack) == 1 or stack.pop() != closers[c]:",
      "code": "def validate_string(s):\n    \"\"\"\n    Returns True if and only if all the alphabetic characters within s are unique \n    and the string has balanced parentheses, where only '()', '[]', and '{}' are \n    considered valid pairs.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: Whether the string has unique alphabetic characters and balanced parentheses.\n    \"\"\"\n    alpha_counts = {}\n    stack = []\n    openers = {'(', '[', '{'}\n    closers = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c.isalpha():\n            if c in alpha_counts:\n                return False\n            else:\n                alpha_counts[c] = 1\n        elif c in openers:\n            stack.append(c)\n        elif c in closers:\n            if len(stack) == 1 or stack.pop() != closers[c]:\n                return False\n    return len(stack) == 0"
    }
  ]
}