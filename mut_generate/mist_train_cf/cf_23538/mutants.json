{
  "task_id": "cf_23538",
  "entry_point": "shortest_path",
  "mutant_count": 114,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights[start[0]][start[1]] = 0",
      "mutated_line": "weights[start[0]][start[1]] = 1",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 1\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights[start[0]][start[1]] = 0",
      "mutated_line": "weights[start[0]][start[1]] = -1",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = -1\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights[start[0]][start[1]] = 0",
      "mutated_line": "weights[start[0]][start[1]] = 1",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 1\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]",
      "mutated_line": "weights = [[float('inf')] / len(grid[0]) for _ in range(len(grid))]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] / len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]",
      "mutated_line": "weights = [[float('inf')] + len(grid[0]) for _ in range(len(grid))]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] + len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]",
      "mutated_line": "weights = [[float('inf')] ** len(grid[0]) for _ in range(len(grid))]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] ** len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights[start[0]][start[1]] = 0",
      "mutated_line": "weights[start[0]][start[2]] = 0",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[2]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights[start[0]][start[1]] = 0",
      "mutated_line": "weights[start[0]][start[0]] = 0",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[0]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights[start[0]][start[1]] = 0",
      "mutated_line": "weights[start[0]][start[0]] = 0",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[0]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights[start[0]][start[1]] = 0",
      "mutated_line": "weights[start[0]][start[-1]] = 0",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[-1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(2, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(2, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(-1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 1), (-1, 0), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 1), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, -1), (-1, 0), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, -1), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 1), (-1, 0), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 1), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (+1, 0), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (+1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 1), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 1), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, -1), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, -1), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 1), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 1), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (1, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (1, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (-1, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (-1, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (1, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (1, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 2), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 2), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 0), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 0), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 0), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 0), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, -1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, -1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (1, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (1, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (-1, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (-1, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (1, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (1, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, +1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, +1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "curr = q.pop(0)",
      "mutated_line": "curr = q.pop(1)",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(1)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "curr = q.pop(0)",
      "mutated_line": "curr = q.pop(-1)",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(-1)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "curr = q.pop(0)",
      "mutated_line": "curr = q.pop(1)",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(1)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "row = curr[0] + direction[0]",
      "mutated_line": "row = curr[0] - direction[0]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] - direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "row = curr[0] + direction[0]",
      "mutated_line": "row = curr[0] * direction[0]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] * direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "col = curr[1] + direction[1]",
      "mutated_line": "col = curr[1] - direction[1]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] - direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "col = curr[1] + direction[1]",
      "mutated_line": "col = curr[1] * direction[1]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] * direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 0 <= row < len(grid) or 0 <= col < len(grid[0]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) or 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return weights[end[0]][end[1]]",
      "mutated_line": "return weights[end[0]][end[2]]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[2]]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return weights[end[0]][end[1]]",
      "mutated_line": "return weights[end[0]][end[0]]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[0]]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return weights[end[0]][end[1]]",
      "mutated_line": "return weights[end[0]][end[0]]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[0]]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return weights[end[0]][end[1]]",
      "mutated_line": "return weights[end[0]][end[-1]]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[-1]]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights[start[0]][start[1]] = 0",
      "mutated_line": "weights[start[1]][start[1]] = 0",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[1]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights[start[0]][start[1]] = 0",
      "mutated_line": "weights[start[-1]][start[1]] = 0",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[-1]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights[start[0]][start[1]] = 0",
      "mutated_line": "weights[start[1]][start[1]] = 0",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[1]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-2, 0), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-2, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-0, 0), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-0, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-0, 0), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-0, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (--1, 0), (0, 1), (0, -1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (--1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -2)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -2)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -0)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -0)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -0)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -0)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "directions = [(1, 0), (-1, 0), (0, 1), (0, --1)]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, --1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "curr_dist = weights[curr[0]][curr[1]]",
      "mutated_line": "curr_dist = weights[curr[0]][curr[2]]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[2]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "curr_dist = weights[curr[0]][curr[1]]",
      "mutated_line": "curr_dist = weights[curr[0]][curr[0]]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[0]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "curr_dist = weights[curr[0]][curr[1]]",
      "mutated_line": "curr_dist = weights[curr[0]][curr[0]]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[0]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "curr_dist = weights[curr[0]][curr[1]]",
      "mutated_line": "curr_dist = weights[curr[0]][curr[-1]]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[-1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 0 < row < len(grid) and 0 <= col < len(grid[0]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 < row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 0 > row < len(grid) and 0 <= col < len(grid[0]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 > row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 0 == row < len(grid) and 0 <= col < len(grid[0]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 == row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 0 <= row < len(grid) and 0 < col < len(grid[0]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 < col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 0 <= row < len(grid) and 0 > col < len(grid[0]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 > col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 0 <= row < len(grid) and 0 == col < len(grid[0]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 == col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if weights[row][col] > curr_dist + 1:",
      "mutated_line": "if weights[row][col] >= curr_dist + 1:",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] >= curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if weights[row][col] > curr_dist + 1:",
      "mutated_line": "if weights[row][col] <= curr_dist + 1:",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] <= curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if weights[row][col] > curr_dist + 1:",
      "mutated_line": "if weights[row][col] != curr_dist + 1:",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] != curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return weights[end[0]][end[1]]",
      "mutated_line": "return weights[end[1]][end[1]]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[1]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return weights[end[0]][end[1]]",
      "mutated_line": "return weights[end[-1]][end[1]]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[-1]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return weights[end[0]][end[1]]",
      "mutated_line": "return weights[end[1]][end[1]]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[1]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]",
      "mutated_line": "weights = [[float('')] * len(grid[0]) for _ in range(len(grid))]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]",
      "mutated_line": "weights = [[float('inf')] * len(grid[1]) for _ in range(len(grid))]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[1]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]",
      "mutated_line": "weights = [[float('inf')] * len(grid[-1]) for _ in range(len(grid))]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[-1]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]",
      "mutated_line": "weights = [[float('inf')] * len(grid[1]) for _ in range(len(grid))]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[1]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "curr_dist = weights[curr[0]][curr[1]]",
      "mutated_line": "curr_dist = weights[curr[1]][curr[1]]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[1]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "curr_dist = weights[curr[0]][curr[1]]",
      "mutated_line": "curr_dist = weights[curr[-1]][curr[1]]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[-1]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "curr_dist = weights[curr[0]][curr[1]]",
      "mutated_line": "curr_dist = weights[curr[1]][curr[1]]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[1]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "row = curr[0] + direction[0]",
      "mutated_line": "row = curr[1] + direction[0]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[1] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "row = curr[0] + direction[0]",
      "mutated_line": "row = curr[-1] + direction[0]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[-1] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "row = curr[0] + direction[0]",
      "mutated_line": "row = curr[1] + direction[0]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[1] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "row = curr[0] + direction[0]",
      "mutated_line": "row = curr[0] + direction[1]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[1]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "row = curr[0] + direction[0]",
      "mutated_line": "row = curr[0] + direction[-1]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[-1]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "row = curr[0] + direction[0]",
      "mutated_line": "row = curr[0] + direction[1]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[1]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "col = curr[1] + direction[1]",
      "mutated_line": "col = curr[2] + direction[1]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[2] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "col = curr[1] + direction[1]",
      "mutated_line": "col = curr[0] + direction[1]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[0] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "col = curr[1] + direction[1]",
      "mutated_line": "col = curr[0] + direction[1]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[0] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "col = curr[1] + direction[1]",
      "mutated_line": "col = curr[-1] + direction[1]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[-1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "col = curr[1] + direction[1]",
      "mutated_line": "col = curr[1] + direction[2]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[2]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "col = curr[1] + direction[1]",
      "mutated_line": "col = curr[1] + direction[0]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[0]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "col = curr[1] + direction[1]",
      "mutated_line": "col = curr[1] + direction[0]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[0]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "col = curr[1] + direction[1]",
      "mutated_line": "col = curr[1] + direction[-1]",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[-1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 1 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 1 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if -1 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if -1 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 1 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 1 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 0 <= row < len(grid) and 1 <= col < len(grid[0]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 1 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 0 <= row < len(grid) and -1 <= col < len(grid[0]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and -1 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 0 <= row < len(grid) and 1 <= col < len(grid[0]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 1 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if weights[row][col] > curr_dist + 1:",
      "mutated_line": "if weights[row][col] > curr_dist - 1:",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist - 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if weights[row][col] > curr_dist + 1:",
      "mutated_line": "if weights[row][col] > curr_dist * 1:",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist * 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "weights[row][col] = curr_dist + 1",
      "mutated_line": "weights[row][col] = curr_dist - 1",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist - 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "weights[row][col] = curr_dist + 1",
      "mutated_line": "weights[row][col] = curr_dist * 1",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist * 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if weights[row][col] > curr_dist + 1:",
      "mutated_line": "if weights[row][col] > curr_dist + 2:",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 2:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if weights[row][col] > curr_dist + 1:",
      "mutated_line": "if weights[row][col] > curr_dist + 0:",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 0:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if weights[row][col] > curr_dist + 1:",
      "mutated_line": "if weights[row][col] > curr_dist + 0:",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 0:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if weights[row][col] > curr_dist + 1:",
      "mutated_line": "if weights[row][col] > curr_dist + -1:",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + -1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "weights[row][col] = curr_dist + 1",
      "mutated_line": "weights[row][col] = curr_dist + 2",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 2\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "weights[row][col] = curr_dist + 1",
      "mutated_line": "weights[row][col] = curr_dist + 0",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 0\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "weights[row][col] = curr_dist + 1",
      "mutated_line": "weights[row][col] = curr_dist + 0",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 0\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "weights[row][col] = curr_dist + 1",
      "mutated_line": "weights[row][col] = curr_dist + -1",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[0]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + -1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[1]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[1]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[-1]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[-1]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[0]):",
      "mutated_line": "if 0 <= row < len(grid) and 0 <= col < len(grid[1]):",
      "code": "def shortest_path(grid, start, end):\n    \"\"\"\n    This function calculates the shortest path distance from the start point to the end point using Dijkstra's algorithm.\n\n    Args:\n    grid (2D array): A 2D array representing the grid where each cell represents a node.\n    start (tuple): The starting point coordinates.\n    end (tuple): The ending point coordinates.\n\n    Returns:\n    int: The shortest path distance from the start point to the end point.\n    \"\"\"\n    weights = [[float('inf')] * len(grid[0]) for _ in range(len(grid))]\n    weights[start[0]][start[1]] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    q = [start]\n    while q:\n        curr = q.pop(0)\n        curr_dist = weights[curr[0]][curr[1]]\n        for direction in directions:\n            row = curr[0] + direction[0]\n            col = curr[1] + direction[1]\n            if 0 <= row < len(grid) and 0 <= col < len(grid[1]):\n                if weights[row][col] > curr_dist + 1:\n                    weights[row][col] = curr_dist + 1\n                    q.append((row, col))\n    return weights[end[0]][end[1]]"
    }
  ]
}