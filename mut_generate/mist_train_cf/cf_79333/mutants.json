{
  "task_id": "cf_79333",
  "entry_point": "countRestrictedPaths",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 - 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 * 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 * 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 + 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 8\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 6\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 0\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 1\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + -7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "distance = [float('inf')] * (n+1)",
      "mutated_line": "distance = [float('inf')] / (n + 1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] / (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "distance = [float('inf')] * (n+1)",
      "mutated_line": "distance = [float('inf')] + (n + 1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] + (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "distance = [float('inf')] * (n+1)",
      "mutated_line": "distance = [float('inf')] ** (n + 1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] ** (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance[n] = 0",
      "mutated_line": "distance[n] = 1",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 1\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance[n] = 0",
      "mutated_line": "distance[n] = -1",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = -1\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance[n] = 0",
      "mutated_line": "distance[n] = 1",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 1\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] / (n + 1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] / (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] + (n + 1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] + (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] ** (n + 1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] ** (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[n] = 1",
      "mutated_line": "dp[n] = 2",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 2\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[n] = 1",
      "mutated_line": "dp[n] = 0",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 0\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[n] = 1",
      "mutated_line": "dp[n] = 0",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 0\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[n] = 1",
      "mutated_line": "dp[n] = -1",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = -1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 11 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 9 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 0 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 1 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = -10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 10 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 8 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 0 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 1 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** -9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "distance = [float('inf')] * (n+1)",
      "mutated_line": "distance = [float('inf')] * (n - 1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n - 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "distance = [float('inf')] * (n+1)",
      "mutated_line": "distance = [float('inf')] * (n * 1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n * 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if d != distance[node]:",
      "mutated_line": "if d == distance[node]:",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d == distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n - 1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n - 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n * 1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n * 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[1]",
      "mutated_line": "return dp[2]",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[2]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[1]",
      "mutated_line": "return dp[0]",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[1]",
      "mutated_line": "return dp[0]",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[1]",
      "mutated_line": "return dp[-1]",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "distance = [float('inf')] * (n+1)",
      "mutated_line": "distance = [float('inf')] * (n + 2)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 2)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "distance = [float('inf')] * (n+1)",
      "mutated_line": "distance = [float('inf')] * (n + 0)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 0)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "distance = [float('inf')] * (n+1)",
      "mutated_line": "distance = [float('inf')] * (n + 0)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 0)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "distance = [float('inf')] * (n+1)",
      "mutated_line": "distance = [float('inf')] * (n + -1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + -1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heap = [(0, n)]",
      "mutated_line": "heap = [(1, n)]",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(1, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heap = [(0, n)]",
      "mutated_line": "heap = [(-1, n)]",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(-1, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heap = [(0, n)]",
      "mutated_line": "heap = [(1, n)]",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(1, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if distance[node] + w < distance[neighbor]:",
      "mutated_line": "if distance[node] + w <= distance[neighbor]:",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w <= distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if distance[node] + w < distance[neighbor]:",
      "mutated_line": "if distance[node] + w >= distance[neighbor]:",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w >= distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if distance[node] + w < distance[neighbor]:",
      "mutated_line": "if distance[node] + w != distance[neighbor]:",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w != distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [1] * (n + 1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [1] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [-1] * (n + 1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [-1] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [1] * (n + 1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [1] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 2)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 2)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 0)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 0)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 0)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 0)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + -1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + -1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for node in sorted(range(1, n+1), key=lambda i: -distance[i]):",
      "mutated_line": "for node in sorted(range(2, n + 1), key=lambda i: -distance[i]):",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(2, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for node in sorted(range(1, n+1), key=lambda i: -distance[i]):",
      "mutated_line": "for node in sorted(range(0, n + 1), key=lambda i: -distance[i]):",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(0, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for node in sorted(range(1, n+1), key=lambda i: -distance[i]):",
      "mutated_line": "for node in sorted(range(0, n + 1), key=lambda i: -distance[i]):",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(0, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for node in sorted(range(1, n+1), key=lambda i: -distance[i]):",
      "mutated_line": "for node in sorted(range(-1, n + 1), key=lambda i: -distance[i]):",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(-1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for node in sorted(range(1, n+1), key=lambda i: -distance[i]):",
      "mutated_line": "for node in sorted(range(1, n - 1), key=lambda i: -distance[i]):",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n - 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for node in sorted(range(1, n+1), key=lambda i: -distance[i]):",
      "mutated_line": "for node in sorted(range(1, n * 1), key=lambda i: -distance[i]):",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n * 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:",
      "mutated_line": "if distance[node] > distance[neighbor] or (min(node, neighbor), max(node, neighbor)) not in forbidden:",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] or (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "dp[node] += dp[neighbor]",
      "mutated_line": "dp[node] -= dp[neighbor]",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] -= dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "distance = [float('inf')] * (n+1)",
      "mutated_line": "distance = [float('')] * (n + 1)",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if distance[node] + w < distance[neighbor]:",
      "mutated_line": "if distance[node] - w < distance[neighbor]:",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] - w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if distance[node] + w < distance[neighbor]:",
      "mutated_line": "if distance[node] * w < distance[neighbor]:",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] * w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "distance[neighbor] = distance[node] + w",
      "mutated_line": "distance[neighbor] = distance[node] - w",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] - w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "distance[neighbor] = distance[node] + w",
      "mutated_line": "distance[neighbor] = distance[node] * w",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] * w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for node in sorted(range(1, n+1), key=lambda i: -distance[i]):",
      "mutated_line": "for node in sorted(range(1, n + 2), key=lambda i: -distance[i]):",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 2), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for node in sorted(range(1, n+1), key=lambda i: -distance[i]):",
      "mutated_line": "for node in sorted(range(1, n + 0), key=lambda i: -distance[i]):",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 0), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for node in sorted(range(1, n+1), key=lambda i: -distance[i]):",
      "mutated_line": "for node in sorted(range(1, n + 0), key=lambda i: -distance[i]):",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 0), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for node in sorted(range(1, n+1), key=lambda i: -distance[i]):",
      "mutated_line": "for node in sorted(range(1, n + -1), key=lambda i: -distance[i]):",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + -1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "for node in sorted(range(1, n+1), key=lambda i: -distance[i]):",
      "mutated_line": "for node in sorted(range(1, n + 1), key=lambda i: +distance[i]):",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: +distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:",
      "mutated_line": "if distance[node] >= distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] >= distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:",
      "mutated_line": "if distance[node] <= distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] <= distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:",
      "mutated_line": "if distance[node] != distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] != distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) not in forbidden:",
      "mutated_line": "if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) in forbidden:",
      "code": "import heapq\nfrom collections import defaultdict\nMOD = 10 ** 9 + 7\n\ndef countRestrictedPaths(n, edges, forbiddenEdges):\n    graph = defaultdict(list)\n    forbidden = set([(min(u, v), max(u, v)) for (u, v) in forbiddenEdges])\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distance = [float('inf')] * (n + 1)\n    distance[n] = 0\n    heap = [(0, n)]\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        if d != distance[node]:\n            continue\n        for (neighbor, w) in graph[node]:\n            if distance[node] + w < distance[neighbor]:\n                distance[neighbor] = distance[node] + w\n                heapq.heappush(heap, (distance[neighbor], neighbor))\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    for node in sorted(range(1, n + 1), key=lambda i: -distance[i]):\n        for (neighbor, _) in graph[node]:\n            if distance[node] > distance[neighbor] and (min(node, neighbor), max(node, neighbor)) in forbidden:\n                dp[node] += dp[neighbor]\n                dp[node] %= MOD\n    return dp[1]"
    }
  ]
}