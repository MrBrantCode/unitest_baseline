{
  "task_id": "cf_95659",
  "entry_point": "find_combinations",
  "mutant_count": 41,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if current_sum == target and len(combination) > 1:",
      "mutated_line": "if current_sum == target or len(combination) > 1:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target or len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "backtrack(0, 0)",
      "mutated_line": "backtrack(1, 0)",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(1, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "backtrack(0, 0)",
      "mutated_line": "backtrack(-1, 0)",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(-1, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "backtrack(0, 0)",
      "mutated_line": "backtrack(1, 0)",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(1, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "backtrack(0, 0)",
      "mutated_line": "backtrack(0, 1)",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "backtrack(0, 0)",
      "mutated_line": "backtrack(0, -1)",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, -1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "backtrack(0, 0)",
      "mutated_line": "backtrack(0, 1)",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if current_sum == target and len(combination) > 1:",
      "mutated_line": "if current_sum != target and len(combination) > 1:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum != target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if current_sum == target and len(combination) > 1:",
      "mutated_line": "if current_sum == target and len(combination) >= 1:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) >= 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if current_sum == target and len(combination) > 1:",
      "mutated_line": "if current_sum == target and len(combination) <= 1:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) <= 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if current_sum == target and len(combination) > 1:",
      "mutated_line": "if current_sum == target and len(combination) != 1:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) != 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "elif current_sum > target or start >= len(nums):",
      "mutated_line": "elif current_sum > target and start >= len(nums):",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target and start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start or nums[i] == nums[i - 1]:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start or nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current_sum == target and len(combination) > 1:",
      "mutated_line": "if current_sum == target and len(combination) > 2:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 2:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current_sum == target and len(combination) > 1:",
      "mutated_line": "if current_sum == target and len(combination) > 0:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 0:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current_sum == target and len(combination) > 1:",
      "mutated_line": "if current_sum == target and len(combination) > 0:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 0:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current_sum == target and len(combination) > 1:",
      "mutated_line": "if current_sum == target and len(combination) > -1:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > -1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif current_sum > target or start >= len(nums):",
      "mutated_line": "elif current_sum >= target or start >= len(nums):",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum >= target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif current_sum > target or start >= len(nums):",
      "mutated_line": "elif current_sum <= target or start >= len(nums):",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum <= target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif current_sum > target or start >= len(nums):",
      "mutated_line": "elif current_sum != target or start >= len(nums):",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum != target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif current_sum > target or start >= len(nums):",
      "mutated_line": "elif current_sum > target or start > len(nums):",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start > len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif current_sum > target or start >= len(nums):",
      "mutated_line": "elif current_sum > target or start < len(nums):",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start < len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif current_sum > target or start >= len(nums):",
      "mutated_line": "elif current_sum > target or start == len(nums):",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start == len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i >= start and nums[i] == nums[i - 1]:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i >= start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i <= start and nums[i] == nums[i - 1]:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i <= start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i != start and nums[i] == nums[i - 1]:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i != start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start and nums[i] != nums[i - 1]:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] != nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "backtrack(i + 1, current_sum + nums[i])",
      "mutated_line": "backtrack(i - 1, current_sum + nums[i])",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i - 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "backtrack(i + 1, current_sum + nums[i])",
      "mutated_line": "backtrack(i * 1, current_sum + nums[i])",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i * 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "backtrack(i + 1, current_sum + nums[i])",
      "mutated_line": "backtrack(i + 1, current_sum - nums[i])",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum - nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "backtrack(i + 1, current_sum + nums[i])",
      "mutated_line": "backtrack(i + 1, current_sum * nums[i])",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum * nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "backtrack(i + 1, current_sum + nums[i])",
      "mutated_line": "backtrack(i + 2, current_sum + nums[i])",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 2, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "backtrack(i + 1, current_sum + nums[i])",
      "mutated_line": "backtrack(i + 0, current_sum + nums[i])",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 0, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "backtrack(i + 1, current_sum + nums[i])",
      "mutated_line": "backtrack(i + 0, current_sum + nums[i])",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 0, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "backtrack(i + 1, current_sum + nums[i])",
      "mutated_line": "backtrack(i + -1, current_sum + nums[i])",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + -1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start and nums[i] == nums[i + 1]:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i + 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start and nums[i] == nums[i * 1]:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i * 1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start and nums[i] == nums[i - 2]:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 2]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start and nums[i] == nums[i - 0]:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 0]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start and nums[i] == nums[i - 0]:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 0]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if i > start and nums[i] == nums[i-1]:",
      "mutated_line": "if i > start and nums[i] == nums[i - -1]:",
      "code": "def find_combinations(nums, target):\n    results = []\n    combination = []\n    nums.sort()\n\n    def backtrack(start, current_sum):\n        if current_sum == target and len(combination) > 1:\n            results.append(combination[:])\n            return\n        elif current_sum > target or start >= len(nums):\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - -1]:\n                continue\n            combination.append(nums[i])\n            backtrack(i + 1, current_sum + nums[i])\n            combination.pop()\n    backtrack(0, 0)\n    return results"
    }
  ]
}