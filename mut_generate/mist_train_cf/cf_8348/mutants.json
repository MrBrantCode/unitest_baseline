{
  "task_id": "cf_8348",
  "entry_point": "get_combinations",
  "mutant_count": 196,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "\"\"\"Check if number is prime.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if n <= 1:",
      "mutated_line": "if n < 1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n < 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if n <= 1:",
      "mutated_line": "if n > 1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n > 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if n <= 1:",
      "mutated_line": "if n == 1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n == 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if n == 2:",
      "mutated_line": "if n != 2:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n != 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 != 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 != 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "max_divisor = int(sqrt(n)) + 1",
      "mutated_line": "max_divisor = int(sqrt(n)) - 1",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) - 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "max_divisor = int(sqrt(n)) + 1",
      "mutated_line": "max_divisor = int(sqrt(n)) * 1",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) * 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return False\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "\"\"\"Check if number is a power of two.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if n <= 0:",
      "mutated_line": "if n < 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n < 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if n <= 0:",
      "mutated_line": "if n > 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n > 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if n <= 0:",
      "mutated_line": "if n == 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n == 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "return (n & (n - 1)) == 0",
      "mutated_line": "return n & n - 1 != 0",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 != 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if n <= 1:",
      "mutated_line": "if n <= 2:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if n <= 1:",
      "mutated_line": "if n <= 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 0:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if n <= 1:",
      "mutated_line": "if n <= 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 0:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if n <= 1:",
      "mutated_line": "if n <= -1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= -1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 3:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 1:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 0:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 1:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if n == 2:",
      "mutated_line": "if n == -2:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == -2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n * 2 == 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n * 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n + 2 == 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n + 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == 1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 1:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == -1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == -1:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == 1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 1:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return True\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "max_divisor = int(sqrt(n)) + 1",
      "mutated_line": "max_divisor = int(sqrt(n)) + 2",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 2\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "max_divisor = int(sqrt(n)) + 1",
      "mutated_line": "max_divisor = int(sqrt(n)) + 0",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 0\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "max_divisor = int(sqrt(n)) + 1",
      "mutated_line": "max_divisor = int(sqrt(n)) + 0",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 0\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "max_divisor = int(sqrt(n)) + 1",
      "mutated_line": "max_divisor = int(sqrt(n)) + -1",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + -1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for d in range(3, max_divisor, 2):",
      "mutated_line": "for d in range(4, max_divisor, 2):",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(4, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for d in range(3, max_divisor, 2):",
      "mutated_line": "for d in range(2, max_divisor, 2):",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(2, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for d in range(3, max_divisor, 2):",
      "mutated_line": "for d in range(0, max_divisor, 2):",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(0, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for d in range(3, max_divisor, 2):",
      "mutated_line": "for d in range(1, max_divisor, 2):",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(1, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for d in range(3, max_divisor, 2):",
      "mutated_line": "for d in range(-3, max_divisor, 2):",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(-3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for d in range(3, max_divisor, 2):",
      "mutated_line": "for d in range(3, max_divisor, 3):",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 3):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for d in range(3, max_divisor, 2):",
      "mutated_line": "for d in range(3, max_divisor, 1):",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 1):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for d in range(3, max_divisor, 2):",
      "mutated_line": "for d in range(3, max_divisor, 0):",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 0):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for d in range(3, max_divisor, 2):",
      "mutated_line": "for d in range(3, max_divisor, 1):",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 1):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for d in range(3, max_divisor, 2):",
      "mutated_line": "for d in range(3, max_divisor, -2):",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, -2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if n % d == 0:",
      "mutated_line": "if n % d != 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d != 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if n <= 0:",
      "mutated_line": "if n <= 1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 1:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if n <= 0:",
      "mutated_line": "if n <= -1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= -1:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if n <= 0:",
      "mutated_line": "if n <= 1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 1:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return True\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return (n & (n - 1)) == 0",
      "mutated_line": "return n | n - 1 == 0",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n | n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (n & (n - 1)) == 0",
      "mutated_line": "return n & n - 1 == 1",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (n & (n - 1)) == 0",
      "mutated_line": "return n & n - 1 == -1",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == -1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (n & (n - 1)) == 0",
      "mutated_line": "return n & n - 1 == 1",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 1"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 or x > 10 or x < 50 or sqrt(x).is_integer() or is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 or x < 10000 or x % 2 == 0 or (x % 3 != 0) or (x % 100 == 0) or is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 or x < 10000 or x % 2 == 0 or (x % 3 != 0) or (x % 100 == 0) or is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 and y % 3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 and y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=False)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=False)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 3 == 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 3 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 1 == 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 1 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 0 == 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 0 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 1 == 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 1 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % -2 == 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % -2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if n % d == 0:",
      "mutated_line": "if n * d == 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n * d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if n % d == 0:",
      "mutated_line": "if n + d == 0:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n + d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if n % d == 0:",
      "mutated_line": "if n % d == 1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 1:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if n % d == 0:",
      "mutated_line": "if n % d == -1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == -1:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if n % d == 0:",
      "mutated_line": "if n % d == 1:",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 1:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return True\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return (n & (n - 1)) == 0",
      "mutated_line": "return n & n + 1 == 0",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n + 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return (n & (n - 1)) == 0",
      "mutated_line": "return n & n * 1 == 0",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n * 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 == 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x >= 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x <= 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x != 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x <= 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x >= 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x != 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 != 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 != 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x <= 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x <= 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x >= 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x >= 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x != 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x != 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 != 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 != 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 == 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 == 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 != 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 != 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 == 0 or y % 3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 == 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 == 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 == 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (n & (n - 1)) == 0",
      "mutated_line": "return n & n - 2 == 0",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 2 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (n & (n - 1)) == 0",
      "mutated_line": "return n & n - 0 == 0",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 0 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (n & (n - 1)) == 0",
      "mutated_line": "return n & n - 0 == 0",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 0 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (n & (n - 1)) == 0",
      "mutated_line": "return n & n - -1 == 0",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - -1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x * 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x + 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 1 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != -1 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 1 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 11 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 9 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 0 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 1 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > -10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 51) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 49) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 0) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 1) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < -50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x * 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x * 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x + 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x + 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 1 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 1 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == -1 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == -1 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 1 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 1 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10001 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10001 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 9999 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 9999 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 0 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 0 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 1 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 1 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < -10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < -10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x * 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x * 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x + 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x + 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 1) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 1) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == -1) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == -1) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 1) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 1) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x * 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x * 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x + 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x + 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 1) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 1) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != -1) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != -1) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 1) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 1) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x * 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x * 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x + 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x + 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 1) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 1) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == -1) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == -1) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 1) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 1) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x * 3 != 0 or y % 3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x * 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x + 3 != 0 or y % 3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x + 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != 1 or y % 3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 1 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != -1 or y % 3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != -1 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != 1 or y % 3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 1 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y * 3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y * 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y + 3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y + 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 1]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 1]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != -1]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != -1]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 1]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 1]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] / x[1], abs(x[0] - x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] / x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] + x[1], abs(x[0] - x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] + x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] ** x[1], abs(x[0] - x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] ** x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 3 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 1 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 0 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 1 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "list1 = [x for x in list1 if x % 2 != 0 and x > 10 and x < 50 and sqrt(x).is_integer() and is_prime(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % -2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 11 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 11 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 9 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 9 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 0 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 0 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 1 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 1 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % -10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % -10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 3 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 3 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 1 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 1 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 0 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 0 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 1 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 1 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % -2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % -2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 4 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 4 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 2 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 2 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 0 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 0 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 1 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 1 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % -3 != 0) and (x % 100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % -3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 101 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 101 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 99 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 99 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 0 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 0 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 1 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 1 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and x % 2 == 0 and x % 3 != 0 and x % 100 == 0 and is_power_of_two(x)]",
      "mutated_line": "list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % -100 == 0) and is_power_of_two(x)]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % -100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 4 != 0 or y % 3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 4 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 2 != 0 or y % 3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 2 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 0 != 0 or y % 3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 0 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 1 != 0 or y % 3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 1 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % -3 != 0 or y % 3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % -3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 4 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 4 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 2 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 2 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 0 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 0 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 1 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 1 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "combinations = [(x, y) for x, y in combinations if x % 3 != 0 or y % 3 != 0]",
      "mutated_line": "combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % -3 != 0]",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % -3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] + x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] + x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] * x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] * x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[1] * x[1], abs(x[0] - x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[1] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[-1] * x[1], abs(x[0] - x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[-1] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[1] * x[1], abs(x[0] - x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[1] * x[1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[2], abs(x[0] - x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[2], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[0], abs(x[0] - x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[0], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[0], abs(x[0] - x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[0], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[-1], abs(x[0] - x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[-1], abs(x[0] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[1] - x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[1] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[-1] - x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[-1] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[1] - x[1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[1] - x[1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[2])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[2])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[0])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[0])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[0])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[0])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[1])), reverse=True)",
      "mutated_line": "combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[-1])), reverse=True)",
      "code": "from itertools import product\nfrom math import sqrt\n\ndef get_combinations(list1, list2):\n    \"\"\"\n    Returns a list of tuples containing all possible combinations of two elements, \n    one from each list, with specific constraints.\n\n    Args:\n    list1 (list): A list of numbers.\n    list2 (list): A list of numbers.\n\n    Returns:\n    list: A list of tuples.\n    \"\"\"\n    list1 = [x for x in list1 if x % 2 != 0 and x > 10 and (x < 50) and sqrt(x).is_integer() and is_prime(x)]\n    list2 = [x for x in list2 if x % 10 == 0 and x < 10000 and (x % 2 == 0) and (x % 3 != 0) and (x % 100 == 0) and is_power_of_two(x)]\n    combinations = list(product(list1, list2))\n    combinations = [(x, y) for (x, y) in combinations if x % 3 != 0 or y % 3 != 0]\n    combinations = sorted(combinations, key=lambda x: (x[0] * x[1], abs(x[0] - x[-1])), reverse=True)\n    return combinations\n\ndef is_prime(n):\n    \"\"\"Check if number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(sqrt(n)) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef is_power_of_two(n):\n    \"\"\"Check if number is a power of two.\"\"\"\n    if n <= 0:\n        return False\n    return n & n - 1 == 0"
    }
  ]
}