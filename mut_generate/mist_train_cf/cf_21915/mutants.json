{
  "task_id": "cf_21915",
  "entry_point": "reverse_and_sum",
  "mutant_count": 87,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "reverse = 0",
      "mutated_line": "reverse = 1",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 1\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "reverse = 0",
      "mutated_line": "reverse = -1",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = -1\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "reverse = 0",
      "mutated_line": "reverse = 1",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 1\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "total_sum = 0",
      "mutated_line": "total_sum = 1",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 1\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "total_sum = 0",
      "mutated_line": "total_sum = -1",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = -1\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "total_sum = 0",
      "mutated_line": "total_sum = 1",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 1\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "is_negative = False",
      "mutated_line": "is_negative = True",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = True\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if num < 0:",
      "mutated_line": "if num <= 0:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num <= 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if num < 0:",
      "mutated_line": "if num >= 0:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num >= 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if num < 0:",
      "mutated_line": "if num != 0:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num != 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while num > 0:",
      "mutated_line": "while num >= 0:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num >= 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while num > 0:",
      "mutated_line": "while num <= 0:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num <= 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while num > 0:",
      "mutated_line": "while num != 0:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num != 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "total_sum += last_digit",
      "mutated_line": "total_sum -= last_digit",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum -= last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "LCR",
      "lineno": 39,
      "original_line": "if reverse > INT_MAX or reverse < INT_MIN:",
      "mutated_line": "if reverse > INT_MAX and reverse < INT_MIN:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX and reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 + 1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 + 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 * 1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 * 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 1, +2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, +2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if num < 0:",
      "mutated_line": "if num < 1:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 1:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if num < 0:",
      "mutated_line": "if num < -1:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < -1:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if num < 0:",
      "mutated_line": "if num < 1:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 1:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "is_negative = True",
      "mutated_line": "is_negative = False",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = False\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "num = -num",
      "mutated_line": "num = +num",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = +num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while num > 0:",
      "mutated_line": "while num > 1:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 1:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while num > 0:",
      "mutated_line": "while num > -1:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > -1:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while num > 0:",
      "mutated_line": "while num > 1:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 1:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "last_digit = num % 10",
      "mutated_line": "last_digit = num * 10",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num * 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "last_digit = num % 10",
      "mutated_line": "last_digit = num + 10",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num + 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "reverse = reverse * 10 + last_digit",
      "mutated_line": "reverse = reverse * 10 - last_digit",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 - last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "reverse = reverse * 10 + last_digit",
      "mutated_line": "reverse = reverse * 10 * last_digit",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 * last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "num //= 10",
      "mutated_line": "num //= 11",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 11\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "num //= 10",
      "mutated_line": "num //= 9",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 9\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "num //= 10",
      "mutated_line": "num //= 0",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 0\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "num //= 10",
      "mutated_line": "num //= 1",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 1\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "num //= 10",
      "mutated_line": "num //= -10",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= -10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "reverse = -reverse",
      "mutated_line": "reverse = +reverse",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = +reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if reverse > INT_MAX or reverse < INT_MIN:",
      "mutated_line": "if reverse >= INT_MAX or reverse < INT_MIN:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse >= INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if reverse > INT_MAX or reverse < INT_MIN:",
      "mutated_line": "if reverse <= INT_MAX or reverse < INT_MIN:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse <= INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if reverse > INT_MAX or reverse < INT_MIN:",
      "mutated_line": "if reverse != INT_MAX or reverse < INT_MIN:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse != INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if reverse > INT_MAX or reverse < INT_MIN:",
      "mutated_line": "if reverse > INT_MAX or reverse <= INT_MIN:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse <= INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if reverse > INT_MAX or reverse < INT_MIN:",
      "mutated_line": "if reverse > INT_MAX or reverse >= INT_MIN:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse >= INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if reverse > INT_MAX or reverse < INT_MIN:",
      "mutated_line": "if reverse > INT_MAX or reverse != INT_MIN:",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse != INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 1\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return -1\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 1\n    return total_sum"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 * 31 - 1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 * 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 + 31 - 1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 + 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 2, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 2, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 0, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 0, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 0, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 0, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - -1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - -1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 1, -(2 * 31))",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -(2 * 31))\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 1, -(2 + 31))",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -(2 + 31))\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "last_digit = num % 10",
      "mutated_line": "last_digit = num % 11",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 11\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "last_digit = num % 10",
      "mutated_line": "last_digit = num % 9",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 9\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "last_digit = num % 10",
      "mutated_line": "last_digit = num % 0",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 0\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "last_digit = num % 10",
      "mutated_line": "last_digit = num % 1",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 1\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "last_digit = num % 10",
      "mutated_line": "last_digit = num % -10",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % -10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "reverse = reverse * 10 + last_digit",
      "mutated_line": "reverse = reverse / 10 + last_digit",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse / 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "reverse = reverse * 10 + last_digit",
      "mutated_line": "reverse = reverse + 10 + last_digit",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse + 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "reverse = reverse * 10 + last_digit",
      "mutated_line": "reverse = reverse ** 10 + last_digit",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse ** 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (3 ** 31 - 1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (3 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (1 ** 31 - 1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (1 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (0 ** 31 - 1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (0 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (1 ** 31 - 1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (1 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (-2 ** 31 - 1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (-2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 32 - 1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 32 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 30 - 1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 30 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 0 - 1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 0 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 1 - 1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 1 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** -31 - 1, -2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** -31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 1, -3 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -3 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 1, -1 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -1 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 1, -0 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -0 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 1, -1 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -1 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 1, --2 ** 31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, --2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 32)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 32)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 30)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 30)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 0)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 0)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 1)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 1)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INT_MAX, INT_MIN = 2**31 - 1, -2**31",
      "mutated_line": "(INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** -31)",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** -31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "reverse = reverse * 10 + last_digit",
      "mutated_line": "reverse = reverse * 11 + last_digit",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 11 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "reverse = reverse * 10 + last_digit",
      "mutated_line": "reverse = reverse * 9 + last_digit",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 9 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "reverse = reverse * 10 + last_digit",
      "mutated_line": "reverse = reverse * 0 + last_digit",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 0 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "reverse = reverse * 10 + last_digit",
      "mutated_line": "reverse = reverse * 1 + last_digit",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * 1 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "reverse = reverse * 10 + last_digit",
      "mutated_line": "reverse = reverse * -10 + last_digit",
      "code": "def reverse_and_sum(num: int) -> int:\n    \"\"\"\n    This function takes an integer as input, reverses it, and returns the sum of its digits.\n    It handles both positive and negative integers, preserving the sign in the reversed integer.\n    If the reversed integer overflows, it returns 0.\n    \n    The time complexity is O(logN) and the space complexity is O(1).\n\n    Args:\n        num (int): The input integer.\n\n    Returns:\n        int: The sum of the digits of the reversed integer.\n    \"\"\"\n    reverse = 0\n    total_sum = 0\n    is_negative = False\n    (INT_MAX, INT_MIN) = (2 ** 31 - 1, -2 ** 31)\n    if num < 0:\n        is_negative = True\n        num = -num\n    while num > 0:\n        last_digit = num % 10\n        reverse = reverse * -10 + last_digit\n        total_sum += last_digit\n        num //= 10\n    if is_negative:\n        reverse = -reverse\n    if reverse > INT_MAX or reverse < INT_MIN:\n        return 0\n    return total_sum"
    }
  ]
}