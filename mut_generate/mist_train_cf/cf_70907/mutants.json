{
  "task_id": "cf_70907",
  "entry_point": "weighted_avg_custom_base",
  "mutant_count": 115,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m and (not 1 <= d <= m - n + 1) and (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m and (not 1 <= d <= m - n + 1) and (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sum_weighted_num = 0",
      "mutated_line": "sum_weighted_num = 1",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 1\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sum_weighted_num = 0",
      "mutated_line": "sum_weighted_num = -1",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = -1\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sum_weighted_num = 0",
      "mutated_line": "sum_weighted_num = 1",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 1\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sum_weights = 0",
      "mutated_line": "sum_weights = 1",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 1\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sum_weights = 0",
      "mutated_line": "sum_weights = -1",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = -1\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sum_weights = 0",
      "mutated_line": "sum_weights = 1",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 1\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "sum_weighted_num += weighted_num",
      "mutated_line": "sum_weighted_num -= weighted_num",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num -= weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "sum_weights += weight * d",
      "mutated_line": "sum_weights -= weight * d",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights -= weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if base == 2:",
      "mutated_line": "if base != 2:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base != 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n >= m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n >= m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n <= m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n <= m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n != m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n != m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return +1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for num in range(n, m + 1):",
      "mutated_line": "weight = sum((1 for i in range(1, num + 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m - 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for num in range(n, m + 1):",
      "mutated_line": "weight = sum((1 for i in range(1, num + 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m * 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "weighted_num = num * weight * d",
      "mutated_line": "weighted_num = num * weight / d",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight / d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "weighted_num = num * weight * d",
      "mutated_line": "weighted_num = num * weight + d",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight + d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "weighted_num = num * weight * d",
      "mutated_line": "weighted_num = (num * weight) ** d",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = (num * weight) ** d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "sum_weights += weight * d",
      "mutated_line": "sum_weights += weight / d",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight / d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "sum_weights += weight * d",
      "mutated_line": "sum_weights += weight + d",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight + d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "sum_weights += weight * d",
      "mutated_line": "sum_weights += weight ** d",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight ** d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "weighted_mean = round(sum_weighted_num / sum_weights)",
      "mutated_line": "weighted_mean = round(sum_weighted_num * sum_weights)",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num * sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "weighted_mean = round(sum_weighted_num / sum_weights)",
      "mutated_line": "weighted_mean = round(sum_weighted_num // sum_weights)",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num // sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if base == 2:",
      "mutated_line": "if base == 3:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 3:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if base == 2:",
      "mutated_line": "if base == 1:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 1:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if base == 2:",
      "mutated_line": "if base == 0:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 0:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if base == 2:",
      "mutated_line": "if base == 1:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 1:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if base == 2:",
      "mutated_line": "if base == -2:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == -2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base != 8:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base != 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 < d <= m - n + 1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 < d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 > d <= m - n + 1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 > d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 == d <= m - n + 1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 == d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 1 or (not 2 < base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 < base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 1 or (not 2 > base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 > base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 1 or (not 2 == base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 == base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -2\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -0\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -0\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return --1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(n, m + 1):",
      "mutated_line": "weight = sum((1 for i in range(1, num + 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 2):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(n, m + 1):",
      "mutated_line": "weight = sum((1 for i in range(1, num + 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 0):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(n, m + 1):",
      "mutated_line": "weight = sum((1 for i in range(1, num + 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 0):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for num in range(n, m + 1):",
      "mutated_line": "weight = sum((1 for i in range(1, num + 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + -1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "weighted_num = num * weight * d",
      "mutated_line": "weighted_num = num / weight * d",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num / weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "weighted_num = num * weight * d",
      "mutated_line": "weighted_num = (num + weight) * d",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = (num + weight) * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "weighted_num = num * weight * d",
      "mutated_line": "weighted_num = num ** weight * d",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num ** weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == 9:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 9:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == 7:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 7:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == 0:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 0:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == 1:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 1:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif base == 8:",
      "mutated_line": "elif base == -8:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == -8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif base == 16:",
      "mutated_line": "elif base != 16:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base != 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 2 <= d <= m - n + 1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 2 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 0 <= d <= m - n + 1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 0 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 0 <= d <= m - n + 1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 0 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not -1 <= d <= m - n + 1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not -1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n - 1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n - 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= (m - n) * 1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= (m - n) * 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 1 or (not 3 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 3 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 1 or (not 1 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 1 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 1 or (not 0 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 0 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 1 or (not 1 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 1 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 1 or (not -2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not -2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 21):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 21):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 19):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 19):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 0):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 0):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 1):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 1):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= -20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= -20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((2 for i in range(1, num + 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((2 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((0 for i in range(1, num + 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((0 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((0 for i in range(1, num + 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((0 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((-1 for i in range(1, num + 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((-1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif base == 16:",
      "mutated_line": "elif base == 17:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 17:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif base == 16:",
      "mutated_line": "elif base == 15:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 15:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif base == 16:",
      "mutated_line": "elif base == 0:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 0:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif base == 16:",
      "mutated_line": "elif base == 1:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 1:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif base == 16:",
      "mutated_line": "elif base == -16:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == -16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "while weighted_mean > 0:",
      "mutated_line": "while weighted_mean >= 0:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean >= 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "while weighted_mean > 0:",
      "mutated_line": "while weighted_mean <= 0:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean <= 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "while weighted_mean > 0:",
      "mutated_line": "while weighted_mean != 0:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean != 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "return str(base) + 'b' + ''.join(map(str, reversed(digits)))",
      "mutated_line": "return str(base) + 'b' - ''.join(map(str, reversed(digits)))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' - ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "return str(base) + 'b' + ''.join(map(str, reversed(digits)))",
      "mutated_line": "return (str(base) + 'b') * ''.join(map(str, reversed(digits)))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return (str(base) + 'b') * ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m + n + 1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m + n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m * n + 1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m * n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 2 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 2 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 0 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 0 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + 0 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 0 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if n > m or not 1 <= d <= m - n + 1 or not 2 <= base <= 20:",
      "mutated_line": "if n > m or not 1 <= d <= m - n + -1 or (not 2 <= base <= 20):",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + -1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(1, num + 1) if num % i != 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i != 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "while weighted_mean > 0:",
      "mutated_line": "while weighted_mean > 1:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 1:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "while weighted_mean > 0:",
      "mutated_line": "while weighted_mean > -1:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > -1:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "while weighted_mean > 0:",
      "mutated_line": "while weighted_mean > 1:",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 1:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "return str(base) + 'b' + ''.join(map(str, reversed(digits)))",
      "mutated_line": "return str(base) - 'b' + ''.join(map(str, reversed(digits)))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) - 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "return str(base) + 'b' + ''.join(map(str, reversed(digits)))",
      "mutated_line": "return str(base) * 'b' + ''.join(map(str, reversed(digits)))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) * 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(2, num + 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(2, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(0, num + 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(0, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(0, num + 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(0, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(-1, num + 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(-1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(1, num - 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num - 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(1, num * 1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num * 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(1, num + 1) if num * i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num * i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(1, num + 1) if num + i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num + i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(1, num + 1) if num % i == 1))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 1))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(1, num + 1) if num % i == -1))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == -1))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(1, num + 1) if num % i == 1))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 1))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return str(base) + 'b' + ''.join(map(str, reversed(digits)))",
      "mutated_line": "return str(base) + '' + ''.join(map(str, reversed(digits)))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + '' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(1, num + 2) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 2) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(1, num + 0) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 0) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(1, num + 0) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 0) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "weight = sum(1 for i in range(1, num + 1) if num % i == 0)",
      "mutated_line": "weight = sum((1 for i in range(1, num + -1) if num % i == 0))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + -1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "digits.append(int(weighted_mean % base))",
      "mutated_line": "digits.append(int(weighted_mean * base))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean * base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "digits.append(int(weighted_mean % base))",
      "mutated_line": "digits.append(int(weighted_mean + base))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean + base))\n            weighted_mean //= base\n        return str(base) + 'b' + ''.join(map(str, reversed(digits)))"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return str(base) + 'b' + ''.join(map(str, reversed(digits)))",
      "mutated_line": "return str(base) + 'b' + 'MUTATED'.join(map(str, reversed(digits)))",
      "code": "def weighted_avg_custom_base(n, m, d, base):\n    \"\"\"\n    This function computes the weighted mean of all integers between 'n' and 'm' (inclusive),\n    where the weights of each number are defined by the count of their divisors.\n    The weights are then multiplied by the factor 'd'. The computed weighted mean is rounded \n    to the closest integer and then converted into a numeral system representation based on the 'base'.\n\n    Args:\n    n (int): The start of the range (inclusive).\n    m (int): The end of the range (inclusive).\n    d (int): The factor to multiply the weights by.\n    base (int): The base of the numeral system.\n\n    Returns:\n    str: The weighted mean in the specified numeral system representation.\n    \"\"\"\n    if n > m or not 1 <= d <= m - n + 1 or (not 2 <= base <= 20):\n        return -1\n    sum_weighted_num = 0\n    sum_weights = 0\n    for num in range(n, m + 1):\n        weight = sum((1 for i in range(1, num + 1) if num % i == 0))\n        weighted_num = num * weight * d\n        sum_weighted_num += weighted_num\n        sum_weights += weight * d\n    weighted_mean = round(sum_weighted_num / sum_weights)\n    if base == 2:\n        return bin(weighted_mean)\n    elif base == 8:\n        return oct(weighted_mean)\n    elif base == 16:\n        return hex(weighted_mean)\n    else:\n        digits = []\n        while weighted_mean > 0:\n            digits.append(int(weighted_mean % base))\n            weighted_mean //= base\n        return str(base) + 'b' + 'MUTATED'.join(map(str, reversed(digits)))"
    }
  ]
}