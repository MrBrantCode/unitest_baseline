{
  "task_id": "cf_41322",
  "entry_point": "evaluate_function",
  "mutant_count": 16,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\"\"\"\n    n_samples = 2\n    dim_codomain = 3\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x + y, x * y]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n_samples = 2",
      "mutated_line": "n_samples = 3",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = 3\n    dim_codomain = 3\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x + y, x * y]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n_samples = 2",
      "mutated_line": "n_samples = 1",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = 1\n    dim_codomain = 3\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x + y, x * y]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n_samples = 2",
      "mutated_line": "n_samples = 0",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = 0\n    dim_codomain = 3\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x + y, x * y]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n_samples = 2",
      "mutated_line": "n_samples = 1",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = 1\n    dim_codomain = 3\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x + y, x * y]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n_samples = 2",
      "mutated_line": "n_samples = -2",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = -2\n    dim_codomain = 3\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x + y, x * y]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dim_codomain = 3",
      "mutated_line": "dim_codomain = 4",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = 2\n    dim_codomain = 4\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x + y, x * y]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dim_codomain = 3",
      "mutated_line": "dim_codomain = 2",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = 2\n    dim_codomain = 2\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x + y, x * y]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dim_codomain = 3",
      "mutated_line": "dim_codomain = 0",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = 2\n    dim_codomain = 0\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x + y, x * y]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dim_codomain = 3",
      "mutated_line": "dim_codomain = 1",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = 2\n    dim_codomain = 1\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x + y, x * y]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dim_codomain = 3",
      "mutated_line": "dim_codomain = -3",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = 2\n    dim_codomain = -3\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x + y, x * y]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "result[i, j] = [x, x + y, x * y]",
      "mutated_line": "result[i, j] = [x, x - y, x * y]",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = 2\n    dim_codomain = 3\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x - y, x * y]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "result[i, j] = [x, x + y, x * y]",
      "mutated_line": "result[i, j] = [x, x * y, x * y]",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = 2\n    dim_codomain = 3\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x * y, x * y]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "result[i, j] = [x, x + y, x * y]",
      "mutated_line": "result[i, j] = [x, x + y, x / y]",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = 2\n    dim_codomain = 3\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x + y, x / y]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "result[i, j] = [x, x + y, x * y]",
      "mutated_line": "result[i, j] = [x, x + y, x + y]",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = 2\n    dim_codomain = 3\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x + y, x + y]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "result[i, j] = [x, x + y, x * y]",
      "mutated_line": "result[i, j] = [x, x + y, x ** y]",
      "code": "import numpy as np\n\ndef evaluate_function(eval_points: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate a mathematical function at specified points.\n\n    Args:\n        eval_points (numpy.ndarray): Numpy array with shape\n            ``(number_eval_points, dim_domain)`` with the\n            evaluation points.\n\n    Returns:\n        (numpy.ndarray): Numpy 3d array with shape\n            ``(n_samples, number_eval_points, dim_codomain)`` with the\n            result of the evaluation. The entry ``(i,j,k)`` will contain\n            the value k-th image dimension of the i-th sample, at the\n            j-th evaluation point.\n    \"\"\"\n    n_samples = 2\n    dim_codomain = 3\n    (n_eval_points, dim_domain) = eval_points.shape\n    result = np.zeros((n_samples, n_eval_points, dim_codomain))\n    for i in range(n_samples):\n        for j in range(n_eval_points):\n            (x, y) = eval_points[j]\n            result[i, j] = [x, x + y, x ** y]\n    return result"
    }
  ]
}