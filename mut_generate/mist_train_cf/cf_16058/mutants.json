{
  "task_id": "cf_16058",
  "entry_point": "find_top_cities",
  "mutant_count": 149,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "total_area = math.pi * (distance ** 2)",
      "mutated_line": "total_area = math.pi / distance ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi / distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "total_area = math.pi * (distance ** 2)",
      "mutated_line": "total_area = math.pi + distance ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi + distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "total_area = math.pi * (distance ** 2)",
      "mutated_line": "total_area = math.pi ** distance ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi ** distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "average_density = total_population / total_area",
      "mutated_line": "average_density = total_population * total_area",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population * total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "average_density = total_population / total_area",
      "mutated_line": "average_density = total_population // total_area",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population // total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "R = 6371.0",
      "mutated_line": "R = 6372.0",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6372.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "R = 6371.0",
      "mutated_line": "R = 6370.0",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6370.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "R = 6371.0",
      "mutated_line": "R = 0",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "R = 6371.0",
      "mutated_line": "R = 1",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 1\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "R = 6371.0",
      "mutated_line": "R = -6371.0",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = -6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dlon = lon2_rad - lon1_rad",
      "mutated_line": "dlon = lon2_rad + lon1_rad",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad + lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dlon = lon2_rad - lon1_rad",
      "mutated_line": "dlon = lon2_rad * lon1_rad",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad * lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dlat = lat2_rad - lat1_rad",
      "mutated_line": "dlat = lat2_rad + lat1_rad",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad + lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dlat = lat2_rad - lat1_rad",
      "mutated_line": "dlat = lat2_rad * lat1_rad",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad * lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 - math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 - math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 * (math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2)",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 * (math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 / math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 / math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 + math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 + math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 ** math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 ** math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "distance = R * c",
      "mutated_line": "distance = R / c",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R / c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "distance = R * c",
      "mutated_line": "distance = R + c",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R + c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "distance = R * c",
      "mutated_line": "distance = R ** c",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R ** c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "R = 6371.0",
      "mutated_line": "R = 6372.0",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6372.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "R = 6371.0",
      "mutated_line": "R = 6370.0",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6370.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "R = 6371.0",
      "mutated_line": "R = 0",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "R = 6371.0",
      "mutated_line": "R = 1",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 1\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "R = 6371.0",
      "mutated_line": "R = -6371.0",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = -6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dlon = lon2_rad - lon1_rad",
      "mutated_line": "dlon = lon2_rad + lon1_rad",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad + lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dlon = lon2_rad - lon1_rad",
      "mutated_line": "dlon = lon2_rad * lon1_rad",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad * lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "dlat = lat2_rad - lat1_rad",
      "mutated_line": "dlat = lat2_rad + lat1_rad",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad + lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "dlat = lat2_rad - lat1_rad",
      "mutated_line": "dlat = lat2_rad * lat1_rad",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad * lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 - math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 - math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 * (math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2)",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 * (math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 / math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 / math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 + math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 + math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 ** math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 ** math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "distance = R * c",
      "mutated_line": "distance = R / c",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R / c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "distance = R * c",
      "mutated_line": "distance = R + c",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R + c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "distance = R * c",
      "mutated_line": "distance = R ** c",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R ** c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "total_area = math.pi * (distance ** 2)",
      "mutated_line": "total_area = math.pi * (distance * 2)",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * (distance * 2)\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "total_area = math.pi * (distance ** 2)",
      "mutated_line": "total_area = math.pi * (distance + 2)",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * (distance + 2)\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) * 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) * 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) + 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) + 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) / math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) / math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + (math.cos(lat1_rad) * math.cos(lat2_rad) + math.sin(dlon / 2) ** 2)",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + (math.cos(lat1_rad) * math.cos(lat2_rad) + math.sin(dlon / 2) ** 2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + (math.cos(lat1_rad) * math.cos(lat2_rad)) ** math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + (math.cos(lat1_rad) * math.cos(lat2_rad)) ** math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 3 * math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 3 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 1 * math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 1 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 0 * math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 0 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 1 * math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 1 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = -2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = -2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]",
      "mutated_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) < distance]",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) < distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]",
      "mutated_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) > distance]",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) > distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]",
      "mutated_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) == distance]",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) == distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)",
      "mutated_line": "sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=False)",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=False)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) * 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) * 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) + 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) + 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) / math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) / math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + (math.cos(lat1_rad) * math.cos(lat2_rad) + math.sin(dlon / 2) ** 2)",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + (math.cos(lat1_rad) * math.cos(lat2_rad) + math.sin(dlon / 2) ** 2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + (math.cos(lat1_rad) * math.cos(lat2_rad)) ** math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + (math.cos(lat1_rad) * math.cos(lat2_rad)) ** math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 3 * math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 3 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 1 * math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 1 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 0 * math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 0 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 1 * math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 1 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = -2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = -2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]",
      "mutated_line": "total_population = sum((city['population'] for city in filtered_cities))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) < distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]",
      "mutated_line": "total_population = sum((city['population'] for city in filtered_cities))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) > distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]",
      "mutated_line": "total_population = sum((city['population'] for city in filtered_cities))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) == distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "total_area = math.pi * (distance ** 2)",
      "mutated_line": "total_area = math.pi * distance ** 3",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 3\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "total_area = math.pi * (distance ** 2)",
      "mutated_line": "total_area = math.pi * distance ** 1",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 1\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "total_area = math.pi * (distance ** 2)",
      "mutated_line": "total_area = math.pi * distance ** 0",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 0\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "total_area = math.pi * (distance ** 2)",
      "mutated_line": "total_area = math.pi * distance ** 1",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 1\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "total_area = math.pi * (distance ** 2)",
      "mutated_line": "total_area = math.pi * distance ** -2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** -2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 3 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 3 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 1 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 1 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 0 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 0 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 1 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 1 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** -2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** -2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) / math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) / math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + (math.cos(lat1_rad) + math.cos(lat2_rad)) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + (math.cos(lat1_rad) + math.cos(lat2_rad)) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) ** math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) ** math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * (math.sin(dlon / 2) * 2)",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * (math.sin(dlon / 2) * 2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * (math.sin(dlon / 2) + 2)",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * (math.sin(dlon / 2) + 2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 3 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 3 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 1 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 1 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 0 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 0 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 1 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 1 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** -2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** -2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) / math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) / math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + (math.cos(lat1_rad) + math.cos(lat2_rad)) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + (math.cos(lat1_rad) + math.cos(lat2_rad)) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) ** math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) ** math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * (math.sin(dlon / 2) * 2)",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * (math.sin(dlon / 2) * 2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * (math.sin(dlon / 2) + 2)",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * (math.sin(dlon / 2) + 2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "total_population = sum(city['population'] for city in filtered_cities)",
      "mutated_line": "total_population = sum((city[''] for city in filtered_cities))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city[''] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat * 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat * 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat // 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat // 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 3",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 3\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 1",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 1\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 0",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 0\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 1",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 1\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** -2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** -2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 + a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 + a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 * a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 * a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)",
      "mutated_line": "sorted_cities = sorted(filtered_cities, key=lambda city: city[''], reverse=True)",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city[''], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat * 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat * 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat // 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat // 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 3",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 3\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 1",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 1\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 0",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 0\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 1",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 1\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** -2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** -2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 + a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 + a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 * a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 * a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 3) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 3) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 1) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 1) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 0) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 0) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 1) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 1) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / -2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / -2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon * 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon * 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon // 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon // 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(2 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(2 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(0 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(0 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(0 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(0 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(-1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(-1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]",
      "mutated_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city[''], city['longitude']) <= distance]",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city[''], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]",
      "mutated_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['']) <= distance]",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 3) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 3) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 1) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 1) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 0) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 0) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 1) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 1) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / -2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / -2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon * 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon * 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon // 2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon // 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(2 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(2 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(0 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(0 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(0 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(0 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))",
      "mutated_line": "c = 2 * math.atan2(math.sqrt(a), math.sqrt(-1 - a))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(-1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]",
      "mutated_line": "total_population = sum((city['population'] for city in filtered_cities))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city[''], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]",
      "mutated_line": "total_population = sum((city['population'] for city in filtered_cities))",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 3) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 3) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 1) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 1) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 0) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 0) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 1) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 1) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / -2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / -2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 3) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 3) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 1) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 1) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 0) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 0) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 1) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 1) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2",
      "mutated_line": "a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / -2) ** 2",
      "code": "import math\n\ndef find_top_cities(city_data, center_lat, center_lon, distance, num_cities):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    sorted_cities = sorted(filtered_cities, key=lambda city: city['population'], reverse=True)\n    top_cities = sorted_cities[:num_cities]\n    return top_cities\n\ndef calculate_average_density(city_data, center_lat, center_lon, distance):\n\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371.0\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.radians(lat2)\n        lon2_rad = math.radians(lon2)\n        dlon = lon2_rad - lon1_rad\n        dlat = lat2_rad - lat1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / -2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        distance = R * c\n        return distance\n    filtered_cities = [city for city in city_data if haversine_distance(center_lat, center_lon, city['latitude'], city['longitude']) <= distance]\n    total_population = sum((city['population'] for city in filtered_cities))\n    total_area = math.pi * distance ** 2\n    average_density = total_population / total_area\n    return average_density"
    }
  ]
}