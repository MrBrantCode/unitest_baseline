{
  "task_id": "cf_63998",
  "entry_point": "minCostToMoveChips",
  "mutant_count": 44,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "total_cost1 += counter[p] * ((abs(p - min1)) % 2) # `% 2` to account for the free moves of 2",
      "mutated_line": "total_cost1 -= counter[p] * (abs(p - min1) % 2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 -= counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "total_cost2 += counter[p] * ((abs(p - min2)) % 2)",
      "mutated_line": "total_cost2 -= counter[p] * (abs(p - min2) % 2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 -= counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if min1 not in restricted:",
      "mutated_line": "if min1 in restricted:",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "total_cost1, total_cost2 = 0, 0",
      "mutated_line": "(total_cost1, total_cost2) = (1, 0)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (1, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "total_cost1, total_cost2 = 0, 0",
      "mutated_line": "(total_cost1, total_cost2) = (-1, 0)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (-1, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "total_cost1, total_cost2 = 0, 0",
      "mutated_line": "(total_cost1, total_cost2) = (1, 0)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (1, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "total_cost1, total_cost2 = 0, 0",
      "mutated_line": "(total_cost1, total_cost2) = (0, 1)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 1)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "total_cost1, total_cost2 = 0, 0",
      "mutated_line": "(total_cost1, total_cost2) = (0, -1)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, -1)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "total_cost1, total_cost2 = 0, 0",
      "mutated_line": "(total_cost1, total_cost2) = (0, 1)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 1)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "total_cost1 += counter[p] * ((abs(p - min1)) % 2) # `% 2` to account for the free moves of 2",
      "mutated_line": "total_cost1 += counter[p] / (abs(p - min1) % 2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] / (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "total_cost1 += counter[p] * ((abs(p - min1)) % 2) # `% 2` to account for the free moves of 2",
      "mutated_line": "total_cost1 += counter[p] + abs(p - min1) % 2",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] + abs(p - min1) % 2\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "total_cost1 += counter[p] * ((abs(p - min1)) % 2) # `% 2` to account for the free moves of 2",
      "mutated_line": "total_cost1 += counter[p] ** (abs(p - min1) % 2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] ** (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "total_cost2 += counter[p] * ((abs(p - min2)) % 2)",
      "mutated_line": "total_cost2 += counter[p] / (abs(p - min2) % 2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] / (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "total_cost2 += counter[p] * ((abs(p - min2)) % 2)",
      "mutated_line": "total_cost2 += counter[p] + abs(p - min2) % 2",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] + abs(p - min2) % 2\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "total_cost2 += counter[p] * ((abs(p - min2)) % 2)",
      "mutated_line": "total_cost2 += counter[p] ** (abs(p - min2) % 2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] ** (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif min2 not in restricted:",
      "mutated_line": "elif min2 in restricted:",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "min1, min2 = sorted(counter, key = counter.get)[:2]",
      "mutated_line": "(min1, min2) = sorted(counter, key=counter.get)[:3]",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:3]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "min1, min2 = sorted(counter, key = counter.get)[:2]",
      "mutated_line": "(min1, min2) = sorted(counter, key=counter.get)[:1]",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:1]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "min1, min2 = sorted(counter, key = counter.get)[:2]",
      "mutated_line": "(min1, min2) = sorted(counter, key=counter.get)[:0]",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:0]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "min1, min2 = sorted(counter, key = counter.get)[:2]",
      "mutated_line": "(min1, min2) = sorted(counter, key=counter.get)[:1]",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:1]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "min1, min2 = sorted(counter, key = counter.get)[:2]",
      "mutated_line": "(min1, min2) = sorted(counter, key=counter.get)[:-2]",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:-2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "total_cost1 += counter[p] * ((abs(p - min1)) % 2) # `% 2` to account for the free moves of 2",
      "mutated_line": "total_cost1 += counter[p] * (abs(p - min1) * 2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) * 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "total_cost1 += counter[p] * ((abs(p - min1)) % 2) # `% 2` to account for the free moves of 2",
      "mutated_line": "total_cost1 += counter[p] * (abs(p - min1) + 2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) + 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "total_cost2 += counter[p] * ((abs(p - min2)) % 2)",
      "mutated_line": "total_cost2 += counter[p] * (abs(p - min2) * 2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) * 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "total_cost2 += counter[p] * ((abs(p - min2)) % 2)",
      "mutated_line": "total_cost2 += counter[p] * (abs(p - min2) + 2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) + 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return +1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "total_cost1 += counter[p] * ((abs(p - min1)) % 2) # `% 2` to account for the free moves of 2",
      "mutated_line": "total_cost1 += counter[p] * (abs(p - min1) % 3)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 3)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "total_cost1 += counter[p] * ((abs(p - min1)) % 2) # `% 2` to account for the free moves of 2",
      "mutated_line": "total_cost1 += counter[p] * (abs(p - min1) % 1)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 1)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "total_cost1 += counter[p] * ((abs(p - min1)) % 2) # `% 2` to account for the free moves of 2",
      "mutated_line": "total_cost1 += counter[p] * (abs(p - min1) % 0)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 0)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "total_cost1 += counter[p] * ((abs(p - min1)) % 2) # `% 2` to account for the free moves of 2",
      "mutated_line": "total_cost1 += counter[p] * (abs(p - min1) % 1)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 1)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "total_cost1 += counter[p] * ((abs(p - min1)) % 2) # `% 2` to account for the free moves of 2",
      "mutated_line": "total_cost1 += counter[p] * (abs(p - min1) % -2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % -2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "total_cost2 += counter[p] * ((abs(p - min2)) % 2)",
      "mutated_line": "total_cost2 += counter[p] * (abs(p - min2) % 3)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 3)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "total_cost2 += counter[p] * ((abs(p - min2)) % 2)",
      "mutated_line": "total_cost2 += counter[p] * (abs(p - min2) % 1)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 1)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "total_cost2 += counter[p] * ((abs(p - min2)) % 2)",
      "mutated_line": "total_cost2 += counter[p] * (abs(p - min2) % 0)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 0)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "total_cost2 += counter[p] * ((abs(p - min2)) % 2)",
      "mutated_line": "total_cost2 += counter[p] * (abs(p - min2) % 1)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 1)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "total_cost2 += counter[p] * ((abs(p - min2)) % 2)",
      "mutated_line": "total_cost2 += counter[p] * (abs(p - min2) % -2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % -2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return --1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "total_cost1 += counter[p] * ((abs(p - min1)) % 2) # `% 2` to account for the free moves of 2",
      "mutated_line": "total_cost1 += counter[p] * (abs(p + min1) % 2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p + min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "total_cost1 += counter[p] * ((abs(p - min1)) % 2) # `% 2` to account for the free moves of 2",
      "mutated_line": "total_cost1 += counter[p] * (abs(p * min1) % 2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p * min1) % 2)\n        total_cost2 += counter[p] * (abs(p - min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "total_cost2 += counter[p] * ((abs(p - min2)) % 2)",
      "mutated_line": "total_cost2 += counter[p] * (abs(p + min2) % 2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p + min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "total_cost2 += counter[p] * ((abs(p - min2)) % 2)",
      "mutated_line": "total_cost2 += counter[p] * (abs(p * min2) % 2)",
      "code": "def minCostToMoveChips(position, restricted):\n    from collections import Counter\n    restricted = set(restricted)\n    counter = Counter(position)\n    (min1, min2) = sorted(counter, key=counter.get)[:2]\n    (total_cost1, total_cost2) = (0, 0)\n    for p in counter:\n        total_cost1 += counter[p] * (abs(p - min1) % 2)\n        total_cost2 += counter[p] * (abs(p * min2) % 2)\n    if min1 not in restricted:\n        return total_cost1\n    elif min2 not in restricted:\n        return total_cost2\n    else:\n        return -1"
    }
  ]
}