{
  "task_id": "cf_31892",
  "entry_point": "entrance",
  "mutant_count": 37,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "in_degree[module] += 1",
      "mutated_line": "in_degree[module] -= 1",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] -= 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if len(result) != len(graph):",
      "mutated_line": "if len(result) == len(graph):",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) == len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if module not in graph:",
      "mutated_line": "if module in graph:",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, len(dependencies)):",
      "mutated_line": "for i in range(2, len(dependencies)):",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(2, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, len(dependencies)):",
      "mutated_line": "for i in range(0, len(dependencies)):",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(0, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, len(dependencies)):",
      "mutated_line": "for i in range(0, len(dependencies)):",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(0, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, len(dependencies)):",
      "mutated_line": "for i in range(-1, len(dependencies)):",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(-1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "in_degree[module] += 1",
      "mutated_line": "in_degree[module] += 2",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 2\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "in_degree[module] += 1",
      "mutated_line": "in_degree[module] += 0",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 0\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "in_degree[module] += 1",
      "mutated_line": "in_degree[module] += 0",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 0\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "in_degree[module] += 1",
      "mutated_line": "in_degree[module] += -1",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += -1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "in_degree[module] -= 1",
      "mutated_line": "in_degree[module] += 1",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] += 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "in_degree[module] = 0",
      "mutated_line": "in_degree[module] = 1",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 1\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "in_degree[module] = 0",
      "mutated_line": "in_degree[module] = -1",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = -1\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "in_degree[module] = 0",
      "mutated_line": "in_degree[module] = 1",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 1\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "prev_module, prev_version = dependencies[i-1]",
      "mutated_line": "(prev_module, prev_version) = dependencies[i + 1]",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i + 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "prev_module, prev_version = dependencies[i-1]",
      "mutated_line": "(prev_module, prev_version) = dependencies[i * 1]",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i * 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "queue = [module for module in graph if in_degree[module] == 0]",
      "mutated_line": "queue = [module for module in graph if in_degree[module] != 0]",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] != 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "current_module = queue.pop(0)",
      "mutated_line": "current_module = queue.pop(1)",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(1)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "current_module = queue.pop(0)",
      "mutated_line": "current_module = queue.pop(-1)",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(-1)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "current_module = queue.pop(0)",
      "mutated_line": "current_module = queue.pop(1)",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(1)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "in_degree[module] -= 1",
      "mutated_line": "in_degree[module] -= 2",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 2\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "in_degree[module] -= 1",
      "mutated_line": "in_degree[module] -= 0",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 0\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "in_degree[module] -= 1",
      "mutated_line": "in_degree[module] -= 0",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 0\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "in_degree[module] -= 1",
      "mutated_line": "in_degree[module] -= -1",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= -1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if in_degree[module] == 0:",
      "mutated_line": "if in_degree[module] != 0:",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] != 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "return [op for op in operations if op in result]",
      "mutated_line": "return [op for op in operations if op not in result]",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op not in result]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prev_module, prev_version = dependencies[i-1]",
      "mutated_line": "(prev_module, prev_version) = dependencies[i - 2]",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 2]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prev_module, prev_version = dependencies[i-1]",
      "mutated_line": "(prev_module, prev_version) = dependencies[i - 0]",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 0]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prev_module, prev_version = dependencies[i-1]",
      "mutated_line": "(prev_module, prev_version) = dependencies[i - 0]",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 0]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prev_module, prev_version = dependencies[i-1]",
      "mutated_line": "(prev_module, prev_version) = dependencies[i - -1]",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - -1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue = [module for module in graph if in_degree[module] == 0]",
      "mutated_line": "queue = [module for module in graph if in_degree[module] == 1]",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 1]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue = [module for module in graph if in_degree[module] == 0]",
      "mutated_line": "queue = [module for module in graph if in_degree[module] == -1]",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == -1]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue = [module for module in graph if in_degree[module] == 0]",
      "mutated_line": "queue = [module for module in graph if in_degree[module] == 1]",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 1]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 0:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if in_degree[module] == 0:",
      "mutated_line": "if in_degree[module] == 1:",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 1:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if in_degree[module] == 0:",
      "mutated_line": "if in_degree[module] == -1:",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == -1:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if in_degree[module] == 0:",
      "mutated_line": "if in_degree[module] == 1:",
      "code": "from typing import List, Tuple\n\ndef entrance(dependencies: List[Tuple[str, str]], operations: List[str]) -> List[str]:\n    graph = {}\n    in_degree = {}\n    for (module, version) in dependencies:\n        if module not in graph:\n            graph[module] = []\n            in_degree[module] = 0\n    for i in range(1, len(dependencies)):\n        (prev_module, prev_version) = dependencies[i - 1]\n        (module, version) = dependencies[i]\n        graph[prev_module].append(module)\n        in_degree[module] += 1\n    queue = [module for module in graph if in_degree[module] == 0]\n    result = []\n    while queue:\n        current_module = queue.pop(0)\n        result.append(current_module)\n        for module in graph[current_module]:\n            in_degree[module] -= 1\n            if in_degree[module] == 1:\n                queue.append(module)\n    if len(result) != len(graph):\n        return []\n    return [op for op in operations if op in result]"
    }
  ]
}