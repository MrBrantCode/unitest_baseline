{
  "task_id": "cf_62721",
  "entry_point": "custom_lexicographic_order",
  "mutant_count": 56,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 1\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = -1\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 1\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "while(i < len(str1) and i < len(str2)):",
      "mutated_line": "while i < len(str1) or i < len(str2):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) or i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i -= 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return len(str1) <= len(str2)",
      "mutated_line": "return len(str1) < len(str2)",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) < len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return len(str1) <= len(str2)",
      "mutated_line": "return len(str1) > len(str2)",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) > len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return len(str1) <= len(str2)",
      "mutated_line": "return len(str1) == len(str2)",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) == len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while(i < len(str1) and i < len(str2)):",
      "mutated_line": "while i <= len(str1) and i < len(str2):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i <= len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while(i < len(str1) and i < len(str2)):",
      "mutated_line": "while i >= len(str1) and i < len(str2):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i >= len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while(i < len(str1) and i < len(str2)):",
      "mutated_line": "while i != len(str1) and i < len(str2):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i != len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while(i < len(str1) and i < len(str2)):",
      "mutated_line": "while i < len(str1) and i <= len(str2):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i <= len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while(i < len(str1) and i < len(str2)):",
      "mutated_line": "while i < len(str1) and i >= len(str2):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i >= len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while(i < len(str1) and i < len(str2)):",
      "mutated_line": "while i < len(str1) and i != len(str2):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i != len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if(ord(str1[i]) < ord(str2[i])):",
      "mutated_line": "if ord(str1[i]) <= ord(str2[i]):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) <= ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if(ord(str1[i]) < ord(str2[i])):",
      "mutated_line": "if ord(str1[i]) >= ord(str2[i]):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) >= ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if(ord(str1[i]) < ord(str2[i])):",
      "mutated_line": "if ord(str1[i]) != ord(str2[i]):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) != ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 2\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 0\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 0\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += -1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return False\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif(ord(str1[i]) > ord(str2[i])):",
      "mutated_line": "elif ord(str1[i]) >= ord(str2[i]):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) >= ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif(ord(str1[i]) > ord(str2[i])):",
      "mutated_line": "elif ord(str1[i]) <= ord(str2[i]):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) <= ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif(ord(str1[i]) > ord(str2[i])):",
      "mutated_line": "elif ord(str1[i]) != ord(str2[i]):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) != ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for j in range(len(data) - i - 1):",
      "mutated_line": "for j in range(len(data) - i + 1):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i + 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for j in range(len(data) - i - 1):",
      "mutated_line": "for j in range((len(data) - i) * 1):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range((len(data) - i) * 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return True\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for j in range(len(data) - i - 1):",
      "mutated_line": "for j in range(len(data) + i - 1):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) + i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for j in range(len(data) - i - 1):",
      "mutated_line": "for j in range(len(data) * i - 1):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) * i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(data) - i - 1):",
      "mutated_line": "for j in range(len(data) - i - 2):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 2):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(data) - i - 1):",
      "mutated_line": "for j in range(len(data) - i - 0):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 0):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(data) - i - 1):",
      "mutated_line": "for j in range(len(data) - i - 0):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 0):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(len(data) - i - 1):",
      "mutated_line": "for j in range(len(data) - i - -1):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - -1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):",
      "mutated_line": "if not custom_lexicographic_order(data[j][''], data[j + 1]['location']):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j][''], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):",
      "mutated_line": "if not custom_lexicographic_order(data[j]['location'], data[j + 1]['']):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "data[j], data[j + 1] = data[j + 1], data[j]",
      "mutated_line": "(data[j], data[j - 1]) = (data[j + 1], data[j])",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j - 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "data[j], data[j + 1] = data[j + 1], data[j]",
      "mutated_line": "(data[j], data[j * 1]) = (data[j + 1], data[j])",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j * 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "data[j], data[j + 1] = data[j + 1], data[j]",
      "mutated_line": "(data[j], data[j + 1]) = (data[j - 1], data[j])",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j - 1], data[j])\n    return data"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "data[j], data[j + 1] = data[j + 1], data[j]",
      "mutated_line": "(data[j], data[j + 1]) = (data[j * 1], data[j])",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j * 1], data[j])\n    return data"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):",
      "mutated_line": "if not custom_lexicographic_order(data[j]['location'], data[j - 1]['location']):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j - 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):",
      "mutated_line": "if not custom_lexicographic_order(data[j]['location'], data[j * 1]['location']):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j * 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "data[j], data[j + 1] = data[j + 1], data[j]",
      "mutated_line": "(data[j], data[j + 2]) = (data[j + 1], data[j])",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 2]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "data[j], data[j + 1] = data[j + 1], data[j]",
      "mutated_line": "(data[j], data[j + 0]) = (data[j + 1], data[j])",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 0]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "data[j], data[j + 1] = data[j + 1], data[j]",
      "mutated_line": "(data[j], data[j + 0]) = (data[j + 1], data[j])",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 0]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "data[j], data[j + 1] = data[j + 1], data[j]",
      "mutated_line": "(data[j], data[j + -1]) = (data[j + 1], data[j])",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + -1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "data[j], data[j + 1] = data[j + 1], data[j]",
      "mutated_line": "(data[j], data[j + 1]) = (data[j + 2], data[j])",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 2], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "data[j], data[j + 1] = data[j + 1], data[j]",
      "mutated_line": "(data[j], data[j + 1]) = (data[j + 0], data[j])",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 0], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "data[j], data[j + 1] = data[j + 1], data[j]",
      "mutated_line": "(data[j], data[j + 1]) = (data[j + 0], data[j])",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + 0], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "data[j], data[j + 1] = data[j + 1], data[j]",
      "mutated_line": "(data[j], data[j + 1]) = (data[j + -1], data[j])",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):\n                (data[j], data[j + 1]) = (data[j + -1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):",
      "mutated_line": "if not custom_lexicographic_order(data[j]['location'], data[j + 2]['location']):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 2]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):",
      "mutated_line": "if not custom_lexicographic_order(data[j]['location'], data[j + 0]['location']):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 0]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):",
      "mutated_line": "if not custom_lexicographic_order(data[j]['location'], data[j + 0]['location']):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + 0]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if not custom_lexicographic_order(data[j]['location'], data[j + 1]['location']):",
      "mutated_line": "if not custom_lexicographic_order(data[j]['location'], data[j + -1]['location']):",
      "code": "def custom_lexicographic_order(str1, str2):\n    \"\"\"\n    Compare two strings character by character and return True if str1 is lexicographically less than or equal to str2, False otherwise.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: Whether str1 is lexicographically less than or equal to str2.\n    \"\"\"\n    i = 0\n    while i < len(str1) and i < len(str2):\n        if ord(str1[i]) < ord(str2[i]):\n            return True\n        elif ord(str1[i]) > ord(str2[i]):\n            return False\n        i += 1\n    return len(str1) <= len(str2)\n\ndef custom_sort(data):\n    \"\"\"\n    Sort the input data by 'location' based on a custom lexicographic order.\n    \n    Args:\n        data (list): A list of dictionaries where each dictionary contains 'name' and 'location' as keys.\n    \n    Returns:\n        list: The sorted list of dictionaries.\n    \"\"\"\n    for i in range(len(data)):\n        for j in range(len(data) - i - 1):\n            if not custom_lexicographic_order(data[j]['location'], data[j + -1]['location']):\n                (data[j], data[j + 1]) = (data[j + 1], data[j])\n    return data"
    }
  ]
}