{
  "task_id": "cf_74542",
  "entry_point": "distributed_merge_sort",
  "mutant_count": 51,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "partition_size = len(data) // num_partitions",
      "mutated_line": "partition_size = len(data) / num_partitions",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) / num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "partition_size = len(data) // num_partitions",
      "mutated_line": "partition_size = len(data) * num_partitions",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) * num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "min_partition_index = -1",
      "mutated_line": "min_partition_index = +1",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = +1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "min_val = float('inf')",
      "mutated_line": "min_val = float('')",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "min_partition_index = -1",
      "mutated_line": "min_partition_index = -2",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -2\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "min_partition_index = -1",
      "mutated_line": "min_partition_index = -0",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -0\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "min_partition_index = -1",
      "mutated_line": "min_partition_index = -0",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -0\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "min_partition_index = -1",
      "mutated_line": "min_partition_index = --1",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = --1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "if partition and partition[0] < min_val:",
      "mutated_line": "if partition or partition[0] < min_val:",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition or partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i / partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i / partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i + partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i + partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i ** partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i ** partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:(i + 1) / partition_size] for i in range(num_partitions - 1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) / partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:i + 1 + partition_size] for i in range(num_partitions - 1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:i + 1 + partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:(i + 1) ** partition_size] for i in range(num_partitions - 1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) ** partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions + 1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions + 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions * 1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions * 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "partitions.append(data[(num_partitions - 1) * partition_size:])",
      "mutated_line": "partitions.append(data[(num_partitions - 1) / partition_size:])",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) / partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "partitions.append(data[(num_partitions - 1) * partition_size:])",
      "mutated_line": "partitions.append(data[num_partitions - 1 + partition_size:])",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[num_partitions - 1 + partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "partitions.append(data[(num_partitions - 1) * partition_size:])",
      "mutated_line": "partitions.append(data[(num_partitions - 1) ** partition_size:])",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) ** partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if partition and partition[0] < min_val:",
      "mutated_line": "if partition and partition[0] <= min_val:",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] <= min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if partition and partition[0] < min_val:",
      "mutated_line": "if partition and partition[0] >= min_val:",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] >= min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if partition and partition[0] < min_val:",
      "mutated_line": "if partition and partition[0] != min_val:",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] != min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "partitions[min_partition_index] = partitions[min_partition_index][1:]",
      "mutated_line": "partitions[min_partition_index] = partitions[min_partition_index][2:]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][2:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "partitions[min_partition_index] = partitions[min_partition_index][1:]",
      "mutated_line": "partitions[min_partition_index] = partitions[min_partition_index][0:]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][0:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "partitions[min_partition_index] = partitions[min_partition_index][1:]",
      "mutated_line": "partitions[min_partition_index] = partitions[min_partition_index][0:]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][0:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "partitions[min_partition_index] = partitions[min_partition_index][1:]",
      "mutated_line": "partitions[min_partition_index] = partitions[min_partition_index][-1:]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][-1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:(i - 1) * partition_size] for i in range(num_partitions - 1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i - 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:i * 1 * partition_size] for i in range(num_partitions - 1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:i * 1 * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 2)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 2)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 0)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 0)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 0)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 0)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - -1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - -1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "partitions.append(data[(num_partitions - 1) * partition_size:])",
      "mutated_line": "partitions.append(data[(num_partitions + 1) * partition_size:])",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions + 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "partitions.append(data[(num_partitions - 1) * partition_size:])",
      "mutated_line": "partitions.append(data[num_partitions * 1 * partition_size:])",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[num_partitions * 1 * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_val = partition[0]",
      "mutated_line": "min_val = partition[1]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[1]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_val = partition[0]",
      "mutated_line": "min_val = partition[-1]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[-1]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_val = partition[0]",
      "mutated_line": "min_val = partition[1]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[1]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:(i + 2) * partition_size] for i in range(num_partitions - 1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 2) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:(i + 0) * partition_size] for i in range(num_partitions - 1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 0) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:(i + 0) * partition_size] for i in range(num_partitions - 1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 0) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]",
      "mutated_line": "partitions = [data[i * partition_size:(i + -1) * partition_size] for i in range(num_partitions - 1)]",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + -1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "partitions.append(data[(num_partitions - 1) * partition_size:])",
      "mutated_line": "partitions.append(data[(num_partitions - 2) * partition_size:])",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 2) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "partitions.append(data[(num_partitions - 1) * partition_size:])",
      "mutated_line": "partitions.append(data[(num_partitions - 0) * partition_size:])",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 0) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "partitions.append(data[(num_partitions - 1) * partition_size:])",
      "mutated_line": "partitions.append(data[(num_partitions - 0) * partition_size:])",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 0) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "partitions.append(data[(num_partitions - 1) * partition_size:])",
      "mutated_line": "partitions.append(data[(num_partitions - -1) * partition_size:])",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - -1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[0] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if partition and partition[0] < min_val:",
      "mutated_line": "if partition and partition[1] < min_val:",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[1] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if partition and partition[0] < min_val:",
      "mutated_line": "if partition and partition[-1] < min_val:",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[-1] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if partition and partition[0] < min_val:",
      "mutated_line": "if partition and partition[1] < min_val:",
      "code": "def distributed_merge_sort(data, num_partitions):\n    \"\"\"\n    Sorts a massive dataset in a distributed system by dividing it into smaller partitions, \n    sorting each partition using local sorting algorithm, and then merging the sorted partitions.\n\n    Args:\n        data (list): The list of integers to be sorted.\n        num_partitions (int): The number of partitions to divide the data into.\n\n    Returns:\n        list: A single sorted list of integers.\n    \"\"\"\n    partition_size = len(data) // num_partitions\n    partitions = [data[i * partition_size:(i + 1) * partition_size] for i in range(num_partitions - 1)]\n    partitions.append(data[(num_partitions - 1) * partition_size:])\n    sorted_partitions = [sorted(partition) for partition in partitions]\n    return merge_partitions(sorted_partitions)\n\ndef merge_partitions(partitions):\n    \"\"\"\n    Merges multiple sorted partitions into a single sorted list.\n\n    Args:\n        partitions (list): A list of sorted lists to be merged.\n\n    Returns:\n        list: A single sorted list.\n    \"\"\"\n    result = []\n    while any((partition for partition in partitions)):\n        min_val = float('inf')\n        min_partition_index = -1\n        for (i, partition) in enumerate(partitions):\n            if partition and partition[1] < min_val:\n                min_val = partition[0]\n                min_partition_index = i\n        result.append(min_val)\n        partitions[min_partition_index] = partitions[min_partition_index][1:]\n    return result"
    }
  ]
}