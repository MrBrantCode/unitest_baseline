{
  "task_id": "cf_42666",
  "entry_point": "performTransformation",
  "mutant_count": 167,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "tau = 2 * math.pi",
      "mutated_line": "tau = 2 / math.pi",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 / math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "tau = 2 * math.pi",
      "mutated_line": "tau = 2 + math.pi",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 + math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "tau = 2 * math.pi",
      "mutated_line": "tau = 2 ** math.pi",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 ** math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tau = 2 * math.pi",
      "mutated_line": "tau = 3 * math.pi",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 3 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tau = 2 * math.pi",
      "mutated_line": "tau = 1 * math.pi",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 1 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tau = 2 * math.pi",
      "mutated_line": "tau = 0 * math.pi",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 0 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tau = 2 * math.pi",
      "mutated_line": "tau = 1 * math.pi",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 1 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tau = 2 * math.pi",
      "mutated_line": "tau = -2 * math.pi",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = -2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] + polar[0], center[1] - polar[1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] + polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] * polar[0], center[1] - polar[1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] * polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] - polar[0], center[1] + polar[1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] + polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] - polar[0], center[1] * polar[1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] * polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] + polar[0] * h, center[1] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] + polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] * (polar[0] * h), center[1] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] * (polar[0] * h), center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] * h, center[1] + polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] + polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] * h, center[1] * (polar[1] * h))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] * (polar[1] * h))\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a = n * tau / N",
      "mutated_line": "a = n * tau * N",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau * N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a = n * tau / N",
      "mutated_line": "a = n * tau // N",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau // N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = a - tau / N",
      "mutated_line": "b = a + tau / N",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a + tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = a - tau / N",
      "mutated_line": "b = a * (tau / N)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a * (tau / N)\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] / h, center[1] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] / h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - (polar[0] + h), center[1] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - (polar[0] + h), center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] ** h, center[1] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] ** h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] / h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] / h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] * h, center[1] - (polar[1] + h))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - (polar[1] + h))\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] ** h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] ** h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a = n * tau / N",
      "mutated_line": "a = n / tau / N",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n / tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a = n * tau / N",
      "mutated_line": "a = (n + tau) / N",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = (n + tau) / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a = n * tau / N",
      "mutated_line": "a = n ** tau / N",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n ** tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = a - tau / N",
      "mutated_line": "b = a - tau * N",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau * N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = a - tau / N",
      "mutated_line": "b = a - tau // N",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau // N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) - r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = ((cqh[0] + r1 * math.cos(a)) * (r2 * math.sin(a)), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) - r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), (cqh[1] + r1 * math.cos(a)) * (r2 * math.sin(a)))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) - r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) - r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = ((cqh[0] + r1 * math.cos(b)) * (r2 * math.sin(b)), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = ((cqh[0] + r1 * math.cos(b)) * (r2 * math.sin(b)), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) - r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) - r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), (cqh[1] + r1 * math.cos(b)) * (r2 * math.sin(b)))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), (cqh[1] + r1 * math.cos(b)) * (r2 * math.sin(b)))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) - r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) - r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = ((cqh[0] + r1 * math.cos(a)) * (r2 * math.sin(a)), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = ((cqh[0] + r1 * math.cos(a)) * (r2 * math.sin(a)), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) - r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) - r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), (cqh[1] + r1 * math.cos(a)) * (r2 * math.sin(a)))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), (cqh[1] + r1 * math.cos(a)) * (r2 * math.sin(a)))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) - r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) - r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = ((cqh[0] + r1 * math.cos(b)) * (r2 * math.sin(b)), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = ((cqh[0] + r1 * math.cos(b)) * (r2 * math.sin(b)), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) - r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) - r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), (cqh[1] + r1 * math.cos(b)) * (r2 * math.sin(b)))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), (cqh[1] + r1 * math.cos(b)) * (r2 * math.sin(b)))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[1] - polar[0], center[1] - polar[1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[1] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[-1] - polar[0], center[1] - polar[1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[-1] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[1] - polar[0], center[1] - polar[1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[1] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] - polar[1], center[1] - polar[1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[1], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] - polar[-1], center[1] - polar[1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[-1], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] - polar[1], center[1] - polar[1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[1], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] - polar[0], center[2] - polar[1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[2] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] - polar[0], center[0] - polar[1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[0] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] - polar[0], center[0] - polar[1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[0] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] - polar[0], center[-1] - polar[1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[-1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] - polar[0], center[1] - polar[2])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[2])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] - polar[0], center[1] - polar[0])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[0])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] - polar[0], center[1] - polar[0])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[0])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq1 = (center[0] - polar[0], center[1] - polar[1])",
      "mutated_line": "cq1 = (center[0] - polar[0], center[1] - polar[-1])",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[-1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[1] - polar[0] * h, center[1] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[1] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[-1] - polar[0] * h, center[1] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[-1] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[1] - polar[0] * h, center[1] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[1] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] * h, center[2] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[2] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] * h, center[0] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[0] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] * h, center[0] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[0] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] * h, center[-1] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[-1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] - r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] * (r1 * math.cos(a)) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 / math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + (r2 + math.sin(a)), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 ** math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] - r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] * (r1 * math.cos(a)) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 / math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + (r2 + math.sin(a)))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 ** math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] - r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] - r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] * (r1 * math.cos(b)) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] * (r1 * math.cos(b)) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 / math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 / math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + (r2 + math.sin(b)), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + (r2 + math.sin(b)), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 ** math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 ** math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] - r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] - r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] * (r1 * math.cos(b)) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] * (r1 * math.cos(b)) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 / math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 / math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + (r2 + math.sin(b)))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + (r2 + math.sin(b)))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 ** math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 ** math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] - r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] - r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] * (r1 * math.cos(a)) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] * (r1 * math.cos(a)) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 / math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 / math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + (r2 + math.sin(a)), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + (r2 + math.sin(a)), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 ** math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 ** math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] - r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] - r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] * (r1 * math.cos(a)) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] * (r1 * math.cos(a)) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 / math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 / math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + (r2 + math.sin(a)))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + (r2 + math.sin(a)))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 ** math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 ** math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] - r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] - r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] * (r1 * math.cos(b)) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] * (r1 * math.cos(b)) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 / math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 / math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + (r2 + math.sin(b)), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + (r2 + math.sin(b)), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 ** math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 ** math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] - r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] - r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] * (r1 * math.cos(b)) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] * (r1 * math.cos(b)) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 / math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 / math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + (r2 + math.sin(b)))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + (r2 + math.sin(b)))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 ** math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 ** math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[1] * h, center[1] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[1] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[-1] * h, center[1] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[-1] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[1] * h, center[1] - polar[1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[1] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[2] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[2] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[0] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[0] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[0] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[0] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)",
      "mutated_line": "cqh = (center[0] - polar[0] * h, center[1] - polar[-1] * h)",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[-1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 / math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + (r1 + math.cos(a)) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 ** math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 / math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + (r1 + math.cos(a)) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 ** math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 / math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 / math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + (r1 + math.cos(b)) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + (r1 + math.cos(b)) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 ** math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 ** math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 / math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 / math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + (r1 + math.cos(b)) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + (r1 + math.cos(b)) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 ** math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 ** math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 / math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 / math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + (r1 + math.cos(a)) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + (r1 + math.cos(a)) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 ** math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 ** math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 / math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 / math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + (r1 + math.cos(a)) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + (r1 + math.cos(a)) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 ** math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 ** math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 / math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 / math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + (r1 + math.cos(b)) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + (r1 + math.cos(b)) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 ** math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 ** math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 / math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 / math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + (r1 + math.cos(b)) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + (r1 + math.cos(b)) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 ** math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 ** math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[1] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[-1] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[1] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[2] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[0] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[0] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[-1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[1] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[1] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[-1] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[-1] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[1] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[1] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[2] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[2] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[0] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[0] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[0] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[0] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[-1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[-1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[1] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[1] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[-1] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[-1] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[1] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[1] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[2] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[2] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[0] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[0] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[0] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[0] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "mutated_line": "p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[-1] + r1 * math.cos(a) + r2 * math.sin(a))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[-1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[1] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[1] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[-1] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[-1] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[1] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[1] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[2] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[2] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[0] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[0] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[0] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[0] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "mutated_line": "q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[-1] + r1 * math.cos(b) + r2 * math.sin(b))",
      "code": "import math\n\ndef performTransformation(center, polar, h, N, r1, r2):\n    tau = 2 * math.pi\n    cq1 = (center[0] - polar[0], center[1] - polar[1])\n    cqh = (center[0] - polar[0] * h, center[1] - polar[1] * h)\n    transformed_points = []\n    for n in range(N):\n        a = n * tau / N\n        b = a - tau / N\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n        p = (cqh[0] + r1 * math.cos(a) + r2 * math.sin(a), cqh[1] + r1 * math.cos(a) + r2 * math.sin(a))\n        q = (cqh[0] + r1 * math.cos(b) + r2 * math.sin(b), cqh[-1] + r1 * math.cos(b) + r2 * math.sin(b))\n        transformed_points.append((p, q, cq1))\n    return transformed_points"
    }
  ]
}