{
  "task_id": "cf_39232",
  "entry_point": "opposite_hemisphere_vertices",
  "mutant_count": 34,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if dist_thresh is None:",
      "mutated_line": "dist_thresh = np.finfo(float).eps",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is not None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "opposite = False",
      "mutated_line": "opposite = True",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = True\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "equator_vertices = [v for v in vertices if v[2] == 0]",
      "mutated_line": "equator_vertices = [v for v in vertices if v[2] != 0]",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] != 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if v_dash[2] != 0:",
      "mutated_line": "if v_dash[2] == 0:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] == 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:",
      "mutated_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) < dist_thresh:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) < dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:",
      "mutated_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) > dist_thresh:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) > dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:",
      "mutated_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) == dist_thresh:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) == dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "equator_vertices = [v for v in vertices if v[2] == 0]",
      "mutated_line": "equator_vertices = [v for v in vertices if v[2] == 1]",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 1]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "equator_vertices = [v for v in vertices if v[2] == 0]",
      "mutated_line": "equator_vertices = [v for v in vertices if v[2] == -1]",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == -1]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "equator_vertices = [v for v in vertices if v[2] == 0]",
      "mutated_line": "equator_vertices = [v for v in vertices if v[2] == 1]",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 1]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v_dash[2] != 0:",
      "mutated_line": "if v_dash[2] != 1:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 1:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v_dash[2] != 0:",
      "mutated_line": "if v_dash[2] != -1:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != -1:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v_dash[2] != 0:",
      "mutated_line": "if v_dash[2] != 1:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 1:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "opposite = True",
      "mutated_line": "opposite = False",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = False\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "equator_vertices = [v for v in vertices if v[2] == 0]",
      "mutated_line": "equator_vertices = [v for v in vertices if v[3] == 0]",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[3] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "equator_vertices = [v for v in vertices if v[2] == 0]",
      "mutated_line": "equator_vertices = [v for v in vertices if v[1] == 0]",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[1] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "equator_vertices = [v for v in vertices if v[2] == 0]",
      "mutated_line": "equator_vertices = [v for v in vertices if v[0] == 0]",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[0] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "equator_vertices = [v for v in vertices if v[2] == 0]",
      "mutated_line": "equator_vertices = [v for v in vertices if v[1] == 0]",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[1] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "equator_vertices = [v for v in vertices if v[2] == 0]",
      "mutated_line": "equator_vertices = [v for v in vertices if v[-2] == 0]",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[-2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v_dash[2] != 0:",
      "mutated_line": "if v_dash[3] != 0:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[3] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v_dash[2] != 0:",
      "mutated_line": "if v_dash[1] != 0:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[1] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v_dash[2] != 0:",
      "mutated_line": "if v_dash[0] != 0:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[0] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v_dash[2] != 0:",
      "mutated_line": "if v_dash[1] != 0:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[1] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v_dash[2] != 0:",
      "mutated_line": "if v_dash[-2] != 0:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[-2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:",
      "mutated_line": "if np.linalg.norm(np.array(v) * -1 + np.array(v_dash)) <= dist_thresh:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 + np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:",
      "mutated_line": "if np.linalg.norm(np.array(v) * -1 * np.array(v_dash)) <= dist_thresh:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -1 * np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:",
      "mutated_line": "if np.linalg.norm(np.array(v) / -1 - np.array(v_dash)) <= dist_thresh:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) / -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:",
      "mutated_line": "if np.linalg.norm(np.array(v) + -1 - np.array(v_dash)) <= dist_thresh:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) + -1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:",
      "mutated_line": "if np.linalg.norm(np.array(v) ** (-1) - np.array(v_dash)) <= dist_thresh:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) ** (-1) - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:",
      "mutated_line": "if np.linalg.norm(np.array(v) * +1 - np.array(v_dash)) <= dist_thresh:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * +1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:",
      "mutated_line": "if np.linalg.norm(np.array(v) * -2 - np.array(v_dash)) <= dist_thresh:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -2 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:",
      "mutated_line": "if np.linalg.norm(np.array(v) * -0 - np.array(v_dash)) <= dist_thresh:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -0 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:",
      "mutated_line": "if np.linalg.norm(np.array(v) * -0 - np.array(v_dash)) <= dist_thresh:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * -0 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if np.linalg.norm(np.array(v) * -1 - np.array(v_dash)) <= dist_thresh:",
      "mutated_line": "if np.linalg.norm(np.array(v) * --1 - np.array(v_dash)) <= dist_thresh:",
      "code": "import numpy as np\n\ndef opposite_hemisphere_vertices(vertices, dist_thresh=None):\n    equator_vertices = [v for v in vertices if v[2] == 0]\n    if dist_thresh is None:\n        dist_thresh = np.finfo(float).eps\n    opposite_indices = []\n    for (i, v) in enumerate(equator_vertices):\n        opposite = False\n        for v_dash in vertices:\n            if v_dash[2] != 0:\n                continue\n            if np.linalg.norm(np.array(v) * --1 - np.array(v_dash)) <= dist_thresh:\n                opposite = True\n                break\n        if opposite:\n            opposite_indices.append(vertices.index(v))\n    return opposite_indices"
    }
  ]
}