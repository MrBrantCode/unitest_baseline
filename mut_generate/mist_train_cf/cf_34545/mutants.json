{
  "task_id": "cf_34545",
  "entry_point": "simulate_motion",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "V = 0.1  # Volume of the sphere in cubic meters",
      "mutated_line": "rho_f = 1000",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 1.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "V = 0.1  # Volume of the sphere in cubic meters",
      "mutated_line": "rho_f = 1000",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = -0.9\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "V = 0.1  # Volume of the sphere in cubic meters",
      "mutated_line": "rho_f = 1000",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "V = 0.1  # Volume of the sphere in cubic meters",
      "mutated_line": "rho_f = 1000",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "V = 0.1  # Volume of the sphere in cubic meters",
      "mutated_line": "rho_f = 1000",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = -0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rho_f = 1000  # Density of the fluid in kg/m^3",
      "mutated_line": "g = 9.81",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1001\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rho_f = 1000  # Density of the fluid in kg/m^3",
      "mutated_line": "g = 9.81",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 999\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rho_f = 1000  # Density of the fluid in kg/m^3",
      "mutated_line": "g = 9.81",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 0\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rho_f = 1000  # Density of the fluid in kg/m^3",
      "mutated_line": "g = 9.81",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rho_f = 1000  # Density of the fluid in kg/m^3",
      "mutated_line": "g = 9.81",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = -1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "g = 9.81  # Acceleration due to gravity in m/s^2",
      "mutated_line": "rho_s = 500",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 10.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "g = 9.81  # Acceleration due to gravity in m/s^2",
      "mutated_line": "rho_s = 500",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 8.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "g = 9.81  # Acceleration due to gravity in m/s^2",
      "mutated_line": "rho_s = 500",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 0\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "g = 9.81  # Acceleration due to gravity in m/s^2",
      "mutated_line": "rho_s = 500",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 1\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "g = 9.81  # Acceleration due to gravity in m/s^2",
      "mutated_line": "rho_s = 500",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = -9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "rho_s = 500  # Density of the sphere in kg/m^3",
      "mutated_line": "eta = 0.01",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 501\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "rho_s = 500  # Density of the sphere in kg/m^3",
      "mutated_line": "eta = 0.01",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 499\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "rho_s = 500  # Density of the sphere in kg/m^3",
      "mutated_line": "eta = 0.01",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 0\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "rho_s = 500  # Density of the sphere in kg/m^3",
      "mutated_line": "eta = 0.01",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 1\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "rho_s = 500  # Density of the sphere in kg/m^3",
      "mutated_line": "eta = 0.01",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = -500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "eta = 0.01  # Viscosity of the fluid in N*s/m^2",
      "mutated_line": "R = 0.05",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 1.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "eta = 0.01  # Viscosity of the fluid in N*s/m^2",
      "mutated_line": "R = 0.05",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = -0.99\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "eta = 0.01  # Viscosity of the fluid in N*s/m^2",
      "mutated_line": "R = 0.05",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "eta = 0.01  # Viscosity of the fluid in N*s/m^2",
      "mutated_line": "R = 0.05",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 1\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "eta = 0.01  # Viscosity of the fluid in N*s/m^2",
      "mutated_line": "R = 0.05",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = -0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "R = 0.05  # Radius of the sphere in meters",
      "mutated_line": "R = 1.05",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 1.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "R = 0.05  # Radius of the sphere in meters",
      "mutated_line": "R = -0.95",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = -0.95\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "R = 0.05  # Radius of the sphere in meters",
      "mutated_line": "R = 0",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "R = 0.05  # Radius of the sphere in meters",
      "mutated_line": "R = 1",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 1\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "R = 0.05  # Radius of the sphere in meters",
      "mutated_line": "R = -0.05",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = -0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m = V * rho_s",
      "mutated_line": "m = V / rho_s",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V / rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m = V * rho_s",
      "mutated_line": "m = V + rho_s",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V + rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m = V * rho_s",
      "mutated_line": "m = V ** rho_s",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V ** rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = -6 * math.pi * eta / R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta / R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = -6 * math.pi * eta + R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta + R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = (-6 * math.pi * eta) ** R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = (-6 * math.pi * eta) ** R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "velocity += acceleration * time_step",
      "mutated_line": "velocity -= acceleration * time_step",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity -= acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "position += velocity * time_step",
      "mutated_line": "position -= velocity * time_step",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position -= velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = -6 * math.pi / eta * R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi / eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = (-6 * math.pi + eta) * R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = (-6 * math.pi + eta) * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = (-6 * math.pi) ** eta * R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = (-6 * math.pi) ** eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for t in range(0, int(total_time / time_step)):",
      "mutated_line": "Fg = -m * g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(1, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for t in range(0, int(total_time / time_step)):",
      "mutated_line": "Fg = -m * g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(-1, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for t in range(0, int(total_time / time_step)):",
      "mutated_line": "Fg = -m * g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(1, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Fb = V * rho_f * g  # Buoyant force",
      "mutated_line": "Fb = V * rho_f / g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f / g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Fb = V * rho_f * g  # Buoyant force",
      "mutated_line": "Fb = V * rho_f + g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f + g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Fb = V * rho_f * g  # Buoyant force",
      "mutated_line": "Fb = (V * rho_f) ** g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = (V * rho_f) ** g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "Fg = -m * g  # Gravitational force",
      "mutated_line": "Fg = -m / g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m / g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "Fg = -m * g  # Gravitational force",
      "mutated_line": "Fg = -m + g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m + g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "Fg = -m * g  # Gravitational force",
      "mutated_line": "Fg = (-m) ** g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = (-m) ** g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "Fd = A * velocity  # Drag force",
      "mutated_line": "Fd = A / velocity",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A / velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "Fd = A * velocity  # Drag force",
      "mutated_line": "Fd = A + velocity",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A + velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "Fd = A * velocity  # Drag force",
      "mutated_line": "Fd = A ** velocity",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A ** velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "net_force = Fb + Fg + Fd  # Net force",
      "mutated_line": "net_force = Fb + Fg - Fd",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg - Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "net_force = Fb + Fg + Fd  # Net force",
      "mutated_line": "net_force = (Fb + Fg) * Fd",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = (Fb + Fg) * Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "acceleration = net_force / m",
      "mutated_line": "acceleration = net_force * m",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force * m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "acceleration = net_force / m",
      "mutated_line": "acceleration = net_force // m",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force // m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "velocity += acceleration * time_step",
      "mutated_line": "velocity += acceleration / time_step",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration / time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "velocity += acceleration * time_step",
      "mutated_line": "velocity += acceleration + time_step",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration + time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "velocity += acceleration * time_step",
      "mutated_line": "velocity += acceleration ** time_step",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration ** time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "position += velocity * time_step",
      "mutated_line": "position += velocity / time_step",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity / time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "position += velocity * time_step",
      "mutated_line": "position += velocity + time_step",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity + time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "position += velocity * time_step",
      "mutated_line": "position += velocity ** time_step",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity ** time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = -6 / math.pi * eta * R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 / math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = (-6 + math.pi) * eta * R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = (-6 + math.pi) * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = (-6) ** math.pi * eta * R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = (-6) ** math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for t in range(0, int(total_time / time_step)):",
      "mutated_line": "Fg = -m * g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time * time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for t in range(0, int(total_time / time_step)):",
      "mutated_line": "Fg = -m * g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time // time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Fb = V * rho_f * g  # Buoyant force",
      "mutated_line": "Fb = V / rho_f * g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V / rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Fb = V * rho_f * g  # Buoyant force",
      "mutated_line": "Fb = (V + rho_f) * g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = (V + rho_f) * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "Fb = V * rho_f * g  # Buoyant force",
      "mutated_line": "Fb = V ** rho_f * g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V ** rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "Fg = -m * g  # Gravitational force",
      "mutated_line": "Fg = +m * g",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = +m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "net_force = Fb + Fg + Fd  # Net force",
      "mutated_line": "net_force = Fb - Fg + Fd",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb - Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "net_force = Fb + Fg + Fd  # Net force",
      "mutated_line": "net_force = Fb * Fg + Fd",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb * Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = +6 * math.pi * eta * R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = +6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = -7 * math.pi * eta * R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -7 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = -5 * math.pi * eta * R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -5 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = -0 * math.pi * eta * R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -0 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = -1 * math.pi * eta * R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = -1 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "A = -6 * math.pi * eta * R",
      "mutated_line": "A = --6 * math.pi * eta * R",
      "code": "import math\n\ndef simulate_motion(initial_velocity, initial_position, time_step, total_time):\n    V = 0.1\n    rho_f = 1000\n    g = 9.81\n    rho_s = 500\n    eta = 0.01\n    R = 0.05\n    velocity = initial_velocity\n    position = initial_position\n    m = V * rho_s\n    A = --6 * math.pi * eta * R\n    positions = [position]\n    velocities = [velocity]\n    for t in range(0, int(total_time / time_step)):\n        Fb = V * rho_f * g\n        Fg = -m * g\n        Fd = A * velocity\n        net_force = Fb + Fg + Fd\n        acceleration = net_force / m\n        velocity += acceleration * time_step\n        position += velocity * time_step\n        positions.append(position)\n        velocities.append(velocity)\n    return (positions, velocities)"
    }
  ]
}