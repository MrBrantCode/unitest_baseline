{
  "task_id": "cf_31948",
  "entry_point": "navigateRobot",
  "mutant_count": 120,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): '', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): '', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): '', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): '', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): '', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): '', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): ''}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): ''}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 0 <= row < rows or 0 <= col < cols or grid[row][col] == 0",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows or 0 <= col < cols or grid[row][col] == 0\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while current != start:",
      "mutated_line": "while current == start:",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current == start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if current == end:",
      "mutated_line": "if current != end:",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current != end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(1, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(1, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(-1, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(-1, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(1, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(1, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 2): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 2): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 0): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 0): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 0): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 0): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, -1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, -1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (1, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (1, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (-1, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (-1, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (1, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (1, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, +1): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, +1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (2, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (2, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (0, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (0, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (0, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (0, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (-1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (-1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (1, 1): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 1): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (1, -1): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, -1): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (1, 1): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 1): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (+1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (+1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 1): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 1): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, -1): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, -1): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 1): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 1): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 0 < row < rows and 0 <= col < cols and (grid[row][col] == 0)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 < row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 0 > row < rows and 0 <= col < cols and (grid[row][col] == 0)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 > row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 0 == row < rows and 0 <= col < cols and (grid[row][col] == 0)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 == row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 0 <= row < rows and 0 < col < cols and (grid[row][col] == 0)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 < col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 0 <= row < rows and 0 > col < cols and (grid[row][col] == 0)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 > col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 0 <= row < rows and 0 == col < cols and (grid[row][col] == 0)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 == col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 0 <= row < rows and 0 <= col < cols and (grid[row][col] != 0)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] != 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "current = queue.pop(0)",
      "mutated_line": "current = queue.pop(1)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(1)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "current = queue.pop(0)",
      "mutated_line": "current = queue.pop(-1)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(-1)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "current = queue.pop(0)",
      "mutated_line": "current = queue.pop(1)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(1)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):",
      "mutated_line": "if (new_row, new_col) not in visited or is_valid_move(new_row, new_col):",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited or is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[1]))",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[-1]))",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[-1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[1]))",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[1]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -2): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -2): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -0): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -0): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -0): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -0): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, --1): 'left', (1, 0): 'down', (-1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, --1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-2, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-2, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-0, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-0, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-0, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-0, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "movements = { (0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up' }",
      "mutated_line": "movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (--1, 0): 'up'}",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (--1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 1 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 1 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return -1 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return -1 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 1 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 1 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 0 <= row < rows and 1 <= col < cols and (grid[row][col] == 0)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 1 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 0 <= row < rows and -1 <= col < cols and (grid[row][col] == 0)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and -1 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 0 <= row < rows and 1 <= col < cols and (grid[row][col] == 0)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 1 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 1)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 1)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == -1)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == -1)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0 <= row < rows and 0 <= col < cols and grid[row][col] == 0",
      "mutated_line": "return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 1)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 1)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "new_row, new_col = current[0] + dr, current[1] + dc",
      "mutated_line": "(new_row, new_col) = (current[0] - dr, current[1] + dc)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] - dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "new_row, new_col = current[0] + dr, current[1] + dc",
      "mutated_line": "(new_row, new_col) = (current[0] * dr, current[1] + dc)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] * dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "new_row, new_col = current[0] + dr, current[1] + dc",
      "mutated_line": "(new_row, new_col) = (current[0] + dr, current[1] - dc)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] - dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "new_row, new_col = current[0] + dr, current[1] + dc",
      "mutated_line": "(new_row, new_col) = (current[0] + dr, current[1] * dc)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] * dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):",
      "mutated_line": "if (new_row, new_col) in visited and is_valid_move(new_row, new_col):",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] + previous[0], current[1] - previous[1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] + previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] * previous[0], current[1] - previous[1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] * previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] - previous[0], current[1] + previous[1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] + previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] - previous[0], current[1] * previous[1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] * previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "new_row, new_col = current[0] + dr, current[1] + dc",
      "mutated_line": "(new_row, new_col) = (current[1] + dr, current[1] + dc)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[1] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "new_row, new_col = current[0] + dr, current[1] + dc",
      "mutated_line": "(new_row, new_col) = (current[-1] + dr, current[1] + dc)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[-1] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "new_row, new_col = current[0] + dr, current[1] + dc",
      "mutated_line": "(new_row, new_col) = (current[1] + dr, current[1] + dc)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[1] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "new_row, new_col = current[0] + dr, current[1] + dc",
      "mutated_line": "(new_row, new_col) = (current[0] + dr, current[2] + dc)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[2] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "new_row, new_col = current[0] + dr, current[1] + dc",
      "mutated_line": "(new_row, new_col) = (current[0] + dr, current[0] + dc)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[0] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "new_row, new_col = current[0] + dr, current[1] + dc",
      "mutated_line": "(new_row, new_col) = (current[0] + dr, current[0] + dc)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[0] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "new_row, new_col = current[0] + dr, current[1] + dc",
      "mutated_line": "(new_row, new_col) = (current[0] + dr, current[-1] + dc)",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[-1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[1] - previous[0], current[1] - previous[1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[1] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[-1] - previous[0], current[1] - previous[1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[-1] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[1] - previous[0], current[1] - previous[1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[1] - previous[0], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] - previous[1], current[1] - previous[1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[1], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] - previous[-1], current[1] - previous[1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[-1], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] - previous[1], current[1] - previous[1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[1], current[1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] - previous[0], current[2] - previous[1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[2] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] - previous[0], current[0] - previous[1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[0] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] - previous[0], current[0] - previous[1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[0] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] - previous[0], current[-1] - previous[1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[-1] - previous[1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] - previous[0], current[1] - previous[2]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[2]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] - previous[0], current[1] - previous[0]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[0]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] - previous[0], current[1] - previous[0]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[0]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "path.append(movements[(current[0] - previous[0], current[1] - previous[1])])",
      "mutated_line": "path.append(movements[current[0] - previous[0], current[1] - previous[-1]])",
      "code": "def navigateRobot(grid, start, end):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    movements = {(0, 1): 'right', (0, -1): 'left', (1, 0): 'down', (-1, 0): 'up'}\n\n    def is_valid_move(row, col):\n        return 0 <= row < rows and 0 <= col < cols and (grid[row][col] == 0)\n\n    def backtrack_path(parents, start, end):\n        path = []\n        current = end\n        while current != start:\n            previous = parents[current]\n            path.append(movements[current[0] - previous[0], current[1] - previous[-1]])\n            current = previous\n        return list(reversed(path))\n    queue = [start]\n    visited = set()\n    parents = {}\n    while queue:\n        current = queue.pop(0)\n        if current == end:\n            return backtrack_path(parents, start, end)\n        visited.add(current)\n        for (dr, dc) in directions:\n            (new_row, new_col) = (current[0] + dr, current[1] + dc)\n            if (new_row, new_col) not in visited and is_valid_move(new_row, new_col):\n                queue.append((new_row, new_col))\n                parents[new_row, new_col] = current\n    return []"
    }
  ]
}