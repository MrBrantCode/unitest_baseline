{
  "task_id": "cf_23242",
  "entry_point": "customSort",
  "mutant_count": 87,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def customSort(array):\n    \"\"\"\"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if low >= high:",
      "mutated_line": "if low > high:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low > high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if low >= high:",
      "mutated_line": "if low < high:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low < high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if low >= high:",
      "mutated_line": "if low == high:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low == high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "highEq = pivotIndex + 1",
      "mutated_line": "highEq = pivotIndex - 1",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex - 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "highEq = pivotIndex + 1",
      "mutated_line": "highEq = pivotIndex * 1",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex * 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if low < lowEq - 1:",
      "mutated_line": "if low <= lowEq - 1:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low <= lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if low < lowEq - 1:",
      "mutated_line": "if low >= lowEq - 1:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low >= lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if low < lowEq - 1:",
      "mutated_line": "if low != lowEq - 1:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low != lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if highEq < high:",
      "mutated_line": "if highEq <= high:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq <= high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if highEq < high:",
      "mutated_line": "if highEq >= high:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq >= high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if highEq < high:",
      "mutated_line": "if highEq != high:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq != high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(0, len(array) - 1)]",
      "mutated_line": "stack = [(1, len(array) - 1)]",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(1, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(0, len(array) - 1)]",
      "mutated_line": "stack = [(-1, len(array) - 1)]",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(-1, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(0, len(array) - 1)]",
      "mutated_line": "stack = [(1, len(array) - 1)]",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(1, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "stack = [(0, len(array) - 1)]",
      "mutated_line": "stack = [(0, len(array) + 1)]",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) + 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "stack = [(0, len(array) - 1)]",
      "mutated_line": "stack = [(0, len(array) * 1)]",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) * 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if array[i] > pivot:",
      "mutated_line": "if array[i] >= pivot:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] >= pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if array[i] > pivot:",
      "mutated_line": "if array[i] <= pivot:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] <= pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if array[i] > pivot:",
      "mutated_line": "if array[i] != pivot:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] != pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "pivotIndex += 1",
      "mutated_line": "pivotIndex -= 1",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex -= 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "highEq = pivotIndex + 1",
      "mutated_line": "highEq = pivotIndex + 2",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 2\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "highEq = pivotIndex + 1",
      "mutated_line": "highEq = pivotIndex + 0",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 0\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "highEq = pivotIndex + 1",
      "mutated_line": "highEq = pivotIndex + 0",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 0\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "highEq = pivotIndex + 1",
      "mutated_line": "highEq = pivotIndex + -1",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + -1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex + 1, low - 1, -1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex + 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex * 1, low - 1, -1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex * 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - 1, low + 1, -1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low + 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - 1, low * 1, -1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low * 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - 1, low - 1, +1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, +1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if array[i] == pivot:",
      "mutated_line": "if array[i] != pivot:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] != pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "lowEq -= 1",
      "mutated_line": "lowEq += 1",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq += 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "for i in range(pivotIndex + 2, high + 1):",
      "mutated_line": "for i in range(pivotIndex - 2, high + 1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex - 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "for i in range(pivotIndex + 2, high + 1):",
      "mutated_line": "for i in range(pivotIndex * 2, high + 1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex * 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "for i in range(pivotIndex + 2, high + 1):",
      "mutated_line": "for i in range(pivotIndex + 2, high - 1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high - 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "for i in range(pivotIndex + 2, high + 1):",
      "mutated_line": "for i in range(pivotIndex + 2, high * 1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high * 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if array[i] == pivot:",
      "mutated_line": "if array[i] != pivot:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] != pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "highEq += 1",
      "mutated_line": "highEq -= 1",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq -= 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "if low < lowEq - 1:",
      "mutated_line": "if low < lowEq + 1:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq + 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "if low < lowEq - 1:",
      "mutated_line": "if low < lowEq * 1:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq * 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(0, len(array) - 1)]",
      "mutated_line": "stack = [(0, len(array) - 2)]",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 2)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(0, len(array) - 1)]",
      "mutated_line": "stack = [(0, len(array) - 0)]",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 0)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(0, len(array) - 1)]",
      "mutated_line": "stack = [(0, len(array) - 0)]",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 0)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(0, len(array) - 1)]",
      "mutated_line": "stack = [(0, len(array) - -1)]",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - -1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pivotIndex += 1",
      "mutated_line": "pivotIndex += 2",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 2\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pivotIndex += 1",
      "mutated_line": "pivotIndex += 0",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 0\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pivotIndex += 1",
      "mutated_line": "pivotIndex += 0",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 0\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pivotIndex += 1",
      "mutated_line": "pivotIndex += -1",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += -1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - 2, low - 1, -1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 2, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - 0, low - 1, -1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 0, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - 0, low - 1, -1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 0, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - -1, low - 1, -1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - -1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - 1, low - 2, -1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 2, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - 1, low - 0, -1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 0, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - 1, low - 0, -1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 0, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - 1, low - -1, -1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - -1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - 1, low - 1, -2):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -2):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - 1, low - 1, -0):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -0):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - 1, low - 1, -0):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -0):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(pivotIndex - 1, low - 1, -1):",
      "mutated_line": "for i in range(pivotIndex - 1, low - 1, --1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, --1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "lowEq -= 1",
      "mutated_line": "lowEq -= 2",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 2\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "lowEq -= 1",
      "mutated_line": "lowEq -= 0",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 0\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "lowEq -= 1",
      "mutated_line": "lowEq -= 0",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 0\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "lowEq -= 1",
      "mutated_line": "lowEq -= -1",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= -1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(pivotIndex + 2, high + 1):",
      "mutated_line": "for i in range(pivotIndex + 3, high + 1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 3, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(pivotIndex + 2, high + 1):",
      "mutated_line": "for i in range(pivotIndex + 1, high + 1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 1, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(pivotIndex + 2, high + 1):",
      "mutated_line": "for i in range(pivotIndex + 0, high + 1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 0, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(pivotIndex + 2, high + 1):",
      "mutated_line": "for i in range(pivotIndex + 1, high + 1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 1, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(pivotIndex + 2, high + 1):",
      "mutated_line": "for i in range(pivotIndex + -2, high + 1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + -2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(pivotIndex + 2, high + 1):",
      "mutated_line": "for i in range(pivotIndex + 2, high + 2):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 2):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(pivotIndex + 2, high + 1):",
      "mutated_line": "for i in range(pivotIndex + 2, high + 0):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 0):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(pivotIndex + 2, high + 1):",
      "mutated_line": "for i in range(pivotIndex + 2, high + 0):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 0):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(pivotIndex + 2, high + 1):",
      "mutated_line": "for i in range(pivotIndex + 2, high + -1):",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + -1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "highEq += 1",
      "mutated_line": "highEq += 2",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 2\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "highEq += 1",
      "mutated_line": "highEq += 0",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 0\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "highEq += 1",
      "mutated_line": "highEq += 0",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 0\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "highEq += 1",
      "mutated_line": "highEq += -1",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += -1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if low < lowEq - 1:",
      "mutated_line": "if low < lowEq - 2:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 2:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if low < lowEq - 1:",
      "mutated_line": "if low < lowEq - 0:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 0:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if low < lowEq - 1:",
      "mutated_line": "if low < lowEq - 0:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 0:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if low < lowEq - 1:",
      "mutated_line": "if low < lowEq - -1:",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - -1:\n            stack.append((low, lowEq - 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "stack.append((low, lowEq - 1))",
      "mutated_line": "stack.append((low, lowEq + 1))",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq + 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "stack.append((low, lowEq - 1))",
      "mutated_line": "stack.append((low, lowEq * 1))",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq * 1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "stack.append((low, lowEq - 1))",
      "mutated_line": "stack.append((low, lowEq - 2))",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 2))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "stack.append((low, lowEq - 1))",
      "mutated_line": "stack.append((low, lowEq - 0))",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 0))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "stack.append((low, lowEq - 1))",
      "mutated_line": "stack.append((low, lowEq - 0))",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - 0))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "stack.append((low, lowEq - 1))",
      "mutated_line": "stack.append((low, lowEq - -1))",
      "code": "def customSort(array):\n    \"\"\"\n    Sorts a list of integers in descending order using a modified version of the quicksort algorithm.\n\n    This algorithm handles duplicates and ensures stability, preserving the relative order of equal elements.\n    It uses an iterative approach instead of recursion with a space complexity of O(log n).\n\n    Args:\n        array (list): A list of integers to be sorted.\n\n    Returns:\n        list: The sorted list of integers in descending order.\n    \"\"\"\n    stack = [(0, len(array) - 1)]\n    while stack:\n        (low, high) = stack.pop()\n        if low >= high:\n            continue\n        pivot = array[high]\n        pivotIndex = low\n        for i in range(low, high):\n            if array[i] > pivot:\n                (array[pivotIndex], array[i]) = (array[i], array[pivotIndex])\n                pivotIndex += 1\n        (array[pivotIndex], array[high]) = (array[high], array[pivotIndex])\n        lowEq = pivotIndex\n        highEq = pivotIndex + 1\n        for i in range(pivotIndex - 1, low - 1, -1):\n            if array[i] == pivot:\n                (array[lowEq], array[i]) = (array[i], array[lowEq])\n                lowEq -= 1\n        for i in range(pivotIndex + 2, high + 1):\n            if array[i] == pivot:\n                (array[highEq], array[i]) = (array[i], array[highEq])\n                highEq += 1\n        if low < lowEq - 1:\n            stack.append((low, lowEq - -1))\n        if highEq < high:\n            stack.append((highEq, high))\n    return array"
    }
  ]
}