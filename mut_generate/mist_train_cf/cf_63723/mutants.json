{
  "task_id": "cf_63723",
  "entry_point": "intToRoman",
  "mutant_count": 86,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "roman = \"\"",
      "mutated_line": "break",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = 'MUTATED'\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "roman += symbol * count",
      "mutated_line": "roman -= symbol * count",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman -= symbol * count\n    return roman"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if num == 0: break",
      "mutated_line": "(count, num) = divmod(num, value)",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num != 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "roman += symbol * count",
      "mutated_line": "roman += symbol / count",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol / count\n    return roman"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "roman += symbol * count",
      "mutated_line": "roman += symbol + count",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol + count\n    return roman"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "roman += symbol * count",
      "mutated_line": "roman += symbol ** count",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol ** count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1001, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1001, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(999, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(999, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(0, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(0, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(-1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(-1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, ''), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, ''), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (901, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (901, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (899, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (899, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (0, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (0, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (1, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (1, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (-900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (-900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (900, ''), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, ''), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (900, 'CM'), (501, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (501, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (900, 'CM'), (499, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (499, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (900, 'CM'), (0, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (0, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (900, 'CM'), (1, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (1, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (900, 'CM'), (-500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (-500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, ''), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, ''), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (401, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (401, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (399, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (399, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (0, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (0, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (1, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (1, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (-400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (-400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),",
      "mutated_line": "lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, ''), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, ''), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (101, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (99, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (0, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (1, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (-100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, ''), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (91, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (89, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (0, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (1, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (-90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, ''), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (51, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (49, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (0, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (1, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (-50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, ''), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (41, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (39, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (0, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (1, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (-40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),",
      "mutated_line": "roman = ''",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, ''), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (11, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (9, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (0, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (1, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (-10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, ''), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (10, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (8, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (0, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (1, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (-9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, ''), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (6, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (4, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (0, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (1, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (-5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, ''), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (5, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (3, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (0, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (1, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (-4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, ''), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (2, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (0, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (0, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (-1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]",
      "mutated_line": "for (value, symbol) in lookup:",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, '')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 0:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num == 0: break",
      "mutated_line": "(count, num) = divmod(num, value)",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 1:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num == 0: break",
      "mutated_line": "(count, num) = divmod(num, value)",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == -1:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num == 0: break",
      "mutated_line": "(count, num) = divmod(num, value)",
      "code": "def intToRoman(num: int) -> str:\n    lookup = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    roman = ''\n    for (value, symbol) in lookup:\n        if num == 1:\n            break\n        (count, num) = divmod(num, value)\n        roman += symbol * count\n    return roman"
    }
  ]
}