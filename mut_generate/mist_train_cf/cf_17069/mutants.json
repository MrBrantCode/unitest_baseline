{
  "task_id": "cf_17069",
  "entry_point": "combine_and_sort_lists",
  "mutant_count": 22,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=False)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=False)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 == 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 == 0], key=lambda pair: pair[0] + pair[1], reverse=True)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] - pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] - pair[1], reverse=True)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] * pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] * pair[1], reverse=True)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x * 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x * 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x + 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x + 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 1], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 1], key=lambda pair: pair[0] + pair[1], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != -1], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != -1], key=lambda pair: pair[0] + pair[1], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 1], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 1], key=lambda pair: pair[0] + pair[1], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 4 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 4 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 2 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 2 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 0 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 0 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 1 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 1 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % -3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % -3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[1] + pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[1] + pair[1], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[-1] + pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[-1] + pair[1], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[1] + pair[1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[1] + pair[1], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[2], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[2], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[0], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[0], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[0], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[0], reverse=True)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sorted([(x, y) for x, y in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[1], reverse=True)",
      "mutated_line": "return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[-1], reverse=True)",
      "code": "def combine_and_sort_lists(list1, list2):\n    \"\"\"\n    Combine two lists by index, excluding values from list1 that are divisible by 3,\n    and sort the resulting list in descending order based on the sum of each pair of values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list where each element is a tuple containing one element from each input list.\n    \"\"\"\n    return sorted([(x, y) for (x, y) in zip(list1, list2) if x % 3 != 0], key=lambda pair: pair[0] + pair[-1], reverse=True)"
    }
  ]
}