{
  "task_id": "cf_70720",
  "entry_point": "parse_music",
  "mutant_count": 50,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def parse_music(music_string: str, tempo_multiplier: float = 1.0) -> Tuple[List[float], int]:",
      "mutated_line": "def parse_music(music_string: str, tempo_multiplier: float=2.0) -> Tuple[List[float], int]:",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=2.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def parse_music(music_string: str, tempo_multiplier: float = 1.0) -> Tuple[List[float], int]:",
      "mutated_line": "def parse_music(music_string: str, tempo_multiplier: float=0.0) -> Tuple[List[float], int]:",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=0.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def parse_music(music_string: str, tempo_multiplier: float = 1.0) -> Tuple[List[float], int]:",
      "mutated_line": "def parse_music(music_string: str, tempo_multiplier: float=0) -> Tuple[List[float], int]:",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def parse_music(music_string: str, tempo_multiplier: float = 1.0) -> Tuple[List[float], int]:",
      "mutated_line": "def parse_music(music_string: str, tempo_multiplier: float=-1.0) -> Tuple[List[float], int]:",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=-1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "measure = 1 #start with 1 measure",
      "mutated_line": "measure = 2",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 2\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "measure = 1 #start with 1 measure",
      "mutated_line": "measure = 0",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 0\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "measure = 1 #start with 1 measure",
      "mutated_line": "measure = 0",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 0\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "measure = 1 #start with 1 measure",
      "mutated_line": "measure = -1",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = -1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "total_duration = 0.0",
      "mutated_line": "total_duration = 1.0",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 1.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "total_duration = 0.0",
      "mutated_line": "total_duration = -1.0",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = -1.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "total_duration = 0.0",
      "mutated_line": "total_duration = 1",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 1\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "total_duration += note_duration",
      "mutated_line": "total_duration -= note_duration",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration -= note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'': 1.0, 'o|': 0.5, '.|': 0.25}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 1.0, '': 0.5, '.|': 0.25}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, '': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 1.0, 'o|': 0.5, '': 0.25}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 2.0, 'o|': 0.5, '.|': 0.25}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 2.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 0.0, 'o|': 0.5, '.|': 0.25}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 0.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 0, 'o|': 0.5, '.|': 0.25}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': -1.0, 'o|': 0.5, '.|': 0.25}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': -1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 1.0, 'o|': 1.5, '.|': 0.25}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 1.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 1.0, 'o|': -0.5, '.|': 0.25}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': -0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 1.0, 'o|': 0, '.|': 0.25}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 1.0, 'o|': 1, '.|': 0.25}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 1, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 1.0, 'o|': -0.5, '.|': 0.25}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': -0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 1.0, 'o|': 0.5, '.|': 1.25}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 1.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 1.0, 'o|': 0.5, '.|': -0.75}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': -0.75}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 1.0, 'o|': 0.5, '.|': 0}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 1.0, 'o|': 0.5, '.|': 1}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 1}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "notes = { 'o': 1.0, 'o|': 0.5, '.|' : 0.25 }",
      "mutated_line": "notes = {'o': 1.0, 'o|': 0.5, '.|': -0.25}",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': -0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "note_duration = notes.get(note) * tempo_multiplier # duration of each note",
      "mutated_line": "note_duration = notes.get(note) / tempo_multiplier",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) / tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "note_duration = notes.get(note) * tempo_multiplier # duration of each note",
      "mutated_line": "note_duration = notes.get(note) + tempo_multiplier",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) + tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "note_duration = notes.get(note) * tempo_multiplier # duration of each note",
      "mutated_line": "note_duration = notes.get(note) ** tempo_multiplier",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) ** tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if total_duration > 1.0:",
      "mutated_line": "if total_duration >= 1.0:",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration >= 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if total_duration > 1.0:",
      "mutated_line": "if total_duration <= 1.0:",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration <= 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if total_duration > 1.0:",
      "mutated_line": "if total_duration != 1.0:",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration != 1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "measure += 1",
      "mutated_line": "measure -= 1",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure -= 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "total_duration -= 1.0",
      "mutated_line": "total_duration += 1.0",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration += 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if total_duration > 1.0:",
      "mutated_line": "if total_duration > 2.0:",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 2.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if total_duration > 1.0:",
      "mutated_line": "if total_duration > 0.0:",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 0.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if total_duration > 1.0:",
      "mutated_line": "if total_duration > 0:",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if total_duration > 1.0:",
      "mutated_line": "if total_duration > -1.0:",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > -1.0:\n            measure += 1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "measure += 1",
      "mutated_line": "measure += 2",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 2\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "measure += 1",
      "mutated_line": "measure += 0",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 0\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "measure += 1",
      "mutated_line": "measure += 0",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 0\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "measure += 1",
      "mutated_line": "measure += -1",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += -1\n            total_duration -= 1.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "total_duration -= 1.0",
      "mutated_line": "total_duration -= 2.0",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 2.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "total_duration -= 1.0",
      "mutated_line": "total_duration -= 0.0",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 0.0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "total_duration -= 1.0",
      "mutated_line": "total_duration -= 0",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= 0\n    return (note_dur, measure)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "total_duration -= 1.0",
      "mutated_line": "total_duration -= -1.0",
      "code": "from typing import Tuple, List\n\ndef parse_music(music_string: str, tempo_multiplier: float=1.0) -> Tuple[List[float], int]:\n    \"\"\"\n    This function interprets the music_string as a sequence of musical notes in a specific ASCII format,\n    where 'o' represents a whole note (1 beat), 'o|' represents a half note (0.5 beats), and '.|' represents a quarter note (0.25 beats).\n    The tempo_multiplier adjusts the beats per measure for each note.\n    The function returns a tuple containing a list of fractional values representing the duration of each note in beats per measure,\n    and an integer representing the total number of measures.\n    The cumulative beats in any measure should not exceed 1; if it does, the measure should be divided into multiple measures.\n    \"\"\"\n    notes = {'o': 1.0, 'o|': 0.5, '.|': 0.25}\n    note_dur = []\n    measure = 1\n    total_duration = 0.0\n    for note in music_string.split():\n        note_duration = notes.get(note) * tempo_multiplier\n        note_dur.append(note_duration)\n        total_duration += note_duration\n        if total_duration > 1.0:\n            measure += 1\n            total_duration -= -1.0\n    return (note_dur, measure)"
    }
  ]
}