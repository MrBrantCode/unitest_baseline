{
  "task_id": "cf_20043",
  "entry_point": "format_ip_addresses",
  "mutant_count": 34,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 ** (32 - cidr_notation) + 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) + 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 ** (32 - cidr_notation) * 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) * 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 * (32 - cidr_notation) - 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 * (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 + (32 - cidr_notation) - 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 + (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 ** (32 - cidr_notation) - 3",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 3\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 ** (32 - cidr_notation) - 1",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 1\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 ** (32 - cidr_notation) - 0",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 0\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 ** (32 - cidr_notation) - 1",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 1\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 ** (32 - cidr_notation) - -2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - -2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ip_obj = ipaddress.ip_network(f\"{ip}/{prefix_length}\", strict=False)",
      "mutated_line": "ip_obj = ipaddress.ip_network(f'{ip}{prefix_length}', strict=False)",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ip_obj = ipaddress.ip_network(f\"{ip}/{prefix_length}\", strict=False)",
      "mutated_line": "ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=True)",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=True)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 3 ** (32 - cidr_notation) - 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 3 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 1 ** (32 - cidr_notation) - 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 1 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 0 ** (32 - cidr_notation) - 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 0 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 1 ** (32 - cidr_notation) - 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 1 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = -2 ** (32 - cidr_notation) - 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = -2 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 ** (32 + cidr_notation) - 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 + cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 ** (32 * cidr_notation) - 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 * cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 ** (33 - cidr_notation) - 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (33 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 ** (31 - cidr_notation) - 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (31 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 ** (0 - cidr_notation) - 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (0 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 ** (1 - cidr_notation) - 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (1 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "host_addresses = 2 ** (32 - cidr_notation) - 2",
      "mutated_line": "host_addresses = 2 ** (-32 - cidr_notation) - 2",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (-32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "formatted_ips.append(f\"IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n\")",
      "mutated_line": "formatted_ips.append(f'{ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'{ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "formatted_ips.append(f\"IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n\")",
      "mutated_line": "formatted_ips.append(f'IP Address: {ip}{network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}{network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "formatted_ips.append(f\"IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n\")",
      "mutated_line": "formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}{subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}{subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "formatted_ips.append(f\"IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n\")",
      "mutated_line": "formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "formatted_ips.append(f\"IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n\")",
      "mutated_line": "formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}{host_addresses}\\n')",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}{host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "formatted_ips.append(f\"IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n\")",
      "mutated_line": "formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}')",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "formatted_ips.append(f\"Invalid IP Address: {ip}. It is not a private IP address.\\n\")",
      "mutated_line": "formatted_ips.append(f'{ip}. It is not a private IP address.\\n')",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'{ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "formatted_ips.append(f\"Invalid IP Address: {ip}. It is not a private IP address.\\n\")",
      "mutated_line": "formatted_ips.append(f'Invalid IP Address: {ip}')",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "formatted_ips.append(f\"Invalid IP Address: {ip}\\n\")",
      "mutated_line": "formatted_ips.append(f'{ip}\\n')",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'{ip}\\n')\n    return formatted_ips"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "formatted_ips.append(f\"Invalid IP Address: {ip}\\n\")",
      "mutated_line": "formatted_ips.append(f'Invalid IP Address: {ip}')",
      "code": "import ipaddress\n\ndef format_ip_addresses(ip_addresses, prefix_length):\n    \"\"\"\n    Formats a list of IP addresses and calculates their corresponding network address, \n    subnet mask in CIDR notation, and the number of possible host addresses.\n\n    Args:\n        ip_addresses (list): A list of IP addresses.\n        prefix_length (int): The desired network prefix length.\n\n    Returns:\n        list: A list of strings containing the formatted IP addresses.\n    \"\"\"\n    formatted_ips = []\n    for ip in ip_addresses:\n        try:\n            ip_obj = ipaddress.ip_network(f'{ip}/{prefix_length}', strict=False)\n            network_address = ip_obj.network_address\n            subnet_mask = ip_obj.netmask\n            cidr_notation = ip_obj.prefixlen\n            host_addresses = 2 ** (32 - cidr_notation) - 2\n            if ipaddress.ip_address(ip).is_private:\n                formatted_ips.append(f'IP Address: {ip}\\nNetwork Address: {network_address}\\nSubnet Mask: {subnet_mask}\\nCIDR Notation: /{cidr_notation}\\nNumber of Host Addresses: {host_addresses}\\n')\n            else:\n                formatted_ips.append(f'Invalid IP Address: {ip}. It is not a private IP address.\\n')\n        except ValueError:\n            formatted_ips.append(f'Invalid IP Address: {ip}')\n    return formatted_ips"
    }
  ]
}