{
  "task_id": "cf_12011",
  "entry_point": "find_max_overlapping_events",
  "mutant_count": 43,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "maxOverlap = 0",
      "mutated_line": "maxOverlap = 1",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 1\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "maxOverlap = 0",
      "mutated_line": "maxOverlap = -1",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = -1\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "maxOverlap = 0",
      "mutated_line": "maxOverlap = 1",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 1\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "currentOverlap = 0",
      "mutated_line": "currentOverlap = 1",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 1\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "currentOverlap = 0",
      "mutated_line": "currentOverlap = -1",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = -1\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "currentOverlap = 0",
      "mutated_line": "currentOverlap = 1",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 1\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if currentOverlap > maxOverlap:",
      "mutated_line": "if currentOverlap >= maxOverlap:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap >= maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if currentOverlap > maxOverlap:",
      "mutated_line": "if currentOverlap <= maxOverlap:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap <= maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if currentOverlap > maxOverlap:",
      "mutated_line": "if currentOverlap != maxOverlap:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap != maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "currentOverlap = 1",
      "mutated_line": "currentOverlap = 2",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 2\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "currentOverlap = 1",
      "mutated_line": "currentOverlap = 0",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 0\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "currentOverlap = 1",
      "mutated_line": "currentOverlap = 0",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 0\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "currentOverlap = 1",
      "mutated_line": "currentOverlap = -1",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = -1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[0] < overlappingIntervalsStack[-1][1]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] < overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[0] > overlappingIntervalsStack[-1][1]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] > overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[0] == overlappingIntervalsStack[-1][1]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] == overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "currentOverlap += 1",
      "mutated_line": "currentOverlap -= 1",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap -= 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "currentOverlap += 1",
      "mutated_line": "currentOverlap += 2",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 2\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "currentOverlap += 1",
      "mutated_line": "currentOverlap += 0",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 0\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "currentOverlap += 1",
      "mutated_line": "currentOverlap += 0",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 0\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "currentOverlap += 1",
      "mutated_line": "currentOverlap += -1",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += -1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if currentOverlap > maxOverlap:",
      "mutated_line": "if currentOverlap >= maxOverlap:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap >= maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if currentOverlap > maxOverlap:",
      "mutated_line": "if currentOverlap <= maxOverlap:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap <= maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if currentOverlap > maxOverlap:",
      "mutated_line": "if currentOverlap != maxOverlap:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap != maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "currentOverlap = 1",
      "mutated_line": "currentOverlap = 2",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 2\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "currentOverlap = 1",
      "mutated_line": "currentOverlap = 0",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 0\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "currentOverlap = 1",
      "mutated_line": "currentOverlap = 0",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 0\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "currentOverlap = 1",
      "mutated_line": "currentOverlap = -1",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = -1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: x[0])",
      "mutated_line": "intervals.sort(key=lambda x: x[1])",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[1])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: x[0])",
      "mutated_line": "intervals.sort(key=lambda x: x[-1])",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[-1])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: x[0])",
      "mutated_line": "intervals.sort(key=lambda x: x[1])",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[1])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[1] <= overlappingIntervalsStack[-1][1]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[1] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[-1] <= overlappingIntervalsStack[-1][1]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[-1] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[1] <= overlappingIntervalsStack[-1][1]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[1] <= overlappingIntervalsStack[-1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[0] <= overlappingIntervalsStack[-1][2]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][2]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[0] <= overlappingIntervalsStack[-1][0]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][0]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[0] <= overlappingIntervalsStack[-1][0]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][0]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[0] <= overlappingIntervalsStack[-1][-1]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-1][-1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[0] <= overlappingIntervalsStack[+1][1]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[+1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[0] <= overlappingIntervalsStack[-2][1]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-2][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[0] <= overlappingIntervalsStack[-0][1]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-0][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[0] <= overlappingIntervalsStack[-0][1]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[-0][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif interval[0] <= overlappingIntervalsStack[-1][1]:",
      "mutated_line": "elif interval[0] <= overlappingIntervalsStack[--1][1]:",
      "code": "def find_max_overlapping_events(intervals):\n    intervals.sort(key=lambda x: x[0])\n    maxOverlap = 0\n    currentOverlap = 0\n    maxOverlappingIntervals = []\n    overlappingIntervalsStack = []\n    for interval in intervals:\n        if not overlappingIntervalsStack:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n        elif interval[0] <= overlappingIntervalsStack[--1][1]:\n            overlappingIntervalsStack.append(interval)\n            currentOverlap += 1\n        else:\n            if currentOverlap > maxOverlap:\n                maxOverlap = currentOverlap\n                maxOverlappingIntervals = overlappingIntervalsStack.copy()\n            overlappingIntervalsStack.clear()\n            overlappingIntervalsStack.append(interval)\n            currentOverlap = 1\n    if currentOverlap > maxOverlap:\n        maxOverlap = currentOverlap\n        maxOverlappingIntervals = overlappingIntervalsStack.copy()\n    return (maxOverlap, maxOverlappingIntervals)"
    }
  ]
}