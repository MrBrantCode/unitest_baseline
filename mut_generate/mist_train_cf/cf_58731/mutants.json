{
  "task_id": "cf_58731",
  "entry_point": "tsp",
  "mutant_count": 71,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def tsp(dist):\n    \"\"\"\"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for subset in range(1, 1 << n):",
      "mutated_line": "for subset in range(2, 1 << n):",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(2, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for subset in range(1, 1 << n):",
      "mutated_line": "for subset in range(0, 1 << n):",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(0, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for subset in range(1, 1 << n):",
      "mutated_line": "for subset in range(0, 1 << n):",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(0, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for subset in range(1, 1 << n):",
      "mutated_line": "for subset in range(-1, 1 << n):",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(-1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result = float('inf')",
      "mutated_line": "result = float('')",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for a in range(1, n):",
      "mutated_line": "for a in range(2, n):",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(2, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for a in range(1, n):",
      "mutated_line": "for a in range(0, n):",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(0, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for a in range(1, n):",
      "mutated_line": "for a in range(0, n):",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(0, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for a in range(1, n):",
      "mutated_line": "for a in range(-1, n):",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(-1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]",
      "mutated_line": "memo = [[[float('inf')] / (1 << n) for _ in range(n)] for _ in range(n)]",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] / (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]",
      "mutated_line": "memo = [[[float('inf')] + (1 << n) for _ in range(n)] for _ in range(n)]",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] + (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]",
      "mutated_line": "memo = [[[float('inf')] ** (1 << n) for _ in range(n)] for _ in range(n)]",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] ** (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for subset in range(1, 1 << n):",
      "mutated_line": "for subset in range(1, 2 << n):",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 2 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for subset in range(1, 1 << n):",
      "mutated_line": "for subset in range(1, 0 << n):",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 0 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for subset in range(1, 1 << n):",
      "mutated_line": "for subset in range(1, 0 << n):",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 0 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for subset in range(1, 1 << n):",
      "mutated_line": "for subset in range(1, -1 << n):",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, -1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(1 << n) - 1] - dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] - dist[a][0])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(1 << n) - 1] * dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] * dist[a][0])\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if ((subset >> b) & 1) == 0:",
      "mutated_line": "if subset >> b & 1 != 0:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 != 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]",
      "mutated_line": "memo = [[[float('inf')] * (2 << n) for _ in range(n)] for _ in range(n)]",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (2 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]",
      "mutated_line": "memo = [[[float('inf')] * (0 << n) for _ in range(n)] for _ in range(n)]",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (0 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]",
      "mutated_line": "memo = [[[float('inf')] * (0 << n) for _ in range(n)] for _ in range(n)]",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (0 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]",
      "mutated_line": "memo = [[[float('inf')] * (-1 << n) for _ in range(n)] for _ in range(n)]",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (-1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo[a][b][1 << b] = dist[a][b]",
      "mutated_line": "memo[a][b][2 << b] = dist[a][b]",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][2 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo[a][b][1 << b] = dist[a][b]",
      "mutated_line": "memo[a][b][0 << b] = dist[a][b]",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][0 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo[a][b][1 << b] = dist[a][b]",
      "mutated_line": "memo[a][b][0 << b] = dist[a][b]",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][0 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo[a][b][1 << b] = dist[a][b]",
      "mutated_line": "memo[a][b][-1 << b] = dist[a][b]",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][-1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if ((subset >> b) & 1) == 0:",
      "mutated_line": "if subset >> b | 1 == 0:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b | 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ((subset >> b) & 1) == 0:",
      "mutated_line": "if subset >> b & 1 == 1:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 1:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ((subset >> b) & 1) == 0:",
      "mutated_line": "if subset >> b & 1 == -1:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == -1:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ((subset >> b) & 1) == 0:",
      "mutated_line": "if subset >> b & 1 == 1:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 1:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if a == c or ((subset >> c) & 1) == 0:",
      "mutated_line": "if a == c and subset >> c & 1 == 0:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c and subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "subset_without_b = subset ^ (1 << b)",
      "mutated_line": "subset_without_b = subset | 1 << b",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset | 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(1 << n) + 1] + dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) + 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(1 << n) * 1] + dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) * 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][1])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][-1])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][-1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][1])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]",
      "mutated_line": "memo = [[[float('')] * (1 << n) for _ in range(n)] for _ in range(n)]",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ((subset >> b) & 1) == 0:",
      "mutated_line": "if subset >> b & 2 == 0:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 2 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ((subset >> b) & 1) == 0:",
      "mutated_line": "if subset >> b & 0 == 0:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 0 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ((subset >> b) & 1) == 0:",
      "mutated_line": "if subset >> b & 0 == 0:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 0 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if ((subset >> b) & 1) == 0:",
      "mutated_line": "if subset >> b & -1 == 0:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & -1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if a == c or ((subset >> c) & 1) == 0:",
      "mutated_line": "if a != c or subset >> c & 1 == 0:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a != c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if a == c or ((subset >> c) & 1) == 0:",
      "mutated_line": "if a == c or subset >> c & 1 != 0:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 != 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])",
      "mutated_line": "memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] - dist[c][b])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] - dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])",
      "mutated_line": "memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] * dist[c][b])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] * dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][1][(1 << n) - 1] + dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][1][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][-1][(1 << n) - 1] + dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][-1][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][1][(1 << n) - 1] + dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][1][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(1 << n) - 2] + dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 2] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(1 << n) - 0] + dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 0] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(1 << n) - 0] + dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 0] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(1 << n) - -1] + dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - -1] + dist[a][0])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if a == c or ((subset >> c) & 1) == 0:",
      "mutated_line": "if a == c or subset >> c | 1 == 0:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c | 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if a == c or ((subset >> c) & 1) == 0:",
      "mutated_line": "if a == c or subset >> c & 1 == 1:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 1:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if a == c or ((subset >> c) & 1) == 0:",
      "mutated_line": "if a == c or subset >> c & 1 == -1:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == -1:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if a == c or ((subset >> c) & 1) == 0:",
      "mutated_line": "if a == c or subset >> c & 1 == 1:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 1:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "subset_without_b = subset ^ (1 << b)",
      "mutated_line": "subset_without_b = subset ^ 2 << b",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 2 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "subset_without_b = subset ^ (1 << b)",
      "mutated_line": "subset_without_b = subset ^ 0 << b",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 0 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "subset_without_b = subset ^ (1 << b)",
      "mutated_line": "subset_without_b = subset ^ 0 << b",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 0 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "subset_without_b = subset ^ (1 << b)",
      "mutated_line": "subset_without_b = subset ^ -1 << b",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ -1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(2 << n) - 1] + dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(2 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(0 << n) - 1] + dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(0 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(0 << n) - 1] + dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(0 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])",
      "mutated_line": "result = min(result, memo[a][0][(-1 << n) - 1] + dist[a][0])",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(-1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if a == c or ((subset >> c) & 1) == 0:",
      "mutated_line": "if a == c or subset >> c & 2 == 0:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 2 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if a == c or ((subset >> c) & 1) == 0:",
      "mutated_line": "if a == c or subset >> c & 0 == 0:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 0 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if a == c or ((subset >> c) & 1) == 0:",
      "mutated_line": "if a == c or subset >> c & 0 == 0:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & 0 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if a == c or ((subset >> c) & 1) == 0:",
      "mutated_line": "if a == c or subset >> c & -1 == 0:",
      "code": "def tsp(dist):\n    \"\"\"\n    Solves the Traveling Salesman Problem using the Held-Karp algorithm.\n\n    Args:\n    dist (list of lists): A weighted adjacency matrix of size n x n, where n is the number of cities.\n    \n    Returns:\n    The minimum cost for the salesman to visit all cities and return to the starting city.\n    \"\"\"\n    n = len(dist)\n    memo = [[[float('inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    for a in range(n):\n        for b in range(n):\n            memo[a][b][1 << b] = dist[a][b]\n    for subset in range(1, 1 << n):\n        for a in range(n):\n            for b in range(n):\n                if subset >> b & 1 == 0:\n                    continue\n                for c in range(n):\n                    if a == c or subset >> c & -1 == 0:\n                        continue\n                    subset_without_b = subset ^ 1 << b\n                    memo[a][b][subset] = min(memo[a][b][subset], memo[a][c][subset_without_b] + dist[c][b])\n    result = float('inf')\n    for a in range(1, n):\n        result = min(result, memo[a][0][(1 << n) - 1] + dist[a][0])\n    return result"
    }
  ]
}