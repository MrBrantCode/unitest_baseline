{
  "task_id": "cf_51094",
  "entry_point": "median",
  "mutant_count": 59,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if length % 2 == 1:",
      "mutated_line": "if length % 2 != 1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 != 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 and num < -max_heap[0]:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 and num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) >= len(min_heap) + 1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) >= len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) <= len(min_heap) + 1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) <= len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) != len(min_heap) + 1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) != len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(min_heap) > len(max_heap):",
      "mutated_line": "if len(min_heap) >= len(max_heap):",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) >= len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(min_heap) > len(max_heap):",
      "mutated_line": "if len(min_heap) <= len(max_heap):",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) <= len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(min_heap) > len(max_heap):",
      "mutated_line": "if len(min_heap) != len(max_heap):",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) != len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if length % 2 == 1:",
      "mutated_line": "if length * 2 == 1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length * 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if length % 2 == 1:",
      "mutated_line": "if length + 2 == 1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length + 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if length % 2 == 1:",
      "mutated_line": "if length % 2 == 2:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 2:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if length % 2 == 1:",
      "mutated_line": "if length % 2 == 0:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 0:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if length % 2 == 1:",
      "mutated_line": "if length % 2 == 0:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 0:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if length % 2 == 1:",
      "mutated_line": "if length % 2 == -1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == -1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "return -max_heap[0]",
      "mutated_line": "return +max_heap[0]",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return +max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) * 2",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) * 2"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) // 2",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) // 2"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) != 0 or num < -max_heap[0]:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) != 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 or num <= -max_heap[0]:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num <= -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 or num >= -max_heap[0]:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num >= -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 or num != -max_heap[0]:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num != -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) > len(min_heap) - 1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) - 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) > len(min_heap) * 1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) * 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if length % 2 == 1:",
      "mutated_line": "if length % 3 == 1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 3 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if length % 2 == 1:",
      "mutated_line": "if length % 1 == 1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 1 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if length % 2 == 1:",
      "mutated_line": "if length % 0 == 1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 0 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if length % 2 == 1:",
      "mutated_line": "if length % 1 == 1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 1 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if length % 2 == 1:",
      "mutated_line": "if length % -2 == 1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % -2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] - min_heap[0]) / 2",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] - min_heap[0]) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return -max_heap[0] * min_heap[0] / 2",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return -max_heap[0] * min_heap[0] / 2"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / 3",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 3"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / 1",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / 0",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / 1",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[0]) / -2",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / -2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 1 or num < -max_heap[0]:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 1 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == -1 or num < -max_heap[0]:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == -1 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 1 or num < -max_heap[0]:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 1 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 or num < +max_heap[0]:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < +max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "heapq.heappush(max_heap, -num)",
      "mutated_line": "heapq.heappush(max_heap, +num)",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, +num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) > len(min_heap) + 2:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 2:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) > len(min_heap) + 0:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 0:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) > len(min_heap) + 0:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 0:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if len(max_heap) > len(min_heap) + 1:",
      "mutated_line": "if len(max_heap) > len(min_heap) + -1:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + -1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "heapq.heappush(min_heap, -heapq.heappop(max_heap))",
      "mutated_line": "heapq.heappush(min_heap, +heapq.heappop(max_heap))",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, +heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "heapq.heappush(max_heap, -heapq.heappop(min_heap))",
      "mutated_line": "heapq.heappush(max_heap, +heapq.heappop(min_heap))",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, +heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -max_heap[0]",
      "mutated_line": "return -max_heap[1]",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[1]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -max_heap[0]",
      "mutated_line": "return -max_heap[-1]",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[-1]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -max_heap[0]",
      "mutated_line": "return -max_heap[1]",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[1]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (+max_heap[0] + min_heap[0]) / 2",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (+max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[1]) / 2",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[1]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[-1]) / 2",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[-1]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[0] + min_heap[1]) / 2",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[1]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 or num < -max_heap[1]:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[1]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 or num < -max_heap[-1]:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[-1]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(max_heap) == 0 or num < -max_heap[0]:",
      "mutated_line": "if len(max_heap) == 0 or num < -max_heap[1]:",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[1]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[0] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[1] + min_heap[0]) / 2",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[1] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[-1] + min_heap[0]) / 2",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[-1] + min_heap[0]) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (-max_heap[0] + min_heap[0]) / 2",
      "mutated_line": "return (-max_heap[1] + min_heap[0]) / 2",
      "code": "import heapq\n\ndef median(lst: list):\n    max_heap = []\n    min_heap = []\n    length = len(lst)\n    for num in lst:\n        if len(max_heap) == 0 or num < -max_heap[0]:\n            heapq.heappush(max_heap, -num)\n        else:\n            heapq.heappush(min_heap, num)\n        if len(max_heap) > len(min_heap) + 1:\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n        if len(min_heap) > len(max_heap):\n            heapq.heappush(max_heap, -heapq.heappop(min_heap))\n    if length % 2 == 1:\n        return -max_heap[0]\n    else:\n        return (-max_heap[1] + min_heap[0]) / 2"
    }
  ]
}