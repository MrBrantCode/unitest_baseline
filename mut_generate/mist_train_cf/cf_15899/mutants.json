{
  "task_id": "cf_15899",
  "entry_point": "find_shortest_path",
  "mutant_count": 139,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist[tuple(start)] = 0",
      "mutated_line": "dist[tuple(start)] = 1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 1\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist[tuple(start)] = 0",
      "mutated_line": "dist[tuple(start)] = -1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = -1\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist[tuple(start)] = 0",
      "mutated_line": "dist[tuple(start)] = 1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 1\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 53,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return +1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if current == end:",
      "mutated_line": "if current != end:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current != end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if current_dist > dist[tuple(current)]:",
      "mutated_line": "if current_dist >= dist[tuple(current)]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist >= dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if current_dist > dist[tuple(current)]:",
      "mutated_line": "if current_dist <= dist[tuple(current)]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist <= dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if current_dist > dist[tuple(current)]:",
      "mutated_line": "if current_dist != dist[tuple(current)]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist != dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(-1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(-1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(1, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 2), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 2), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 0), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, -1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, -1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (-1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (-1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (1, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, +1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, +1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (2, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (2, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (0, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (-1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (-1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (+1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (+1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (2, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (2, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 2), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 2), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, -1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, -1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (+1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (+1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, +1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, +1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (2, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (2, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (0, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (-1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (-1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, +1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, +1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (+1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (+1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 2)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 2)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 0)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, -1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, -1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "mutated_line": "dist = {(i, j): float('') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pq = [(0, start)]",
      "mutated_line": "pq = [(1, start)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(1, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pq = [(0, start)]",
      "mutated_line": "pq = [(-1, start)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(-1, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pq = [(0, start)]",
      "mutated_line": "pq = [(1, start)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(1, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[0] < len(matrix) or 0 <= neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) or 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -2), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -2), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -0), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, --1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, --1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-2, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-2, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (--1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (--1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-2, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-2, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-0, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (--1, -1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (--1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -2), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -2), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -0), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, --1), (1, -1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, --1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -2), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -2), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -0), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, --1), (-1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, --1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-2, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-2, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-0, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]",
      "mutated_line": "movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (--1, 1)]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (--1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] - movement[0], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] - movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] * movement[0], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] * movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] + movement[0], current[1] - movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] - movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] + movement[0], current[1] * movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] * movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 < neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 < neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 > neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 > neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 == neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 == neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[0] < len(matrix) and 0 < neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 < neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[0] < len(matrix) and 0 > neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 > neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[0] < len(matrix) and 0 == neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 == neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]",
      "mutated_line": "new_dist = current_dist - matrix[neighbor[0]][neighbor[1]]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist - matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]",
      "mutated_line": "new_dist = current_dist * matrix[neighbor[0]][neighbor[1]]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist * matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if new_dist < dist[neighbor]:",
      "mutated_line": "if new_dist <= dist[neighbor]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist <= dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if new_dist < dist[neighbor]:",
      "mutated_line": "if new_dist >= dist[neighbor]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist >= dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if new_dist < dist[neighbor]:",
      "mutated_line": "if new_dist != dist[neighbor]:",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist != dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 1 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 1 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if -1 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if -1 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 1 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 1 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[0] < len(matrix) and 1 <= neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 1 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[0] < len(matrix) and -1 <= neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and -1 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[0] < len(matrix) and 1 <= neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 1 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "mutated_line": "dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[1]))}",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[1]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "mutated_line": "dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[-1]))}",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[-1]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}",
      "mutated_line": "dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[1]))}",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[1]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[1] + movement[0], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[1] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[-1] + movement[0], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[-1] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[1] + movement[0], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[1] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] + movement[1], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[1], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] + movement[-1], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[-1], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] + movement[1], current[1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[1], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] + movement[0], current[2] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[2] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] + movement[0], current[0] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[0] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] + movement[0], current[0] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[0] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] + movement[0], current[-1] + movement[1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[-1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] + movement[0], current[1] + movement[2])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[2])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] + movement[0], current[1] + movement[0])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[0])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] + movement[0], current[1] + movement[0])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[0])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor = (current[0] + movement[0], current[1] + movement[1])",
      "mutated_line": "neighbor = (current[0] + movement[0], current[1] + movement[-1])",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[-1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[1] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[1] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[-1] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[-1] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[1] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[1] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[2] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[2] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[0] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[0] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[0] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[0] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[-1] < len(matrix[0]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[-1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[1]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[1]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[-1]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[-1]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):",
      "mutated_line": "if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[1]):",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[1]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]",
      "mutated_line": "new_dist = current_dist + matrix[neighbor[0]][neighbor[2]]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[2]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]",
      "mutated_line": "new_dist = current_dist + matrix[neighbor[0]][neighbor[0]]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[0]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]",
      "mutated_line": "new_dist = current_dist + matrix[neighbor[0]][neighbor[0]]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[0]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]",
      "mutated_line": "new_dist = current_dist + matrix[neighbor[0]][neighbor[-1]]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[0]][neighbor[-1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]",
      "mutated_line": "new_dist = current_dist + matrix[neighbor[1]][neighbor[1]]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[1]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]",
      "mutated_line": "new_dist = current_dist + matrix[neighbor[-1]][neighbor[1]]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[-1]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "new_dist = current_dist + matrix[neighbor[0]][neighbor[1]]",
      "mutated_line": "new_dist = current_dist + matrix[neighbor[1]][neighbor[1]]",
      "code": "import heapq\n\ndef find_shortest_path(matrix, start, end):\n    \"\"\"\n    This function finds the shortest path distance between two points in a 2D matrix using Dijkstra's algorithm.\n    \n    Args:\n    matrix (list of lists): A 2D list representing the weights of the edges.\n    start (list): A list of two integers representing the start point.\n    end (list): A list of two integers representing the end point.\n    \n    Returns:\n    int: The shortest path distance between the start and end points. Returns -1 if there's no valid path.\n    \"\"\"\n    movements = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}\n    dist[tuple(start)] = 0\n    pq = [(0, start)]\n    while pq:\n        (current_dist, current) = heapq.heappop(pq)\n        if current == end:\n            return current_dist\n        if current_dist > dist[tuple(current)]:\n            continue\n        for movement in movements:\n            neighbor = (current[0] + movement[0], current[1] + movement[1])\n            if 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]):\n                new_dist = current_dist + matrix[neighbor[1]][neighbor[1]]\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, list(neighbor)))\n    return -1"
    }
  ]
}