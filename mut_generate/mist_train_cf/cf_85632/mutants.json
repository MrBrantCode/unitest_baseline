{
  "task_id": "cf_85632",
  "entry_point": "find_divisible_pair",
  "mutant_count": 35,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for j in range(i + 1, len(digits)):",
      "mutated_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i - 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for j in range(i + 1, len(digits)):",
      "mutated_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i * 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and digits[i] // digits[j] == quotient:",
      "mutated_line": "if digits[j] != 0 or digits[i] % digits[j] == 0 or digits[i] // digits[j] == quotient:",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 or digits[i] % digits[j] == 0 or digits[i] // digits[j] == quotient:\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(i + 1, len(digits)):",
      "mutated_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 2, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(i + 1, len(digits)):",
      "mutated_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 0, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(i + 1, len(digits)):",
      "mutated_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 0, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(i + 1, len(digits)):",
      "mutated_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + -1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and digits[i] // digits[j] == quotient:",
      "mutated_line": "if digits[j] == 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] == 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and digits[i] // digits[j] == quotient:",
      "mutated_line": "if digits[j] != 0 and digits[i] % digits[j] != 0 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] != 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and digits[i] // digits[j] == quotient:",
      "mutated_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] != quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] != quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and digits[j] // digits[i] == quotient:",
      "mutated_line": "elif digits[i] != 0 or digits[j] % digits[i] == 0 or digits[j] // digits[i] == quotient:",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 or digits[j] % digits[i] == 0 or digits[j] // digits[i] == quotient:\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and digits[i] // digits[j] == quotient:",
      "mutated_line": "if digits[j] != 1 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 1 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and digits[i] // digits[j] == quotient:",
      "mutated_line": "if digits[j] != -1 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != -1 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and digits[i] // digits[j] == quotient:",
      "mutated_line": "if digits[j] != 1 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 1 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and digits[i] // digits[j] == quotient:",
      "mutated_line": "if digits[j] != 0 and digits[i] * digits[j] == 0 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] * digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and digits[i] // digits[j] == quotient:",
      "mutated_line": "if digits[j] != 0 and digits[i] + digits[j] == 0 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] + digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and digits[i] // digits[j] == quotient:",
      "mutated_line": "if digits[j] != 0 and digits[i] % digits[j] == 1 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 1 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and digits[i] // digits[j] == quotient:",
      "mutated_line": "if digits[j] != 0 and digits[i] % digits[j] == -1 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == -1 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and digits[i] // digits[j] == quotient:",
      "mutated_line": "if digits[j] != 0 and digits[i] % digits[j] == 1 and (digits[i] // digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 1 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and digits[i] // digits[j] == quotient:",
      "mutated_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] / digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] / digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and digits[i] // digits[j] == quotient:",
      "mutated_line": "if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] * digits[j] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] * digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and digits[j] // digits[i] == quotient:",
      "mutated_line": "elif digits[i] == 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] == 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and digits[j] // digits[i] == quotient:",
      "mutated_line": "elif digits[i] != 0 and digits[j] % digits[i] != 0 and (digits[j] // digits[i] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] != 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and digits[j] // digits[i] == quotient:",
      "mutated_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] != quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] != quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and digits[j] // digits[i] == quotient:",
      "mutated_line": "elif digits[i] != 1 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 1 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and digits[j] // digits[i] == quotient:",
      "mutated_line": "elif digits[i] != -1 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != -1 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and digits[j] // digits[i] == quotient:",
      "mutated_line": "elif digits[i] != 1 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 1 and digits[j] % digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and digits[j] // digits[i] == quotient:",
      "mutated_line": "elif digits[i] != 0 and digits[j] * digits[i] == 0 and (digits[j] // digits[i] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] * digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and digits[j] // digits[i] == quotient:",
      "mutated_line": "elif digits[i] != 0 and digits[j] + digits[i] == 0 and (digits[j] // digits[i] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] + digits[i] == 0 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and digits[j] // digits[i] == quotient:",
      "mutated_line": "elif digits[i] != 0 and digits[j] % digits[i] == 1 and (digits[j] // digits[i] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 1 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and digits[j] // digits[i] == quotient:",
      "mutated_line": "elif digits[i] != 0 and digits[j] % digits[i] == -1 and (digits[j] // digits[i] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == -1 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and digits[j] // digits[i] == quotient:",
      "mutated_line": "elif digits[i] != 0 and digits[j] % digits[i] == 1 and (digits[j] // digits[i] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 1 and (digits[j] // digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and digits[j] // digits[i] == quotient:",
      "mutated_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] / digits[i] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] / digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and digits[j] // digits[i] == quotient:",
      "mutated_line": "elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] * digits[i] == quotient):",
      "code": "def find_divisible_pair(digits, quotient):\n    \"\"\"\n    This function takes a list of decimal digits and a quotient as input.\n    It returns a pair of unique digits from the list such that the division of one digit by the other equals the given quotient.\n    If no such pair exists, the function returns None.\n    \"\"\"\n    digits.sort()\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[j] != 0 and digits[i] % digits[j] == 0 and (digits[i] // digits[j] == quotient):\n                return (digits[i], digits[j])\n            elif digits[i] != 0 and digits[j] % digits[i] == 0 and (digits[j] * digits[i] == quotient):\n                return (digits[j], digits[i])\n    return None"
    }
  ]
}