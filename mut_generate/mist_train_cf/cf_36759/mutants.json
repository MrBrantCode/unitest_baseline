{
  "task_id": "cf_36759",
  "entry_point": "handlePawnMoves",
  "mutant_count": 74,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 4,
      "original_line": "if piece.color == game_state.current_player and piece.type == 'pawn':",
      "mutated_line": "if piece.color == game_state.current_player or piece.type == 'pawn':",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player or piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if piece.color == game_state.current_player and piece.type == 'pawn':",
      "mutated_line": "if piece.color != game_state.current_player and piece.type == 'pawn':",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color != game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if piece.color == game_state.current_player and piece.type == 'pawn':",
      "mutated_line": "if piece.color == game_state.current_player and piece.type != 'pawn':",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type != 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if game_state.board[i + piece.direction] == 0:",
      "mutated_line": "if game_state.board[i + piece.direction] != 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] != 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if square == ep_square:",
      "mutated_line": "if square != ep_square:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square != ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if piece.color == game_state.current_player and piece.type == 'pawn':",
      "mutated_line": "if piece.color == game_state.current_player and piece.type == '':",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == '':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if game_state.board[i + piece.direction] == 0:",
      "mutated_line": "if game_state.board[i + piece.direction] == 1:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 1:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if game_state.board[i + piece.direction] == 0:",
      "mutated_line": "if game_state.board[i + piece.direction] == -1:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == -1:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if game_state.board[i + piece.direction] == 0:",
      "mutated_line": "if game_state.board[i + piece.direction] == 1:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 1:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) or game_state.board[i + 2 * piece.direction] == 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) or game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for j in [i - 1, i + 1]:",
      "mutated_line": "for j in [i + 1, i + 1]:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i + 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for j in [i - 1, i + 1]:",
      "mutated_line": "for j in [i * 1, i + 1]:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i * 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for j in [i - 1, i + 1]:",
      "mutated_line": "for j in [i - 1, i - 1]:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i - 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for j in [i - 1, i + 1]:",
      "mutated_line": "for j in [i - 1, i * 1]:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i * 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if game_state.board[j] != 0 and game_state.board[j].color != piece.color:",
      "mutated_line": "if game_state.board[j] != 0 or game_state.board[j].color != piece.color:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 or game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if piece.is_promotion_rank(i + piece.direction):",
      "mutated_line": "if piece.is_promotion_rank(i - piece.direction):",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i - piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if piece.is_promotion_rank(i + piece.direction):",
      "mutated_line": "if piece.is_promotion_rank(i * piece.direction):",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i * piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if game_state.board[i + piece.direction] == 0:",
      "mutated_line": "if game_state.board[i - piece.direction] == 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i - piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if game_state.board[i + piece.direction] == 0:",
      "mutated_line": "if game_state.board[i * piece.direction] == 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i * piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i - piece.direction, 0, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i - piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i * piece.direction, 0, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i * piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i + piece.direction, 1, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 1, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i + piece.direction, -1, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, -1, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i + piece.direction, 1, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 1, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i + piece.direction, 0, value, True)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, True)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] != 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] != 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in [i - 1, i + 1]:",
      "mutated_line": "for j in [i - 2, i + 1]:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 2, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in [i - 1, i + 1]:",
      "mutated_line": "for j in [i - 0, i + 1]:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 0, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in [i - 1, i + 1]:",
      "mutated_line": "for j in [i - 0, i + 1]:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 0, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in [i - 1, i + 1]:",
      "mutated_line": "for j in [i - -1, i + 1]:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - -1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in [i - 1, i + 1]:",
      "mutated_line": "for j in [i - 1, i + 2]:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 2]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in [i - 1, i + 1]:",
      "mutated_line": "for j in [i - 1, i + 0]:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 0]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in [i - 1, i + 1]:",
      "mutated_line": "for j in [i - 1, i + 0]:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 0]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in [i - 1, i + 1]:",
      "mutated_line": "for j in [i - 1, i + -1]:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + -1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if game_state.board[j] != 0 and game_state.board[j].color != piece.color:",
      "mutated_line": "if game_state.board[j] == 0 and game_state.board[j].color != piece.color:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] == 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if game_state.board[j] != 0 and game_state.board[j].color != piece.color:",
      "mutated_line": "if game_state.board[j] != 0 and game_state.board[j].color == piece.color:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color == piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, True)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, True)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for promotion_type in ['queen', 'rook', 'bishop', 'knight']:",
      "mutated_line": "for promotion_type in ['', 'rook', 'bishop', 'knight']:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for promotion_type in ['queen', 'rook', 'bishop', 'knight']:",
      "mutated_line": "for promotion_type in ['queen', '', 'bishop', 'knight']:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', '', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for promotion_type in ['queen', 'rook', 'bishop', 'knight']:",
      "mutated_line": "for promotion_type in ['queen', 'rook', '', 'knight']:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', '', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for promotion_type in ['queen', 'rook', 'bishop', 'knight']:",
      "mutated_line": "for promotion_type in ['queen', 'rook', 'bishop', '']:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', '']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 1:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 1:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == -1:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == -1:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 1:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 1:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i - 2 * piece.direction, BITS_PAWN_START, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i - 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i * (2 * piece.direction), BITS_PAWN_START, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i * (2 * piece.direction), BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, True)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, True)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if game_state.board[j] != 0 and game_state.board[j].color != piece.color:",
      "mutated_line": "if game_state.board[j] != 1 and game_state.board[j].color != piece.color:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 1 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if game_state.board[j] != 0 and game_state.board[j].color != piece.color:",
      "mutated_line": "if game_state.board[j] != -1 and game_state.board[j].color != piece.color:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != -1 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if game_state.board[j] != 0 and game_state.board[j].color != piece.color:",
      "mutated_line": "if game_state.board[j] != 1 and game_state.board[j].color != piece.color:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 1 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)",
      "mutated_line": "addPawnMove(moves, piece, i, j, 1, piece_attacks[game_state.board[j]], False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 1, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)",
      "mutated_line": "addPawnMove(moves, piece, i, j, -1, piece_attacks[game_state.board[j]], False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, -1, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)",
      "mutated_line": "addPawnMove(moves, piece, i, j, 1, piece_attacks[game_state.board[j]], False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 1, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)",
      "mutated_line": "addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], True)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], True)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)",
      "mutated_line": "addPawnMove(moves, piece, i, i - piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i - piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)",
      "mutated_line": "addPawnMove(moves, piece, i, i * piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i * piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) and game_state.board[i - 2 * piece.direction] == 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i - 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) and game_state.board[i * (2 * piece.direction)] == 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i * (2 * piece.direction)] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i + 2 / piece.direction, BITS_PAWN_START, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 / piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i + (2 + piece.direction), BITS_PAWN_START, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + (2 + piece.direction), BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i + 2 ** piece.direction, BITS_PAWN_START, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 ** piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) and game_state.board[i + 2 / piece.direction] == 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 / piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) and game_state.board[i + (2 + piece.direction)] == 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + (2 + piece.direction)] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) and game_state.board[i + 2 ** piece.direction] == 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 ** piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i + 3 * piece.direction, BITS_PAWN_START, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 3 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i + 1 * piece.direction, BITS_PAWN_START, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 1 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i + 0 * piece.direction, BITS_PAWN_START, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 0 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i + 1 * piece.direction, BITS_PAWN_START, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 1 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)",
      "mutated_line": "addPawnMove(moves, piece, i, i + -2 * piece.direction, BITS_PAWN_START, value, False)",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + -2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) and game_state.board[i + 3 * piece.direction] == 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 3 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) and game_state.board[i + 1 * piece.direction] == 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 1 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) and game_state.board[i + 0 * piece.direction] == 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 0 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) and game_state.board[i + 1 * piece.direction] == 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + 1 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if piece.is_starting_position(i) and game_state.board[i + 2 * piece.direction] == 0:",
      "mutated_line": "if piece.is_starting_position(i) and game_state.board[i + -2 * piece.direction] == 0:",
      "code": "def handlePawnMoves(game_state, defenses, piece_attacks, ep_square):\n    moves = []\n    for (square, piece) in game_state.board.items():\n        if piece.color == game_state.current_player and piece.type == 'pawn':\n            i = square.index\n            value = piece_attacks[piece]\n            if game_state.board[i + piece.direction] == 0:\n                addPawnMove(moves, piece, i, i + piece.direction, 0, value, False)\n                if piece.is_starting_position(i) and game_state.board[i + -2 * piece.direction] == 0:\n                    addPawnMove(moves, piece, i, i + 2 * piece.direction, BITS_PAWN_START, value, False)\n            for j in [i - 1, i + 1]:\n                if game_state.board[j] != 0 and game_state.board[j].color != piece.color:\n                    addPawnMove(moves, piece, i, j, 0, piece_attacks[game_state.board[j]], False)\n            if square == ep_square:\n                addPawnMove(moves, piece, i, ep_square, BITS_EN_PASSANT, value, False)\n            if piece.is_promotion_rank(i + piece.direction):\n                for promotion_type in ['queen', 'rook', 'bishop', 'knight']:\n                    addPawnMove(moves, piece, i, i + piece.direction, BITS_PROMOTION, piece_attacks[promotion_type], promotion_type)\n    return moves"
    }
  ]
}