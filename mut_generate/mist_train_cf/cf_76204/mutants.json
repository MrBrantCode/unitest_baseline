{
  "task_id": "cf_76204",
  "entry_point": "exchange",
  "mutant_count": 56,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):",
      "mutated_line": "return 'NO'",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) == sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return \"YES\"",
      "mutated_line": "return ''",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "\"\"\"Check if a number is prime.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n < 2:",
      "mutated_line": "if n <= 2:",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n <= 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n < 2:",
      "mutated_line": "if n >= 2:",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n >= 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n < 2:",
      "mutated_line": "if n != 2:",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n != 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return False\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return \"NO\"",
      "mutated_line": "return ''",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return ''\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 3:",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 3:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 1:",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 0:",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 0:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 1:",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n < 2:",
      "mutated_line": "if n < -2:",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < -2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return True\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(3, int(n ** 0.5) + 1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(3, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(1, int(n ** 0.5) + 1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(0, int(n ** 0.5) + 1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(0, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(1, int(n ** 0.5) + 1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(-2, int(n ** 0.5) + 1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(-2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(2, int(n ** 0.5) - 1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) - 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(2, int(n ** 0.5) * 1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) * 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i != 0:",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i != 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return \"NO\"",
      "mutated_line": "return ''",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return ''\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):",
      "mutated_line": "return 'NO'",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 - primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):",
      "mutated_line": "return 'NO'",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum((nonprimes1 + primes1 + nonprimes2) * primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):",
      "mutated_line": "return 'NO'",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 - lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):",
      "mutated_line": "return 'NO'",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 * lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(2, int(n ** 0.5) + 2):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 2):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(2, int(n ** 0.5) + 0):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 0):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(2, int(n ** 0.5) + 0):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 0):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(2, int(n ** 0.5) + -1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + -1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n * i == 0:",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n * i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n + i == 0:",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n + i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == 1:",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 1:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == -1:",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == -1:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == 1:",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 1:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return True\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "replaceable = [(i, prime) for i, prime in enumerate(primes2) if prime > nonprime]",
      "mutated_line": "replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime >= nonprime]",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime >= nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "replaceable = [(i, prime) for i, prime in enumerate(primes2) if prime > nonprime]",
      "mutated_line": "replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime <= nonprime]",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime <= nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "replaceable = [(i, prime) for i, prime in enumerate(primes2) if prime > nonprime]",
      "mutated_line": "replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime != nonprime]",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime != nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):",
      "mutated_line": "return 'NO'",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 - nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):",
      "mutated_line": "return 'NO'",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum((nonprimes1 + primes1) * nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(2, int(n * 0.5) + 1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n * 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(2, int(n + 0.5) + 1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n + 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):",
      "mutated_line": "return 'NO'",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 - primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):",
      "mutated_line": "return 'NO'",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 * primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(2, int(n ** 1.5) + 1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 1.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(2, int(n ** -0.5) + 1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** -0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(2, int(n ** 0) + 1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(2, int(n ** 1) + 1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 1) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, int(n**0.5) + 1):",
      "mutated_line": "for i in range(2, int(n ** -0.5) + 1):",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** -0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i, prime = min(replaceable, key = lambda x: x[1])",
      "mutated_line": "(i, prime) = min(replaceable, key=lambda x: x[2])",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[2])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i, prime = min(replaceable, key = lambda x: x[1])",
      "mutated_line": "(i, prime) = min(replaceable, key=lambda x: x[0])",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[0])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i, prime = min(replaceable, key = lambda x: x[1])",
      "mutated_line": "(i, prime) = min(replaceable, key=lambda x: x[0])",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[0])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i, prime = min(replaceable, key = lambda x: x[1])",
      "mutated_line": "(i, prime) = min(replaceable, key=lambda x: x[-1])",
      "code": "def exchange(lst1, lst2):\n    \"\"\"\n    Check if swapping an arbitrary number of elements between the two lists would make \n    the first list have only prime numbers while keeping the total sum across both lists intact. \n    A swap must maintain the original sequence of the items in their individual lists.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Check if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    (primes1, nonprimes1) = ([n for n in lst1 if is_prime(n)], [n for n in lst1 if not is_prime(n)])\n    (primes2, nonprimes2) = ([n for n in lst2 if is_prime(n)], [n for n in lst2 if not is_prime(n)])\n    for nonprime in nonprimes1:\n        replaceable = [(i, prime) for (i, prime) in enumerate(primes2) if prime > nonprime]\n        if replaceable:\n            (i, prime) = min(replaceable, key=lambda x: x[-1])\n            nonprimes2.append(nonprime)\n            primes2.pop(i)\n        else:\n            return 'NO'\n    if sum(nonprimes1 + primes1 + nonprimes2 + primes2) != sum(lst1 + lst2):\n        return 'NO'\n    return 'YES'"
    }
  ]
}