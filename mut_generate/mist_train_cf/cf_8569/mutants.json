{
  "task_id": "cf_8569",
  "entry_point": "compile_code",
  "mutant_count": 31,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "if isinstance(node, ast.FunctionDef) and len(node.body) > 10:",
      "mutated_line": "if isinstance(node, ast.FunctionDef) or len(node.body) > 10:",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) or len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):",
      "mutated_line": "errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) or isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if isinstance(node, ast.FunctionDef) and len(node.body) > 10:",
      "mutated_line": "if isinstance(node, ast.FunctionDef) and len(node.body) >= 10:",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) >= 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if isinstance(node, ast.FunctionDef) and len(node.body) > 10:",
      "mutated_line": "if isinstance(node, ast.FunctionDef) and len(node.body) <= 10:",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) <= 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if isinstance(node, ast.FunctionDef) and len(node.body) > 10:",
      "mutated_line": "if isinstance(node, ast.FunctionDef) and len(node.body) != 10:",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) != 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if isinstance(node, ast.FunctionDef) and len(node.body) > 10:",
      "mutated_line": "if isinstance(node, ast.FunctionDef) and len(node.body) > 11:",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 11:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if isinstance(node, ast.FunctionDef) and len(node.body) > 10:",
      "mutated_line": "if isinstance(node, ast.FunctionDef) and len(node.body) > 9:",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 9:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if isinstance(node, ast.FunctionDef) and len(node.body) > 10:",
      "mutated_line": "if isinstance(node, ast.FunctionDef) and len(node.body) > 0:",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 0:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if isinstance(node, ast.FunctionDef) and len(node.body) > 10:",
      "mutated_line": "if isinstance(node, ast.FunctionDef) and len(node.body) > 1:",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 1:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if isinstance(node, ast.FunctionDef) and len(node.body) > 10:",
      "mutated_line": "if isinstance(node, ast.FunctionDef) and len(node.body) > -10:",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > -10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "errors.append(f\"Syntax error at line {e.lineno}, column {e.offset}: {e.text}\")",
      "mutated_line": "errors.append(f'{e.lineno}, column {e.offset}: {e.text}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'{e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "errors.append(f\"Syntax error at line {e.lineno}, column {e.offset}: {e.text}\")",
      "mutated_line": "errors.append(f'Syntax error at line {e.lineno}{e.offset}: {e.text}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}{e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "errors.append(f\"Syntax error at line {e.lineno}, column {e.offset}: {e.text}\")",
      "mutated_line": "errors.append(f'Syntax error at line {e.lineno}, column {e.offset}{e.text}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}{e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:",
      "mutated_line": "if arg.arg in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "errors.append(f\"Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines\")",
      "mutated_line": "errors.append(f'{node.lineno}: long function {node.name} with {len(node.body)} lines')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'{node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "errors.append(f\"Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines\")",
      "mutated_line": "errors.append(f'Code smell at line {node.lineno}{node.name} with {len(node.body)} lines')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}{node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "errors.append(f\"Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines\")",
      "mutated_line": "errors.append(f'Code smell at line {node.lineno}: long function {node.name}{len(node.body)} lines')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name}{len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "errors.append(f\"Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines\")",
      "mutated_line": "errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)}')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):",
      "mutated_line": "errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[1], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):",
      "mutated_line": "errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[-1], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):",
      "mutated_line": "errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[1], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "errors.append(f\"Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}\")",
      "mutated_line": "errors.append(f'{node.lineno}: assigning string to non-string variable {node.targets[0].id}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'{node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "errors.append(f\"Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}\")",
      "mutated_line": "errors.append(f'Type mismatch at line {node.lineno}{node.targets[0].id}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}{node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:",
      "mutated_line": "if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) or n.id == arg.arg]:",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) or n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "errors.append(f\"Unused variable at line {node.lineno}: function argument {arg.arg}\")",
      "mutated_line": "errors.append(f'{node.lineno}: function argument {arg.arg}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'{node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "errors.append(f\"Unused variable at line {node.lineno}: function argument {arg.arg}\")",
      "mutated_line": "errors.append(f'Unused variable at line {node.lineno}{arg.arg}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}{arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "errors.append(f\"Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}\")",
      "mutated_line": "errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[1].id}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[1].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "errors.append(f\"Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}\")",
      "mutated_line": "errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[-1].id}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[-1].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "errors.append(f\"Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}\")",
      "mutated_line": "errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[1].id}')",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[1].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id == arg.arg]:",
      "mutated_line": "if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id != arg.arg]:",
      "code": "import ast\n\ndef compile_code(code):\n    \"\"\"\n    Compile and analyze the given Python code for potential issues.\n\n    Args:\n    code (str): A string containing the Python code to be compiled and analyzed.\n\n    Returns:\n    list: A list of error messages or warnings if any issues are found in the code.\n    \"\"\"\n    errors = []\n    try:\n        tree = ast.parse(code)\n    except SyntaxError as e:\n        errors.append(f'Syntax error at line {e.lineno}, column {e.offset}: {e.text}')\n        return errors\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Assign):\n            if isinstance(node.value, ast.Str) and isinstance(node.targets[0], ast.Name):\n                errors.append(f'Type mismatch at line {node.lineno}: assigning string to non-string variable {node.targets[0].id}')\n        elif isinstance(node, ast.FunctionDef):\n            for arg in node.args.args:\n                if arg.arg not in [n.id for n in ast.walk(node) if isinstance(n, ast.Name) and n.id != arg.arg]:\n                    errors.append(f'Unused variable at line {node.lineno}: function argument {arg.arg}')\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef) and len(node.body) > 10:\n            errors.append(f'Code smell at line {node.lineno}: long function {node.name} with {len(node.body)} lines')\n    return errors"
    }
  ]
}