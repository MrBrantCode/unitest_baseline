{
  "task_id": "cf_46561",
  "entry_point": "reorderedPowerOf2",
  "mutant_count": 67,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 or n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "count_steps = 0",
      "mutated_line": "count_steps = 1",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 1\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "count_steps = 0",
      "mutated_line": "count_steps = -1",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = -1\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "count_steps = 0",
      "mutated_line": "count_steps = 1",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 1\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 != 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n == 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if n[j] != i[j]:",
      "mutated_line": "if n[j] == i[j]:",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] == i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "count_steps += 1",
      "mutated_line": "count_steps -= 1",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps -= 1\n    return count_steps"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n | n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 1 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == -1 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 1 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 1:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != -1:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 1:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return True, n, 0",
      "mutated_line": "return (False, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (False, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return True, n, 0",
      "mutated_line": "return (True, n, 1)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 1)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return True, n, 0",
      "mutated_line": "return (True, n, -1)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, -1)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return True, n, 0",
      "mutated_line": "return (True, n, 1)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 1)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 * i for i in range(31) if len(str(2 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 * i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 + i for i in range(31) if len(str(2 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 + i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if Counter(strn) == Counter(str(i)):",
      "mutated_line": "if Counter(strn) != Counter(str(i)):",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) != Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False, -1, -1",
      "mutated_line": "return (True, -1, -1)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (True, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "return False, -1, -1",
      "mutated_line": "return (False, +1, -1)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, +1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "return False, -1, -1",
      "mutated_line": "return (False, -1, +1)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, +1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "count_steps += 1",
      "mutated_line": "count_steps += 2",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 2\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "count_steps += 1",
      "mutated_line": "count_steps += 0",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 0\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "count_steps += 1",
      "mutated_line": "count_steps += 0",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 0\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "count_steps += 1",
      "mutated_line": "count_steps += -1",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += -1\n    return count_steps"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n + 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n * 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [3 ** i for i in range(31) if len(str(2 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [3 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [1 ** i for i in range(31) if len(str(2 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [1 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [0 ** i for i in range(31) if len(str(2 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [0 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [1 ** i for i in range(31) if len(str(2 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [1 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [-2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [-2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) != n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) != n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False, -1, -1",
      "mutated_line": "return (False, -2, -1)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -2, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False, -1, -1",
      "mutated_line": "return (False, -0, -1)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -0, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False, -1, -1",
      "mutated_line": "return (False, -0, -1)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -0, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False, -1, -1",
      "mutated_line": "return (False, --1, -1)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, --1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False, -1, -1",
      "mutated_line": "return (False, -1, -2)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -2)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False, -1, -1",
      "mutated_line": "return (False, -1, -0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -0)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False, -1, -1",
      "mutated_line": "return (False, -1, -0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -0)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False, -1, -1",
      "mutated_line": "return (False, -1, --1)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, --1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 2 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 0 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 0 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n & (n-1) == 0 and n != 0:",
      "mutated_line": "return (True, n, 0)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - -1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 ** i for i in range(32) if len(str(2 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(32) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 ** i for i in range(30) if len(str(2 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(30) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 ** i for i in range(0) if len(str(2 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(0) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 ** i for i in range(1) if len(str(2 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(1) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 ** i for i in range(-31) if len(str(2 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(-31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return True, i, calculate_steps(strn, str(i))",
      "mutated_line": "return (False, i, calculate_steps(strn, str(i)))",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (False, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "i_list[j], i_list[j+indx_i] = i_list[j+indx_i], i_list[j]",
      "mutated_line": "(i_list[j], i_list[j - indx_i]) = (i_list[j + indx_i], i_list[j])",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j - indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "i_list[j], i_list[j+indx_i] = i_list[j+indx_i], i_list[j]",
      "mutated_line": "(i_list[j], i_list[j * indx_i]) = (i_list[j + indx_i], i_list[j])",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j * indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "i_list[j], i_list[j+indx_i] = i_list[j+indx_i], i_list[j]",
      "mutated_line": "(i_list[j], i_list[j + indx_i]) = (i_list[j - indx_i], i_list[j])",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j - indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "i_list[j], i_list[j+indx_i] = i_list[j+indx_i], i_list[j]",
      "mutated_line": "(i_list[j], i_list[j + indx_i]) = (i_list[j * indx_i], i_list[j])",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j * indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i = \"\".join(i_list)",
      "mutated_line": "i = 'MUTATED'.join(i_list)",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = 'MUTATED'.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 ** i for i in range(31) if len(str(2 * i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 * i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 ** i for i in range(31) if len(str(2 + i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(2 + i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 ** i for i in range(31) if len(str(3 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(3 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 ** i for i in range(31) if len(str(1 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(1 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 ** i for i in range(31) if len(str(0 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(0 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 ** i for i in range(31) if len(str(1 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(1 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "power_of_2_list = [2**i for i in range(31) if len(str(2**i)) == n_digits]",
      "mutated_line": "power_of_2_list = [2 ** i for i in range(31) if len(str(-2 ** i)) == n_digits]",
      "code": "from collections import Counter\n\ndef reorderedPowerOf2(n):\n    strn = str(n)\n    n_digits = len(strn)\n    if n & n - 1 == 0 and n != 0:\n        return (True, n, 0)\n    else:\n        power_of_2_list = [2 ** i for i in range(31) if len(str(-2 ** i)) == n_digits]\n        for i in power_of_2_list:\n            if Counter(strn) == Counter(str(i)):\n                return (True, i, calculate_steps(strn, str(i)))\n        return (False, -1, -1)\n\ndef calculate_steps(n, i):\n    (n_len, i_len) = (len(n), len(i))\n    count_steps = 0\n    for j in range(n_len):\n        if n[j] != i[j]:\n            indx_i = i[j:].index(n[j])\n            i_list = list(i)\n            (i_list[j], i_list[j + indx_i]) = (i_list[j + indx_i], i_list[j])\n            i = ''.join(i_list)\n            count_steps += 1\n    return count_steps"
    }
  ]
}