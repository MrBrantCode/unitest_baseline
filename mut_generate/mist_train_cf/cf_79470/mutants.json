{
  "task_id": "cf_79470",
  "entry_point": "find_directions",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited[robot_row][robot_col] = True",
      "mutated_line": "visited[robot_row][robot_col] = False",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = False\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return \"no way\"",
      "mutated_line": "return ''",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return ''"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "visited = [[False]*cols for _ in range(rows)]",
      "mutated_line": "visited = [[False] / cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] / cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "visited = [[False]*cols for _ in range(rows)]",
      "mutated_line": "visited = [[False] + cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] + cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "visited = [[False]*cols for _ in range(rows)]",
      "mutated_line": "visited = [[False] ** cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] ** cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "parent = [[None]*cols for _ in range(rows)]",
      "mutated_line": "parent = [[None] / cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] / cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "parent = [[None]*cols for _ in range(rows)]",
      "mutated_line": "parent = [[None] + cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] + cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "parent = [[None]*cols for _ in range(rows)]",
      "mutated_line": "parent = [[None] ** cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] ** cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "direction = ['u', 'r', 'd', 'l']",
      "mutated_line": "direction = ['', 'r', 'd', 'l']",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "direction = ['u', 'r', 'd', 'l']",
      "mutated_line": "direction = ['u', '', 'd', 'l']",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', '', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "direction = ['u', 'r', 'd', 'l']",
      "mutated_line": "direction = ['u', 'r', '', 'l']",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', '', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "direction = ['u', 'r', 'd', 'l']",
      "mutated_line": "direction = ['u', 'r', 'd', '']",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', '']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (x, y) == (station_row, station_col):",
      "mutated_line": "if (x, y) != (station_row, station_col):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) != (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([+1, 0, 1, 0], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([+1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 1, 1, 0], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 1, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, -1, 1, 0], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, -1, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 1, 1, 0], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 1, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 2, 0], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 2, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 0, 0], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 0, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 0, 0], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 0, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, -1, 0], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, -1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 1], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 1], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, -1], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, -1], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 1], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 1], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [1, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [1, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [-1, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [-1, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [1, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [1, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [0, 2, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 2, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [0, 0, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 0, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [0, 0, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 0, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [0, -1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, -1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [0, 1, 1, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 1, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [0, 1, -1, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, -1, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [0, 1, 1, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 1, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, +1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, +1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(4):",
      "mutated_line": "(nx, ny) = (x + dx[i], y + dy[i])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(5):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(4):",
      "mutated_line": "(nx, ny) = (x + dx[i], y + dy[i])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(3):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(4):",
      "mutated_line": "(nx, ny) = (x + dx[i], y + dy[i])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(0):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(4):",
      "mutated_line": "(nx, ny) = (x + dx[i], y + dy[i])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(1):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(4):",
      "mutated_line": "(nx, ny) = (x + dx[i], y + dy[i])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(-4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < rows or 0 <= ny < cols or (not visited[nx][ny]) or (labyrinth[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows or 0 <= ny < cols or (not visited[nx][ny]) or (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(labyrinth), len(labyrinth[0])",
      "mutated_line": "(rows, cols) = (len(labyrinth), len(labyrinth[1]))",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[1]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(labyrinth), len(labyrinth[0])",
      "mutated_line": "(rows, cols) = (len(labyrinth), len(labyrinth[-1]))",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[-1]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rows, cols = len(labyrinth), len(labyrinth[0])",
      "mutated_line": "(rows, cols) = (len(labyrinth), len(labyrinth[1]))",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[1]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited = [[False]*cols for _ in range(rows)]",
      "mutated_line": "visited = [[True] * cols for _ in range(rows)]",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[True] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-2, 0, 1, 0], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-2, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-0, 0, 1, 0], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-0, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-0, 0, 1, 0], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-0, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([--1, 0, 1, 0], [0, 1, 0, -1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([--1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -2])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -2])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -0])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -0])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -0])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -0])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]",
      "mutated_line": "(dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, --1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, --1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "nx, ny = x + dx[i], y + dy[i]",
      "mutated_line": "(nx, ny) = (x - dx[i], y + dy[i])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x - dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "nx, ny = x + dx[i], y + dy[i]",
      "mutated_line": "(nx, ny) = (x * dx[i], y + dy[i])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x * dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "nx, ny = x + dx[i], y + dy[i]",
      "mutated_line": "(nx, ny) = (x + dx[i], y - dy[i])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y - dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "nx, ny = x + dx[i], y + dy[i]",
      "mutated_line": "(nx, ny) = (x + dx[i], y * dy[i])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y * dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 0 < nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 < nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 0 > nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 > nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 0 == nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 == nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < rows and 0 < ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 < ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < rows and 0 > ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 > ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < rows and 0 == ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 == ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] != 0):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] != 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "visited[nx][ny] = True",
      "mutated_line": "visited[nx][ny] = False",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = False\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ''.join(path[::-1])",
      "mutated_line": "return 'MUTATED'.join(path[::-1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return 'MUTATED'.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 1 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 1 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if -1 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if -1 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 1 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 1 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < rows and 1 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 1 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < rows and -1 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and -1 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < rows and 1 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 1 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 1):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 1):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == -1):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == -1):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and labyrinth[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 1):",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 1):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "return ''.join(path[::-1])",
      "mutated_line": "return ''.join(path[::+1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::+1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ''.join(path[::-1])",
      "mutated_line": "return ''.join(path[::-2])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-2])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ''.join(path[::-1])",
      "mutated_line": "return ''.join(path[::-0])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-0])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ''.join(path[::-1])",
      "mutated_line": "return ''.join(path[::-0])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::-0])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return ''.join(path[::-1])",
      "mutated_line": "return ''.join(path[::--1])",
      "code": "from collections import deque\n\ndef find_directions(labyrinth, robot, station):\n    (rows, cols) = (len(labyrinth), len(labyrinth[0]))\n    (robot_row, robot_col) = robot\n    (station_row, station_col) = station\n    visited = [[False] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n    (dx, dy) = ([-1, 0, 1, 0], [0, 1, 0, -1])\n    direction = ['u', 'r', 'd', 'l']\n    queue = deque([(robot_row, robot_col)])\n    visited[robot_row][robot_col] = True\n    while queue:\n        (x, y) = queue.popleft()\n        if (x, y) == (station_row, station_col):\n            path = []\n            while parent[x][y]:\n                (nx, ny, d) = parent[x][y]\n                path.append(d)\n                (x, y) = (nx, ny)\n            return ''.join(path[::--1])\n        for i in range(4):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (labyrinth[nx][ny] == 0):\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n                parent[nx][ny] = (x, y, direction[i])\n    return 'no way'"
    }
  ]
}