{
  "task_id": "cf_38131",
  "entry_point": "non_max_suppression",
  "mutant_count": 127,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while len(sorted_indices) > 0:",
      "mutated_line": "while len(sorted_indices) >= 0:",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) >= 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while len(sorted_indices) > 0:",
      "mutated_line": "while len(sorted_indices) <= 0:",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) <= 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while len(sorted_indices) > 0:",
      "mutated_line": "while len(sorted_indices) != 0:",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) != 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) / max(0, y2 - y1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) / max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) + max(0, y2 - y1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) + max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) ** max(0, y2 - y1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) ** max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[0]) / (box1[3] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) / (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = box1[2] - box1[0] + (box1[3] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = box1[2] - box1[0] + (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[0]) ** (box1[3] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) ** (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[0]) / (box2[3] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) / (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = box2[2] - box2[0] + (box2[3] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = box2[2] - box2[0] + (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[0]) ** (box2[3] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) ** (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "union = area_box1 + area_box2 - intersection",
      "mutated_line": "union = area_box1 + area_box2 + intersection",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 + intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "union = area_box1 + area_box2 - intersection",
      "mutated_line": "union = (area_box1 + area_box2) * intersection",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = (area_box1 + area_box2) * intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return intersection / union",
      "mutated_line": "return intersection * union",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection * union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return intersection / union",
      "mutated_line": "return intersection // union",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection // union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while len(sorted_indices) > 0:",
      "mutated_line": "while len(sorted_indices) > 1:",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 1:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while len(sorted_indices) > 0:",
      "mutated_line": "while len(sorted_indices) > -1:",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > -1:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while len(sorted_indices) > 0:",
      "mutated_line": "while len(sorted_indices) > 1:",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 1:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] + box1[0]) * (box1[3] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] + box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = box1[2] * box1[0] * (box1[3] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = box1[2] * box1[0] * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] + box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] + box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] * box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] * box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] + box2[0]) * (box2[3] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] + box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = box2[2] * box2[0] * (box2[3] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = box2[2] * box2[0] * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] + box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] + box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] * box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] * box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "union = area_box1 + area_box2 - intersection",
      "mutated_line": "union = area_box1 - area_box2 - intersection",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 - area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "union = area_box1 + area_box2 - intersection",
      "mutated_line": "union = area_box1 * area_box2 - intersection",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 * area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)",
      "mutated_line": "sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=False)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=False)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "current_index = sorted_indices[0]",
      "mutated_line": "current_index = sorted_indices[1]",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[1]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "current_index = sorted_indices[0]",
      "mutated_line": "current_index = sorted_indices[-1]",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[-1]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "current_index = sorted_indices[0]",
      "mutated_line": "current_index = sorted_indices[1]",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[1]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, len(sorted_indices)):",
      "mutated_line": "for i in range(2, len(sorted_indices)):",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(2, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, len(sorted_indices)):",
      "mutated_line": "for i in range(0, len(sorted_indices)):",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(0, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, len(sorted_indices)):",
      "mutated_line": "for i in range(0, len(sorted_indices)):",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(0, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, len(sorted_indices)):",
      "mutated_line": "for i in range(-1, len(sorted_indices)):",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(-1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:",
      "mutated_line": "if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) >= threshold:",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) >= threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:",
      "mutated_line": "if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) <= threshold:",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) <= threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:",
      "mutated_line": "if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) != threshold:",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) != threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i -= 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "sorted_indices.pop(0)",
      "mutated_line": "sorted_indices.pop(1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(1)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "sorted_indices.pop(0)",
      "mutated_line": "sorted_indices.pop(-1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(-1)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "sorted_indices.pop(0)",
      "mutated_line": "sorted_indices.pop(1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(1)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x1 = max(box1[0], box2[0])",
      "mutated_line": "x1 = max(box1[1], box2[0])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[1], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x1 = max(box1[0], box2[0])",
      "mutated_line": "x1 = max(box1[-1], box2[0])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[-1], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x1 = max(box1[0], box2[0])",
      "mutated_line": "x1 = max(box1[1], box2[0])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[1], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x1 = max(box1[0], box2[0])",
      "mutated_line": "x1 = max(box1[0], box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[1])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x1 = max(box1[0], box2[0])",
      "mutated_line": "x1 = max(box1[0], box2[-1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[-1])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x1 = max(box1[0], box2[0])",
      "mutated_line": "x1 = max(box1[0], box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[1])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[2], box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[2], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[0], box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[0], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[0], box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[0], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[-1], box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[-1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[1], box2[2])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[2])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[1], box2[0])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[0])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[1], box2[0])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[0])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y1 = max(box1[1], box2[1])",
      "mutated_line": "y1 = max(box1[1], box2[-1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[-1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[3], box2[2])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[3], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[1], box2[2])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[1], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[0], box2[2])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[0], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[1], box2[2])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[1], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[-2], box2[2])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[-2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[2], box2[3])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[3])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[2], box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[1])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[2], box2[0])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[0])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[2], box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[1])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x2 = min(box1[2], box2[2])",
      "mutated_line": "x2 = min(box1[2], box2[-2])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[-2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[4], box2[3])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[4], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[2], box2[3])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[2], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[0], box2[3])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[0], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[1], box2[3])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[1], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[-3], box2[3])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[-3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[3], box2[4])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[4])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[3], box2[2])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[2])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[3], box2[0])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[0])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[3], box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[1])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "y2 = min(box1[3], box2[3])",
      "mutated_line": "y2 = min(box1[3], box2[-3])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[-3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(1, x2 - x1) * max(0, y2 - y1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(1, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(-1, x2 - x1) * max(0, y2 - y1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(-1, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(1, x2 - x1) * max(0, y2 - y1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(1, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 + x1) * max(0, y2 - y1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 + x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 * x1) * max(0, y2 - y1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 * x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) * max(1, y2 - y1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(1, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) * max(-1, y2 - y1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(-1, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) * max(1, y2 - y1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(1, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) * max(0, y2 + y1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 + y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "intersection = max(0, x2 - x1) * max(0, y2 - y1)",
      "mutated_line": "intersection = max(0, x2 - x1) * max(0, y2 * y1)",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 * y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 2\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 0\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 0\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += -1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[3] - box1[0]) * (box1[3] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[3] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[1] - box1[0]) * (box1[3] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[1] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[0] - box1[0]) * (box1[3] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[0] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[1] - box1[0]) * (box1[3] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[1] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[-2] - box1[0]) * (box1[3] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[-2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[1]) * (box1[3] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[1]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[-1]) * (box1[3] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[-1]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[1]) * (box1[3] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[1]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[0]) * (box1[4] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[4] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[0]) * (box1[2] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[2] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[0]) * (box1[0] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[0] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[0]) * (box1[1] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[1] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[0]) * (box1[-3] - box1[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[-3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[2])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[2])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[0])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[0])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[0])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[0])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])",
      "mutated_line": "area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[-1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[-1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[3] - box2[0]) * (box2[3] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[3] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[1] - box2[0]) * (box2[3] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[1] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[0] - box2[0]) * (box2[3] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[0] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[1] - box2[0]) * (box2[3] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[1] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[-2] - box2[0]) * (box2[3] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[-2] - box2[0]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[1]) * (box2[3] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[1]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[-1]) * (box2[3] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[-1]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[1]) * (box2[3] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[1]) * (box2[3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[0]) * (box2[4] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[4] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[0]) * (box2[2] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[2] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[0]) * (box2[0] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[0] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[0]) * (box2[1] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[1] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[0]) * (box2[-3] - box2[1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[-3] - box2[1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[2])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[2])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[0])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[0])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[0])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[0])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[1])",
      "mutated_line": "area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[-1])",
      "code": "from typing import List, Tuple\n\ndef non_max_suppression(bounding_boxes: List[Tuple[int, int, int, int]], confidence_scores: List[float], threshold: float) -> List[int]:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes based on their confidence scores.\n\n    Args:\n    - bounding_boxes: A list of tuples representing the bounding boxes in the format (x_min, y_min, x_max, y_max).\n    - confidence_scores: A list of confidence scores corresponding to each bounding box.\n    - threshold: The threshold value for suppressing overlapping bounding boxes, ranging from 0 to 1.\n\n    Returns:\n    - A list of indices representing the selected bounding boxes after NMS.\n    \"\"\"\n\n    def calculate_iou(box1: Tuple[int, int, int, int], box2: Tuple[int, int, int, int]) -> float:\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n        intersection = max(0, x2 - x1) * max(0, y2 - y1)\n        area_box1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        area_box2 = (box2[2] - box2[0]) * (box2[3] - box2[-1])\n        union = area_box1 + area_box2 - intersection\n        return intersection / union\n    selected_indices = []\n    sorted_indices = sorted(range(len(confidence_scores)), key=lambda i: confidence_scores[i], reverse=True)\n    while len(sorted_indices) > 0:\n        current_index = sorted_indices[0]\n        selected_indices.append(current_index)\n        for i in range(1, len(sorted_indices)):\n            if calculate_iou(bounding_boxes[current_index], bounding_boxes[sorted_indices[i]]) > threshold:\n                sorted_indices.pop(i)\n            else:\n                i += 1\n        sorted_indices.pop(0)\n    return selected_indices"
    }
  ]
}