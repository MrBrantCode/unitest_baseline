{
  "task_id": "cf_44105",
  "entry_point": "entrance",
  "mutant_count": 98,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 1 and b == 1:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 and b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_value = a + b",
      "mutated_line": "max_value = a - b",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a - b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "max_value = a + b",
      "mutated_line": "max_value = a * b",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a * b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "d = [float('inf')] * (max_value + 1)",
      "mutated_line": "d = [float('inf')] / (max_value + 1)",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] / (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "d = [float('inf')] * (max_value + 1)",
      "mutated_line": "d = [float('inf')] + (max_value + 1)",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] + (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "d = [float('inf')] * (max_value + 1)",
      "mutated_line": "d = [float('inf')] ** (max_value + 1)",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] ** (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d[a] = 0",
      "mutated_line": "d[a] = 1",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 1\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d[a] = 0",
      "mutated_line": "d[a] = -1",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = -1\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d[a] = 0",
      "mutated_line": "d[a] = 1",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 1\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a != 1 or b == 1:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a != 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 1 or b != 1:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b != 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 1\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return -1\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 1\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, max_value + 1):",
      "mutated_line": "for i in range(2, max_value + 1):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(2, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, max_value + 1):",
      "mutated_line": "for i in range(0, max_value + 1):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(0, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, max_value + 1):",
      "mutated_line": "for i in range(0, max_value + 1):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(0, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, max_value + 1):",
      "mutated_line": "for i in range(-1, max_value + 1):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(-1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(1, max_value + 1):",
      "mutated_line": "for i in range(1, max_value - 1):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value - 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(1, max_value + 1):",
      "mutated_line": "for i in range(1, max_value * 1):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value * 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i * 2 <= max_value:",
      "mutated_line": "if i * 2 < max_value:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 < max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i * 2 <= max_value:",
      "mutated_line": "if i * 2 > max_value:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 > max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i * 2 <= max_value:",
      "mutated_line": "if i * 2 == max_value:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 == max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "d = [float('inf')] * (max_value + 1)",
      "mutated_line": "d = [float('inf')] * (max_value - 1)",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value - 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "d = [float('inf')] * (max_value + 1)",
      "mutated_line": "d = [float('inf')] * (max_value * 1)",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value * 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return d[1]",
      "mutated_line": "return d[2]",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[2]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return d[1]",
      "mutated_line": "return d[0]",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return d[1]",
      "mutated_line": "return d[0]",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return d[1]",
      "mutated_line": "return d[-1]",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 2 or b == 1:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 2 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 0 or b == 1:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 0 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 0 or b == 1:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 0 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == -1 or b == 1:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == -1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 1 or b == 2:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 2:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 1 or b == 0:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 0:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 1 or b == 0:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 0:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 1 or b == -1:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == -1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, max_value + 1):",
      "mutated_line": "for i in range(1, max_value + 2):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 2):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, max_value + 1):",
      "mutated_line": "for i in range(1, max_value + 0):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 0):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, max_value + 1):",
      "mutated_line": "for i in range(1, max_value + 0):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 0):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, max_value + 1):",
      "mutated_line": "for i in range(1, max_value + -1):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + -1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, max_value + 1):",
      "mutated_line": "for j in range(2, max_value + 1):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(2, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, max_value + 1):",
      "mutated_line": "for j in range(0, max_value + 1):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(0, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, max_value + 1):",
      "mutated_line": "for j in range(0, max_value + 1):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(0, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, max_value + 1):",
      "mutated_line": "for j in range(-1, max_value + 1):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(-1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for j in range(1, max_value + 1):",
      "mutated_line": "for j in range(1, max_value - 1):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value - 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for j in range(1, max_value + 1):",
      "mutated_line": "for j in range(1, max_value * 1):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value * 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i != j:",
      "mutated_line": "if i == j:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i == j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if i * 2 <= max_value:",
      "mutated_line": "if i / 2 <= max_value:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i / 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if i * 2 <= max_value:",
      "mutated_line": "if i + 2 <= max_value:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i + 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if i * 2 <= max_value:",
      "mutated_line": "if i ** 2 <= max_value:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i ** 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "d = [float('inf')] * (max_value + 1)",
      "mutated_line": "d = [float('inf')] * (max_value + 2)",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 2)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "d = [float('inf')] * (max_value + 1)",
      "mutated_line": "d = [float('inf')] * (max_value + 0)",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 0)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "d = [float('inf')] * (max_value + 1)",
      "mutated_line": "d = [float('inf')] * (max_value + 0)",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 0)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "d = [float('inf')] * (max_value + 1)",
      "mutated_line": "d = [float('inf')] * (max_value + -1)",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + -1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if d[v] > d[u] + w:",
      "mutated_line": "if d[v] >= d[u] + w:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] >= d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if d[v] > d[u] + w:",
      "mutated_line": "if d[v] <= d[u] + w:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] <= d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if d[v] > d[u] + w:",
      "mutated_line": "if d[v] != d[u] + w:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] != d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "graph = [[] for _ in range(max_value + 1)]",
      "mutated_line": "graph = [[] for _ in range(max_value - 1)]",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value - 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "graph = [[] for _ in range(max_value + 1)]",
      "mutated_line": "graph = [[] for _ in range(max_value * 1)]",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value * 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, max_value + 1):",
      "mutated_line": "for j in range(1, max_value + 2):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 2):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, max_value + 1):",
      "mutated_line": "for j in range(1, max_value + 0):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 0):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, max_value + 1):",
      "mutated_line": "for j in range(1, max_value + 0):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 0):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, max_value + 1):",
      "mutated_line": "for j in range(1, max_value + -1):",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + -1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i * 2 <= max_value:",
      "mutated_line": "if i * 3 <= max_value:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 3 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i * 2 <= max_value:",
      "mutated_line": "if i * 1 <= max_value:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 1 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i * 2 <= max_value:",
      "mutated_line": "if i * 0 <= max_value:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 0 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i * 2 <= max_value:",
      "mutated_line": "if i * 1 <= max_value:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 1 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i * 2 <= max_value:",
      "mutated_line": "if i * -2 <= max_value:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * -2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "d = [float('inf')] * (max_value + 1)",
      "mutated_line": "d = [float('')] * (max_value + 1)",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if d[v] > d[u] + w:",
      "mutated_line": "if d[v] > d[u] - w:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] - w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if d[v] > d[u] + w:",
      "mutated_line": "if d[v] > d[u] * w:",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] * w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "d[v] = d[u] + w",
      "mutated_line": "d[v] = d[u] - w",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] - w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "d[v] = d[u] + w",
      "mutated_line": "d[v] = d[u] * w",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] * w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "graph = [[] for _ in range(max_value + 1)]",
      "mutated_line": "graph = [[] for _ in range(max_value + 2)]",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 2)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "graph = [[] for _ in range(max_value + 1)]",
      "mutated_line": "graph = [[] for _ in range(max_value + 0)]",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 0)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "graph = [[] for _ in range(max_value + 1)]",
      "mutated_line": "graph = [[] for _ in range(max_value + 0)]",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 0)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "graph = [[] for _ in range(max_value + 1)]",
      "mutated_line": "graph = [[] for _ in range(max_value + -1)]",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + -1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "graph[i].append((i * 2, 0))",
      "mutated_line": "graph[i].append((i / 2, 0))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i / 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "graph[i].append((i * 2, 0))",
      "mutated_line": "graph[i].append((i + 2, 0))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i + 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "graph[i].append((i * 2, 0))",
      "mutated_line": "graph[i].append((i ** 2, 0))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i ** 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "graph[i].append((i * 2, 0))",
      "mutated_line": "graph[i].append((i * 2, 1))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 1))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "graph[i].append((i * 2, 0))",
      "mutated_line": "graph[i].append((i * 2, -1))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, -1))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "graph[i].append((i * 2, 0))",
      "mutated_line": "graph[i].append((i * 2, 1))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 1))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "graph[i].append((j, 1))",
      "mutated_line": "graph[i].append((j, 2))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 2))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "graph[i].append((j, 1))",
      "mutated_line": "graph[i].append((j, 0))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 0))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "graph[i].append((j, 1))",
      "mutated_line": "graph[i].append((j, 0))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 0))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "graph[i].append((j, 1))",
      "mutated_line": "graph[i].append((j, -1))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, -1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "graph[j].append((i, 1))",
      "mutated_line": "graph[j].append((i, 2))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 2))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "graph[j].append((i, 1))",
      "mutated_line": "graph[j].append((i, 0))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 0))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "graph[j].append((i, 1))",
      "mutated_line": "graph[j].append((i, 0))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 0))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "graph[j].append((i, 1))",
      "mutated_line": "graph[j].append((i, -1))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, -1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "graph[i].append((i * 2, 0))",
      "mutated_line": "graph[i].append((i * 3, 0))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 3, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "graph[i].append((i * 2, 0))",
      "mutated_line": "graph[i].append((i * 1, 0))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 1, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "graph[i].append((i * 2, 0))",
      "mutated_line": "graph[i].append((i * 0, 0))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 0, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "graph[i].append((i * 2, 0))",
      "mutated_line": "graph[i].append((i * 1, 0))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * 1, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "graph[i].append((i * 2, 0))",
      "mutated_line": "graph[i].append((i * -2, 0))",
      "code": "from collections import deque\n\ndef entrance(a, b):\n    \"\"\"\n    Calculate the least number of pourings required to measure one liter.\n\n    Args:\n        a (int): The capacity of bucket S in liters.\n        b (int): The capacity of bucket M in liters.\n\n    Returns:\n        int: The least number of pourings required to measure one liter.\n    \"\"\"\n    if a == 1 or b == 1:\n        return 0\n    max_value = a + b\n    graph = [[] for _ in range(max_value + 1)]\n    for i in range(1, max_value + 1):\n        for j in range(1, max_value + 1):\n            if i != j:\n                graph[i].append((j, 1))\n                graph[j].append((i, 1))\n        if i * 2 <= max_value:\n            graph[i].append((i * -2, 0))\n    d = [float('inf')] * (max_value + 1)\n    d[a] = 0\n    queue = deque([a])\n    while queue:\n        u = queue.popleft()\n        for (v, w) in graph[u]:\n            if d[v] > d[u] + w:\n                d[v] = d[u] + w\n                queue.append(v)\n    return d[1]"
    }
  ]
}