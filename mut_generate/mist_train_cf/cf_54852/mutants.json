{
  "task_id": "cf_54852",
  "entry_point": "minTotalDistance",
  "mutant_count": 102,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "min_distance = float('inf')",
      "mutated_line": "min_distance = float('')",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "return min_distance if min_distance!=float('inf') else -1",
      "mutated_line": "return min_distance if min_distance == float('inf') else -1",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance == float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "return min_distance if min_distance!=float('inf') else -1",
      "mutated_line": "return min_distance if min_distance != float('inf') else +1",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else +1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(1, 1), (1, 0), (-1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(1, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(-1, 1), (1, 0), (-1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(-1, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(1, 1), (1, 0), (-1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(1, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 2), (1, 0), (-1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 2), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 0), (1, 0), (-1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 0), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 0), (1, 0), (-1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 0), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, -1), (1, 0), (-1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, -1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (2, 0), (-1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (2, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (0, 0), (-1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (0, 0), (-1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (0, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (-1, 0), (-1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (-1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 1), (-1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 1), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (-1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, -1), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 1), (-1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 1), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (+1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (+1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 1), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, -1), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, -1), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 1), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, 0), (1, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (1, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, 0), (-1, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (-1, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, 0), (1, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (1, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, 0), (0, +1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, +1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "friends = [(i,j) for i in range(m) for j in range(n) if grid[i][j] == 1]",
      "mutated_line": "friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] != 1]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] != 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "obstacles = [(i,j) for i in range(m) for j in range(n) if grid[i][j] == 2]",
      "mutated_line": "obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] != 2]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] != 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if grid[i][j] == 0:",
      "mutated_line": "if grid[i][j] != 0:",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min_distance if min_distance!=float('inf') else -1",
      "mutated_line": "return min_distance if min_distance != float('inf') else -2",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -2"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min_distance if min_distance!=float('inf') else -1",
      "mutated_line": "return min_distance if min_distance != float('inf') else -0",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min_distance if min_distance!=float('inf') else -1",
      "mutated_line": "return min_distance if min_distance != float('inf') else -0",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min_distance if min_distance!=float('inf') else -1",
      "mutated_line": "return min_distance if min_distance != float('inf') else --1",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else --1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[1]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[-1]))",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[-1]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[1]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-2, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-2, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-0, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-0, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-0, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-0, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (--1, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (--1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, 0), (0, -2)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -2)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, 0), (0, -0)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -0)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, 0), (0, -0)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -0)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "mutated_line": "directions = [(0, 1), (1, 0), (-1, 0), (0, --1)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, --1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "friends = [(i,j) for i in range(m) for j in range(n) if grid[i][j] == 1]",
      "mutated_line": "friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "friends = [(i,j) for i in range(m) for j in range(n) if grid[i][j] == 1]",
      "mutated_line": "friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 0]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 0]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "friends = [(i,j) for i in range(m) for j in range(n) if grid[i][j] == 1]",
      "mutated_line": "friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 0]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 0]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "friends = [(i,j) for i in range(m) for j in range(n) if grid[i][j] == 1]",
      "mutated_line": "friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == -1]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == -1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "obstacles = [(i,j) for i in range(m) for j in range(n) if grid[i][j] == 2]",
      "mutated_line": "obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 3]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 3]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "obstacles = [(i,j) for i in range(m) for j in range(n) if grid[i][j] == 2]",
      "mutated_line": "obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "obstacles = [(i,j) for i in range(m) for j in range(n) if grid[i][j] == 2]",
      "mutated_line": "obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 0]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 0]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "obstacles = [(i,j) for i in range(m) for j in range(n) if grid[i][j] == 2]",
      "mutated_line": "obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "obstacles = [(i,j) for i in range(m) for j in range(n) if grid[i][j] == 2]",
      "mutated_line": "obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == -2]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == -2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if grid[i][j] == 0:",
      "mutated_line": "if grid[i][j] == 1:",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if grid[i][j] == 0:",
      "mutated_line": "if grid[i][j] == -1:",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == -1:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if grid[i][j] == 0:",
      "mutated_line": "if grid[i][j] == 1:",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[i][j] = 0",
      "mutated_line": "dist[i][j] = 1",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 1\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[i][j] = 0",
      "mutated_line": "dist[i][j] = -1",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = -1\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[i][j] = 0",
      "mutated_line": "dist[i][j] = 1",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 1\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return min_distance if min_distance!=float('inf') else -1",
      "mutated_line": "return min_distance if min_distance != float('') else -1",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [[-1]*n for _ in range(m)]",
      "mutated_line": "dist = [[-1] / n for _ in range(m)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] / n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [[-1]*n for _ in range(m)]",
      "mutated_line": "dist = [[-1] + n for _ in range(m)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] + n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [[-1]*n for _ in range(m)]",
      "mutated_line": "dist = [[-1] ** n for _ in range(m)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] ** n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m or 0 <= ny < n or dist[nx][ny] == -1 or (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m or 0 <= ny < n or dist[nx][ny] == -1 or (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "dist = [[-1]*n for _ in range(m)]",
      "mutated_line": "dist = [[+1] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[+1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x - dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x * dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y - dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y * dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 < nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 < nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 > nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 > nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 == nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 == nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 < ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 < ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 > ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 > ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 == ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 == ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] != -1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] != -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] == 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] == 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] - 1",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] - 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] * 1",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] * 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[-1]*n for _ in range(m)]",
      "mutated_line": "dist = [[-2] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-2] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[-1]*n for _ in range(m)]",
      "mutated_line": "dist = [[-0] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-0] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[-1]*n for _ in range(m)]",
      "mutated_line": "dist = [[-0] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-0] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [[-1]*n for _ in range(m)]",
      "mutated_line": "dist = [[--1] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[--1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 1 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if -1 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if -1 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 1 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 1 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and -1 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and -1 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 1 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == +1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == +1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 3):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 3):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 1):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 1):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 0):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 0):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 1):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 1):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != -2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != -2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] + 2",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 2\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] + 0",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 0\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] + 0",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 0\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dist[nx][ny] = dist[x][y] + 1",
      "mutated_line": "dist[nx][ny] = dist[x][y] + -1",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + -1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -2) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -2) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -0) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -0) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -0) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == -0) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0<=nx<m and 0<=ny<n and dist[nx][ny]==-1 and grid[nx][ny]!=2:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == --1) and (grid[nx][ny] != 2):",
      "code": "from collections import deque\n\ndef minTotalDistance(grid):\n    (m, n) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    friends = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    obstacles = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 2]\n    min_distance = float('inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                dist = [[-1] * n for _ in range(m)]\n                dist[i][j] = 0\n                queue = deque([(i, j)])\n                while queue:\n                    (x, y) = queue.popleft()\n                    for (dx, dy) in directions:\n                        (nx, ny) = (x + dx, y + dy)\n                        if 0 <= nx < m and 0 <= ny < n and (dist[nx][ny] == --1) and (grid[nx][ny] != 2):\n                            dist[nx][ny] = dist[x][y] + 1\n                            queue.append((nx, ny))\n                total_distance = sum((dist[x][y] for (x, y) in friends))\n                min_distance = min(min_distance, total_distance)\n    return min_distance if min_distance != float('inf') else -1"
    }
  ]
}