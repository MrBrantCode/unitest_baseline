{
  "task_id": "cf_91399",
  "entry_point": "find_max_overlapping_intervals",
  "mutant_count": 37,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "maxOverlaps = 0",
      "mutated_line": "maxOverlaps = 1",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 1\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "maxOverlaps = 0",
      "mutated_line": "maxOverlaps = -1",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = -1\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "maxOverlaps = 0",
      "mutated_line": "maxOverlaps = 1",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 1\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "currentOverlaps = 1",
      "mutated_line": "currentOverlaps = 2",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 2\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "currentOverlaps = 1",
      "mutated_line": "currentOverlaps = 0",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 0\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "currentOverlaps = 1",
      "mutated_line": "currentOverlaps = 0",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 0\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "currentOverlaps = 1",
      "mutated_line": "currentOverlaps = -1",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = -1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "previousEnd = intervals[0][1]",
      "mutated_line": "previousEnd = intervals[0][2]",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][2]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "previousEnd = intervals[0][1]",
      "mutated_line": "previousEnd = intervals[0][0]",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][0]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "previousEnd = intervals[0][1]",
      "mutated_line": "previousEnd = intervals[0][0]",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][0]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "previousEnd = intervals[0][1]",
      "mutated_line": "previousEnd = intervals[0][-1]",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][-1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "(currentStart, currentEnd) = intervals[i]",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(2, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "(currentStart, currentEnd) = intervals[i]",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(0, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "(currentStart, currentEnd) = intervals[i]",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(0, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "(currentStart, currentEnd) = intervals[i]",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(-1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if currentStart <= previousEnd:",
      "mutated_line": "if currentStart < previousEnd:",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart < previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if currentStart <= previousEnd:",
      "mutated_line": "if currentStart > previousEnd:",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart > previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if currentStart <= previousEnd:",
      "mutated_line": "if currentStart == previousEnd:",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart == previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "currentOverlaps += 1",
      "mutated_line": "currentOverlaps -= 1",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps -= 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "previousEnd = intervals[0][1]",
      "mutated_line": "previousEnd = intervals[1][1]",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[1][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "previousEnd = intervals[0][1]",
      "mutated_line": "previousEnd = intervals[-1][1]",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[-1][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "previousEnd = intervals[0][1]",
      "mutated_line": "previousEnd = intervals[1][1]",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[1][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "currentOverlaps += 1",
      "mutated_line": "currentOverlaps += 2",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 2\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "currentOverlaps += 1",
      "mutated_line": "currentOverlaps += 0",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 0\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "currentOverlaps += 1",
      "mutated_line": "currentOverlaps += 0",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 0\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "currentOverlaps += 1",
      "mutated_line": "currentOverlaps += -1",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += -1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "currentOverlaps = 1",
      "mutated_line": "currentOverlaps = 2",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 2\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "currentOverlaps = 1",
      "mutated_line": "currentOverlaps = 0",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 0\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "currentOverlaps = 1",
      "mutated_line": "currentOverlaps = 0",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 0\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "currentOverlaps = 1",
      "mutated_line": "currentOverlaps = -1",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = -1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], x[1]))  # Sort intervals based on start points and end points",
      "mutated_line": "intervals.sort(key=lambda x: (x[1], x[1]))",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[1], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], x[1]))  # Sort intervals based on start points and end points",
      "mutated_line": "intervals.sort(key=lambda x: (x[-1], x[1]))",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[-1], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], x[1]))  # Sort intervals based on start points and end points",
      "mutated_line": "intervals.sort(key=lambda x: (x[1], x[1]))",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[1], x[1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], x[1]))  # Sort intervals based on start points and end points",
      "mutated_line": "intervals.sort(key=lambda x: (x[0], x[2]))",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[2]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], x[1]))  # Sort intervals based on start points and end points",
      "mutated_line": "intervals.sort(key=lambda x: (x[0], x[0]))",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[0]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], x[1]))  # Sort intervals based on start points and end points",
      "mutated_line": "intervals.sort(key=lambda x: (x[0], x[0]))",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[0]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "intervals.sort(key=lambda x: (x[0], x[1]))  # Sort intervals based on start points and end points",
      "mutated_line": "intervals.sort(key=lambda x: (x[0], x[-1]))",
      "code": "def find_max_overlapping_intervals(intervals):\n    intervals.sort(key=lambda x: (x[0], x[-1]))\n    maxOverlaps = 0\n    currentOverlaps = 1\n    previousEnd = intervals[0][1]\n    for i in range(1, len(intervals)):\n        (currentStart, currentEnd) = intervals[i]\n        if currentStart <= previousEnd:\n            currentOverlaps += 1\n        else:\n            maxOverlaps = max(maxOverlaps, currentOverlaps)\n            currentOverlaps = 1\n        previousEnd = max(previousEnd, currentEnd)\n    maxOverlaps = max(maxOverlaps, currentOverlaps)\n    return maxOverlaps"
    }
  ]
}