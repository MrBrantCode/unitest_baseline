{
  "task_id": "cf_44429",
  "entry_point": "complex_string_weaver",
  "mutant_count": 98,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if len(s1) != len(s2):",
      "mutated_line": "if len(s1) == len(s2):",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) == len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "interleave = ''",
      "mutated_line": "interleave = 'MUTATED'",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = 'MUTATED'\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "interleave += mod_s[i]",
      "mutated_line": "interleave -= mod_s[i]",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave -= mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "result = ''",
      "mutated_line": "result = 'MUTATED'",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = 'MUTATED'\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result = ''",
      "mutated_line": "result = 'MUTATED'",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = 'MUTATED'\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return ''",
      "mutated_line": "return 'MUTATED'",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return 'MUTATED'\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i < len(mod_s) - 1:",
      "mutated_line": "if i <= len(mod_s) - 1:",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i <= len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i < len(mod_s) - 1:",
      "mutated_line": "if i >= len(mod_s) - 1:",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i >= len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i < len(mod_s) - 1:",
      "mutated_line": "if i != len(mod_s) - 1:",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i != len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "interleave += 'b'",
      "mutated_line": "interleave -= 'b'",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave -= 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
      "mutated_line": "vowels = {'', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
      "mutated_line": "vowels = {'a', '', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', '', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
      "mutated_line": "vowels = {'a', 'e', '', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', '', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
      "mutated_line": "vowels = {'a', 'e', 'i', '', 'u', 'A', 'E', 'I', 'O', 'U'}",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', '', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
      "mutated_line": "vowels = {'a', 'e', 'i', 'o', '', 'A', 'E', 'I', 'O', 'U'}",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', '', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
      "mutated_line": "vowels = {'a', 'e', 'i', 'o', 'u', '', 'E', 'I', 'O', 'U'}",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', '', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
      "mutated_line": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', '', 'I', 'O', 'U'}",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', '', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
      "mutated_line": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', '', 'O', 'U'}",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', '', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
      "mutated_line": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', '', 'U'}",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', '', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}",
      "mutated_line": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', ''}",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', ''}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if c1 not in vowels:",
      "mutated_line": "if c1 in vowels:",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "result += c1",
      "mutated_line": "result -= c1",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result -= c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result -= chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result -= chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if c2 not in vowels:",
      "mutated_line": "if c2 in vowels:",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "result += c2",
      "mutated_line": "result -= c2",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result -= c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result -= chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result -= chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result -= chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result -= chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "result += c",
      "mutated_line": "result -= c",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result -= c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i < len(mod_s) - 1:",
      "mutated_line": "if i < len(mod_s) + 1:",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) + 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i < len(mod_s) - 1:",
      "mutated_line": "if i < len(mod_s) * 1:",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) * 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "interleave += 'b'",
      "mutated_line": "interleave += ''",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += ''\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "reversed_s = cipher_s[::-1]",
      "mutated_line": "reversed_s = cipher_s[::+1]",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::+1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i < len(mod_s) - 1:",
      "mutated_line": "if i < len(mod_s) - 2:",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 2:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i < len(mod_s) - 1:",
      "mutated_line": "if i < len(mod_s) - 0:",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 0:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i < len(mod_s) - 1:",
      "mutated_line": "if i < len(mod_s) - 0:",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 0:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i < len(mod_s) - 1:",
      "mutated_line": "if i < len(mod_s) - -1:",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - -1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "reversed_s = cipher_s[::-1]",
      "mutated_line": "reversed_s = cipher_s[::-2]",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-2]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "reversed_s = cipher_s[::-1]",
      "mutated_line": "reversed_s = cipher_s[::-0]",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-0]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "reversed_s = cipher_s[::-1]",
      "mutated_line": "reversed_s = cipher_s[::-0]",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-0]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "reversed_s = cipher_s[::-1]",
      "mutated_line": "reversed_s = cipher_s[::--1]",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::--1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 - ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 - ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 * ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 * ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 - ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 - ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 * ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 * ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset + 2) % 26 - ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 - ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset + 2) % 26 * ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 * ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 1 - ord('a')) * 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) * 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr(ord(c1) + 1 - ord('a') + 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr(ord(c1) + 1 - ord('a') + 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 1 - ord('a')) * 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) * 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr(ord(c2) + 1 - ord('a') + 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr(ord(c2) + 1 - ord('a') + 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ascii_offset = ord('a') if c.islower() else ord('A')",
      "mutated_line": "ascii_offset = ord('') if c.islower() else ord('A')",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ascii_offset = ord('a') if c.islower() else ord('A')",
      "mutated_line": "ascii_offset = ord('a') if c.islower() else ord('')",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset + 2) * 26 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) * 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr(ord(c) - ascii_offset + 2 + 26 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr(ord(c) - ascii_offset + 2 + 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 1 + ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 + ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 1) * ord('a') % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1) * ord('a') % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 1 - ord('a')) % 27 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 27 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 1 - ord('a')) % 25 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 25 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 1 - ord('a')) % 0 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 0 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 1 - ord('a')) % 1 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 1 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 1 - ord('a')) % -26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % -26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord(''))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord(''))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 1 + ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 + ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 1) * ord('a') % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1) * ord('a') % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 1 - ord('a')) % 27 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 27 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 1 - ord('a')) % 25 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 25 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 1 - ord('a')) % 0 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 0 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 1 - ord('a')) % 1 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 1 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 1 - ord('a')) % -26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % -26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord(''))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord(''))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset - 2) % 26 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset - 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset) * 2 % 26 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset) * 2 % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset + 2) % 27 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 27 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset + 2) % 25 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 25 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset + 2) % 0 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 0 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset + 2) % 1 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 1 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset + 2) % -26 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % -26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) - 1 - ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) - 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) * 1 - ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) * 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) - 1 - ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) - 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) * 1 - ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) * 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) + ascii_offset + 2) % 26 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) + ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) * ascii_offset + 2) % 26 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) * ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset + 3) % 26 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 3) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset + 1) % 26 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 1) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset + 0) % 26 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 0) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset + 1) % 26 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 1) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)",
      "mutated_line": "result += chr((ord(c) - ascii_offset + -2) % 26 + ascii_offset)",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + -2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 2 - ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 2 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 0 - ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 0 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 0 - ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 0 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + -1 - ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + -1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c1) + 1 - ord('')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 2 - ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 2 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 0 - ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 0 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 0 - ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 0 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + -1 - ord('a')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + -1 - ord('a')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result += chr((ord(c2) + 1 - ord('a')) % 26 + ord('b'))",
      "mutated_line": "result += chr((ord(c2) + 1 - ord('')) % 26 + ord('b'))",
      "code": "from typing import Tuple\n\ndef complex_string_weaver(strings: Tuple[str, str]) -> str:\n\n    def mod_string(s1, s2):\n        result = ''\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        for (c1, c2) in zip(s1, s2):\n            if c1 not in vowels:\n                result += c1\n            else:\n                result += chr((ord(c1) + 1 - ord('a')) % 26 + ord('b'))\n            if c2 not in vowels:\n                result += c2\n            else:\n                result += chr((ord(c2) + 1 - ord('')) % 26 + ord('b'))\n        return result\n\n    def caesar_cipher(s):\n        result = ''\n        for c in s:\n            if c.isalpha():\n                ascii_offset = ord('a') if c.islower() else ord('A')\n                result += chr((ord(c) - ascii_offset + 2) % 26 + ascii_offset)\n            else:\n                result += c\n        return result\n    (s1, s2) = strings\n    if len(s1) != len(s2):\n        return ''\n    mod_s = mod_string(s1, s2)\n    interleave = ''\n    for i in range(len(mod_s)):\n        interleave += mod_s[i]\n        if i < len(mod_s) - 1:\n            interleave += 'b'\n    cipher_s = caesar_cipher(interleave)\n    reversed_s = cipher_s[::-1]\n    return reversed_s"
    }
  ]
}