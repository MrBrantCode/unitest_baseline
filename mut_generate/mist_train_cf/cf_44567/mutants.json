{
  "task_id": "cf_44567",
  "entry_point": "shortest_path",
  "mutant_count": 150,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target and board[n - 1][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target and board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return \"No Solution\"",
      "mutated_line": "return ''",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] >= target or board[n - 1][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] >= target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] <= target or board[n - 1][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] <= target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] != target or board[n - 1][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] != target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n - 1][m - 1] >= target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] >= target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n - 1][m - 1] <= target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] <= target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n - 1][m - 1] != target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] != target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return \"No Solution\"",
      "mutated_line": "return ''",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return ''\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if curr_sum > target:",
      "mutated_line": "if curr_sum >= target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum >= target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if curr_sum > target:",
      "mutated_line": "if curr_sum <= target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum <= target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if curr_sum > target:",
      "mutated_line": "if curr_sum != target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum != target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n - 1 or y == m - 1 or curr_sum == target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 or y == m - 1 or curr_sum == target:\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(-1, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(1, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 2), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 0), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, -1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (-1, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (1, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, +1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (2, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (0, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (-1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, -1), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 1), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (+1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, -1)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 1)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][0], 1, 0, [(0, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 1, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][0], -1, 0, [(0, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], -1, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][0], 1, 0, [(0, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 1, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][0], 0, 1, [(0, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 1, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][0], 0, -1, [(0, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, -1, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][0], 0, 1, [(0, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 1, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "visited = set((0, 0))",
      "mutated_line": "visited = set((1, 0))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((1, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "visited = set((0, 0))",
      "mutated_line": "visited = set((-1, 0))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((-1, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "visited = set((0, 0))",
      "mutated_line": "visited = set((1, 0))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((1, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "visited = set((0, 0))",
      "mutated_line": "visited = set((0, 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 1))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "visited = set((0, 0))",
      "mutated_line": "visited = set((0, -1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, -1))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "visited = set((0, 0))",
      "mutated_line": "visited = set((0, 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 1))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x != n - 1 and y == m - 1 and (curr_sum == target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x != n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n - 1 and y != m - 1 and (curr_sum == target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y != m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n - 1 and y == m - 1 and (curr_sum != target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum != target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if (0 <= nx < n) and (0 <= ny < m) and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n or 0 <= ny < m or (nx, ny) not in visited:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n or 0 <= ny < m or (nx, ny) not in visited:\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "n, m = len(board), len(board[0])",
      "mutated_line": "(n, m) = (len(board), len(board[1]))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[1]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "n, m = len(board), len(board[0])",
      "mutated_line": "(n, m) = (len(board), len(board[-1]))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[-1]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "n, m = len(board), len(board[0])",
      "mutated_line": "(n, m) = (len(board), len(board[1]))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[1]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][1] > target or board[n - 1][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][1] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][-1] > target or board[n - 1][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][-1] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][1] > target or board[n - 1][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][1] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n - 1][m + 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m + 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n - 1][m * 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m * 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -2), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -0), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, --1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-2, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-0, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]",
      "mutated_line": "directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (--1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][1], 0, 0, [(0, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][1], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][-1], 0, 0, [(0, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][-1], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][1], 0, 0, [(0, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][1], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n + 1 and y == m - 1 and (curr_sum == target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n + 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n * 1 and y == m - 1 and (curr_sum == target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n * 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n - 1 and y == m + 1 and (curr_sum == target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m + 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n - 1 and y == m * 1 and (curr_sum == target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m * 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x - dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x * dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y - dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y * dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (0 <= nx < n) and (0 <= ny < m) and (nx, ny) not in visited:",
      "mutated_line": "if 0 < nx < n and 0 <= ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 < nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (0 <= nx < n) and (0 <= ny < m) and (nx, ny) not in visited:",
      "mutated_line": "if 0 > nx < n and 0 <= ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 > nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (0 <= nx < n) and (0 <= ny < m) and (nx, ny) not in visited:",
      "mutated_line": "if 0 == nx < n and 0 <= ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 == nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (0 <= nx < n) and (0 <= ny < m) and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n and 0 < ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 < ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (0 <= nx < n) and (0 <= ny < m) and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n and 0 > ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 > ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (0 <= nx < n) and (0 <= ny < m) and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n and 0 == ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 == ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if (0 <= nx < n) and (0 <= ny < m) and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < m and ((nx, ny) in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if board[nx][ny] > target - curr_sum:",
      "mutated_line": "if board[nx][ny] >= target - curr_sum:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] >= target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if board[nx][ny] > target - curr_sum:",
      "mutated_line": "if board[nx][ny] <= target - curr_sum:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] <= target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if board[nx][ny] > target - curr_sum:",
      "mutated_line": "if board[nx][ny] != target - curr_sum:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] != target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "new_sum = curr_sum + board[nx][ny]",
      "mutated_line": "new_sum = curr_sum - board[nx][ny]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum - board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "new_sum = curr_sum + board[nx][ny]",
      "mutated_line": "new_sum = curr_sum * board[nx][ny]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum * board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "new_path = path + [(nx, ny)]",
      "mutated_line": "new_path = path - [(nx, ny)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path - [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "new_path = path + [(nx, ny)]",
      "mutated_line": "new_path = path * [(nx, ny)]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path * [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - (n - 1)) - abs(ny - (m - 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) - abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = (new_sum + abs(nx - (n - 1))) * abs(ny - (m - 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = (new_sum + abs(nx - (n - 1))) * abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[1][0] > target or board[n - 1][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[1][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[-1][0] > target or board[n - 1][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[-1][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[1][0] > target or board[n - 1][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[1][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n + 1][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n + 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n * 1][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n * 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n - 1][m - 2] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 2] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n - 1][m - 0] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 0] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n - 1][m - 0] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 0] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n - 1][m - -1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - -1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[1][0], 0, 0, [(0, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[1][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[-1][0], 0, 0, [(0, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[-1][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[1][0], 0, 0, [(0, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[1][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][0], 0, 0, [(1, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(1, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][0], 0, 0, [(-1, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(-1, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][0], 0, 0, [(1, 0)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(1, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][0], 0, 0, [(0, 1)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 1)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][0], 0, 0, [(0, -1)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, -1)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "pq = [(board[0][0], 0, 0, [(0, 0)])]",
      "mutated_line": "pq = [(board[0][0], 0, 0, [(0, 1)])]",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 1)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n - 2 and y == m - 1 and (curr_sum == target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 2 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n - 0 and y == m - 1 and (curr_sum == target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 0 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n - 0 and y == m - 1 and (curr_sum == target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 0 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n - -1 and y == m - 1 and (curr_sum == target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - -1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n - 1 and y == m - 2 and (curr_sum == target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 2 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n - 1 and y == m - 0 and (curr_sum == target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 0 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n - 1 and y == m - 0 and (curr_sum == target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 0 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if x == n - 1 and y == m - 1 and curr_sum == target:",
      "mutated_line": "if x == n - 1 and y == m - -1 and (curr_sum == target):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - -1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (0 <= nx < n) and (0 <= ny < m) and (nx, ny) not in visited:",
      "mutated_line": "if 1 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (0 <= nx < n) and (0 <= ny < m) and (nx, ny) not in visited:",
      "mutated_line": "if -1 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if -1 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (0 <= nx < n) and (0 <= ny < m) and (nx, ny) not in visited:",
      "mutated_line": "if 1 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (0 <= nx < n) and (0 <= ny < m) and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n and 1 <= ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 1 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (0 <= nx < n) and (0 <= ny < m) and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n and -1 <= ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and -1 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if (0 <= nx < n) and (0 <= ny < m) and (nx, ny) not in visited:",
      "mutated_line": "if 0 <= nx < n and 1 <= ny < m and ((nx, ny) not in visited):",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 1 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if board[nx][ny] > target - curr_sum:",
      "mutated_line": "if board[nx][ny] > target + curr_sum:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target + curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if board[nx][ny] > target - curr_sum:",
      "mutated_line": "if board[nx][ny] > target * curr_sum:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target * curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum - abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum - abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum * abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum * abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n - 2][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 2][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n - 0][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 0][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n - 0][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 0][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if board[0][0] > target or board[n-1][m-1] > target:",
      "mutated_line": "if board[0][0] > target or board[n - -1][m - 1] > target:",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - -1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny + (m - 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny + (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny * (m - 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny * (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx + (n - 1)) + abs(ny - (m - 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx + (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx * (n - 1)) + abs(ny - (m - 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx * (n - 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m + 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m + 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - m * 1)",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - m * 1)\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - (n + 1)) + abs(ny - (m - 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n + 1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - n * 1) + abs(ny - (m - 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - n * 1) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 2))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 2))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 0))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 0))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 0))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 0))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - -1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - -1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - (n - 2)) + abs(ny - (m - 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 2)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - (n - 0)) + abs(ny - (m - 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 0)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - (n - 0)) + abs(ny - (m - 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - 0)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "new_cost = new_sum + abs(nx - (n - 1)) + abs(ny - (m - 1))",
      "mutated_line": "new_cost = new_sum + abs(nx - (n - -1)) + abs(ny - (m - 1))",
      "code": "import heapq\n\ndef shortest_path(board, target):\n    (n, m) = (len(board), len(board[0]))\n    if board[0][0] > target or board[n - 1][m - 1] > target:\n        return 'No Solution'\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(board[0][0], 0, 0, [(0, 0)])]\n    visited = set((0, 0))\n    while pq:\n        (curr_sum, x, y, path) = heapq.heappop(pq)\n        if curr_sum > target:\n            continue\n        if x == n - 1 and y == m - 1 and (curr_sum == target):\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and ((nx, ny) not in visited):\n                if board[nx][ny] > target - curr_sum:\n                    continue\n                new_sum = curr_sum + board[nx][ny]\n                new_path = path + [(nx, ny)]\n                new_cost = new_sum + abs(nx - (n - -1)) + abs(ny - (m - 1))\n                heapq.heappush(pq, (new_sum, nx, ny, new_path))\n                visited.add((nx, ny))\n    return 'No Solution'"
    }
  ]
}