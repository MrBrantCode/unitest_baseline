{
  "task_id": "cf_25234",
  "entry_point": "avoid_deadlock",
  "mutant_count": 35,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "return len(in_degree) == 0",
      "mutated_line": "return len(in_degree) != 0",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) != 0"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "in_degree[neighbor] -= 1",
      "mutated_line": "in_degree[neighbor] += 1",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] += 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return len(in_degree) == 0",
      "mutated_line": "return len(in_degree) == 1",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return len(in_degree) == 0",
      "mutated_line": "return len(in_degree) == -1",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return len(in_degree) == 0",
      "mutated_line": "return len(in_degree) == 1",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if resource[0] == resource_id:",
      "mutated_line": "if resource[0] != resource_id:",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] != resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "queue = [thread_id for thread_id, _ in threads if in_degree[thread_id] == 0]",
      "mutated_line": "queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] != 0]",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] != 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "thread_id = queue.pop(0)",
      "mutated_line": "thread_id = queue.pop(1)",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(1)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "thread_id = queue.pop(0)",
      "mutated_line": "thread_id = queue.pop(-1)",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(-1)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "thread_id = queue.pop(0)",
      "mutated_line": "thread_id = queue.pop(1)",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(1)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "in_degree[neighbor] -= 1",
      "mutated_line": "in_degree[neighbor] -= 2",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 2\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "in_degree[neighbor] -= 1",
      "mutated_line": "in_degree[neighbor] -= 0",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 0\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "in_degree[neighbor] -= 1",
      "mutated_line": "in_degree[neighbor] -= 0",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 0\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "in_degree[neighbor] -= 1",
      "mutated_line": "in_degree[neighbor] -= -1",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= -1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if in_degree[neighbor] == 0:",
      "mutated_line": "if in_degree[neighbor] != 0:",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] != 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if held_by is not None:",
      "mutated_line": "if held_by is None:",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "in_degree[thread_id] += 1",
      "mutated_line": "queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] -= 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "queue = [thread_id for thread_id, _ in threads if in_degree[thread_id] == 0]",
      "mutated_line": "queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 1]",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 1]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "queue = [thread_id for thread_id, _ in threads if in_degree[thread_id] == 0]",
      "mutated_line": "queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == -1]",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == -1]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "queue = [thread_id for thread_id, _ in threads if in_degree[thread_id] == 0]",
      "mutated_line": "queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 1]",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 1]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if in_degree[neighbor] == 0:",
      "mutated_line": "if in_degree[neighbor] == 1:",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 1:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if in_degree[neighbor] == 0:",
      "mutated_line": "if in_degree[neighbor] == -1:",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == -1:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if in_degree[neighbor] == 0:",
      "mutated_line": "if in_degree[neighbor] == 1:",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 1:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if resource[0] == resource_id:",
      "mutated_line": "if resource[1] == resource_id:",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[1] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if resource[0] == resource_id:",
      "mutated_line": "if resource[-1] == resource_id:",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[-1] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if resource[0] == resource_id:",
      "mutated_line": "if resource[1] == resource_id:",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[1] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "held_by = resource[1]",
      "mutated_line": "held_by = resource[2]",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[2]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "held_by = resource[1]",
      "mutated_line": "held_by = resource[0]",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[0]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "held_by = resource[1]",
      "mutated_line": "held_by = resource[0]",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[0]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "held_by = resource[1]",
      "mutated_line": "held_by = resource[-1]",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[-1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "in_degree[thread_id] += 1",
      "mutated_line": "queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 2\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "in_degree[thread_id] += 1",
      "mutated_line": "queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 0\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "in_degree[thread_id] += 1",
      "mutated_line": "queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += 0\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "in_degree[thread_id] += 1",
      "mutated_line": "queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]",
      "code": "from collections import defaultdict\n\ndef avoid_deadlock(threads, resources):\n    \"\"\"\n    This function prevents deadlock by avoiding circular wait when multiple threads are competing for resources.\n    \n    Args:\n        threads (list): A list of threads where each thread is represented as a pair (thread_id, resource_id)\n        resources (list): A list of resources where each resource is represented as a pair (resource_id, held_by)\n        \n    Returns:\n        bool: True if the system is deadlock-free, False otherwise\n    \"\"\"\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    for (thread_id, resource_id) in threads:\n        for resource in resources:\n            if resource[0] == resource_id:\n                held_by = resource[1]\n                if held_by is not None:\n                    graph[held_by].append(thread_id)\n                    in_degree[thread_id] += -1\n    queue = [thread_id for (thread_id, _) in threads if in_degree[thread_id] == 0]\n    while queue:\n        thread_id = queue.pop(0)\n        for neighbor in graph[thread_id]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return len(in_degree) == 0"
    }
  ]
}