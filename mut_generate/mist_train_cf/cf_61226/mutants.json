{
  "task_id": "cf_61226",
  "entry_point": "maxSumPathChess",
  "mutant_count": 126,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "result = 0",
      "mutated_line": "result = 1",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 1\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "result = 0",
      "mutated_line": "result = -1",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = -1\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "result = 0",
      "mutated_line": "result = 1",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 1\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [+1, 0, 1, 0, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [+1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 1, 1, 0, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 1, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, -1, 1, 0, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, -1, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 1, 1, 0, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 1, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 2, 0, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 2, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 0, 0, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 0, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 0, 0, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 0, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, -1, 0, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, -1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 1, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 1, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, -1, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, -1, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 1, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 1, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, +1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, +1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -1, +1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, +1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -1, -1, 2, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 2, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -1, -1, 0, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 0, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -1, -1, 0, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 0, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -1, -1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, -1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 2]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 2]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 0]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 0]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 0]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 0]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -1, -1, 1, -1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, -1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [1, 1, 0, -1, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [1, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [-1, 1, 0, -1, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [-1, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [1, 1, 0, -1, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [1, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 2, 0, -1, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 2, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 0, 0, -1, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 0, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 0, 0, -1, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 0, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, -1, 0, -1, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, -1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 1, -1, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 1, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, -1, -1, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, -1, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 1, -1, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 1, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, +1, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, +1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, +1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, +1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -1, 2, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 2, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -1, 0, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 0, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -1, 0, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 0, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -1, -1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, -1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -1, 1, +1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, +1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -1, 1, -1, 2]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 2]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -1, 1, -1, 0]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 0]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -1, 1, -1, 0]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 0]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -1, 1, -1, -1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, -1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if steps == k:",
      "mutated_line": "if steps != k:",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps != k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if dp[x][y][steps] != -1:",
      "mutated_line": "if dp[x][y][steps] == -1:",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] == -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "max_path = 0",
      "mutated_line": "max_path = 1",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 1\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "max_path = 0",
      "mutated_line": "max_path = -1",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = -1\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "max_path = 0",
      "mutated_line": "max_path = 1",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 1\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[x][y][steps] = max_path + grid[x][y]",
      "mutated_line": "dp[x][y][steps] = max_path - grid[x][y]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path - grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[x][y][steps] = max_path + grid[x][y]",
      "mutated_line": "dp[x][y][steps] = max_path * grid[x][y]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path * grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-2, 0, 1, 0, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-2, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-0, 0, 1, 0, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-0, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-0, 0, 1, 0, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-0, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [--1, 0, 1, 0, -1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [--1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -2, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -2, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -0, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -0, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -0, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -0, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, --1, -1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, --1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -1, -2, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -2, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -1, -0, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -0, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -1, -0, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -0, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dx = [-1, 0, 1, 0, -1, -1, 1, 1]",
      "mutated_line": "dx = [-1, 0, 1, 0, -1, --1, 1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, --1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -2, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -2, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -0, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -0, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -0, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -0, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, --1, -1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, --1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -2, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -2, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -0, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -0, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -0, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -0, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, --1, 1, -1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, --1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -1, 1, -2, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -2, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -1, 1, -0, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -0, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -1, 1, -0, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -0, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dy = [0, 1, 0, -1, -1, 1, -1, 1]",
      "mutated_line": "dy = [0, 1, 0, -1, -1, 1, --1, 1]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, --1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "if dp[x][y][steps] != -1:",
      "mutated_line": "if dp[x][y][steps] != +1:",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != +1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(9):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(9):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(7):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(7):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(0):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(0):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(1):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(1):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(8):",
      "mutated_line": "for i in range(-8):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(-8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 0 or nx < n or ny >= 0 or (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 or nx < n or ny >= 0 or (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(n*n)] for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dp = [[[+1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[+1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[x][y][steps] != -1:",
      "mutated_line": "if dp[x][y][steps] != -2:",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -2:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[x][y][steps] != -1:",
      "mutated_line": "if dp[x][y][steps] != -0:",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -0:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[x][y][steps] != -1:",
      "mutated_line": "if dp[x][y][steps] != -0:",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -0:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[x][y][steps] != -1:",
      "mutated_line": "if dp[x][y][steps] != --1:",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != --1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx[i], y + dy[i]",
      "mutated_line": "(nx, ny) = (x - dx[i], y + dy[i])",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x - dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx[i], y + dy[i]",
      "mutated_line": "(nx, ny) = (x * dx[i], y + dy[i])",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x * dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx[i], y + dy[i]",
      "mutated_line": "(nx, ny) = (x + dx[i], y - dy[i])",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y - dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "nx, ny = x + dx[i], y + dy[i]",
      "mutated_line": "(nx, ny) = (x + dx[i], y * dy[i])",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y * dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx > 0 and nx < n and (ny >= 0) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx > 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx < 0 and nx < n and (ny >= 0) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx < 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx == 0 and nx < n and (ny >= 0) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx == 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 0 and nx <= n and (ny >= 0) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx <= n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 0 and nx >= n and (ny >= 0) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx >= n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 0 and nx != n and (ny >= 0) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx != n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 0 and nx < n and (ny > 0) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny > 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 0 and nx < n and (ny < 0) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny < 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 0 and nx < n and (ny == 0) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny == 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 0 and nx < n and (ny >= 0) and (ny <= n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny <= n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 0 and nx < n and (ny >= 0) and (ny >= n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny >= n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 0 and nx < n and (ny >= 0) and (ny != n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny != n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(n*n)] for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dp = [[[-2 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-2 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(n*n)] for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dp = [[[-0 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-0 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(n*n)] for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dp = [[[-0 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-0 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(n*n)] for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dp = [[[--1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[--1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 1 and nx < n and (ny >= 0) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 1 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= -1 and nx < n and (ny >= 0) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= -1 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 1 and nx < n and (ny >= 0) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 1 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 0 and nx < n and (ny >= 1) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 1) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 0 and nx < n and (ny >= -1) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= -1) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if nx >= 0 and nx < n and ny >= 0 and ny < n:",
      "mutated_line": "if nx >= 0 and nx < n and (ny >= 1) and (ny < n):",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 1) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result = max(result, maxSum(i, j, 0))",
      "mutated_line": "result = max(result, maxSum(i, j, 1))",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 1))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result = max(result, maxSum(i, j, 0))",
      "mutated_line": "result = max(result, maxSum(i, j, -1))",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, -1))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result = max(result, maxSum(i, j, 0))",
      "mutated_line": "result = max(result, maxSum(i, j, 1))",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 1))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(n*n)] for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dp = [[[-1 for _ in range(n / n)] for _ in range(n)] for _ in range(n)]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n / n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(n*n)] for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dp = [[[-1 for _ in range(n + n)] for _ in range(n)] for _ in range(n)]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n + n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(n*n)] for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dp = [[[-1 for _ in range(n ** n)] for _ in range(n)] for _ in range(n)]",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n ** n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "max_path = max(max_path, maxSum(nx, ny, steps+1))",
      "mutated_line": "max_path = max(max_path, maxSum(nx, ny, steps - 1))",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps - 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "max_path = max(max_path, maxSum(nx, ny, steps+1))",
      "mutated_line": "max_path = max(max_path, maxSum(nx, ny, steps * 1))",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps * 1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "max_path = max(max_path, maxSum(nx, ny, steps+1))",
      "mutated_line": "max_path = max(max_path, maxSum(nx, ny, steps + 2))",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 2))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "max_path = max(max_path, maxSum(nx, ny, steps+1))",
      "mutated_line": "max_path = max(max_path, maxSum(nx, ny, steps + 0))",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 0))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "max_path = max(max_path, maxSum(nx, ny, steps+1))",
      "mutated_line": "max_path = max(max_path, maxSum(nx, ny, steps + 0))",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + 0))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "max_path = max(max_path, maxSum(nx, ny, steps+1))",
      "mutated_line": "max_path = max(max_path, maxSum(nx, ny, steps + -1))",
      "code": "def maxSumPathChess(grid, k):\n    n = len(grid)\n    dp = [[[-1 for _ in range(n * n)] for _ in range(n)] for _ in range(n)]\n    dx = [-1, 0, 1, 0, -1, -1, 1, 1]\n    dy = [0, 1, 0, -1, -1, 1, -1, 1]\n\n    def maxSum(x, y, steps):\n        if steps == k:\n            return grid[x][y]\n        if dp[x][y][steps] != -1:\n            return dp[x][y][steps]\n        max_path = 0\n        for i in range(8):\n            (nx, ny) = (x + dx[i], y + dy[i])\n            if nx >= 0 and nx < n and (ny >= 0) and (ny < n):\n                max_path = max(max_path, maxSum(nx, ny, steps + -1))\n        dp[x][y][steps] = max_path + grid[x][y]\n        return dp[x][y][steps]\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            result = max(result, maxSum(i, j, 0))\n    return result"
    }
  ]
}