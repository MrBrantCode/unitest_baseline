{
  "task_id": "cf_82694",
  "entry_point": "constructURL",
  "mutant_count": 32,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "netloc = subdomain + \".\" + domain + ccTLD",
      "mutated_line": "netloc = subdomain + '.' + domain - ccTLD",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain - ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "netloc = subdomain + \".\" + domain + ccTLD",
      "mutated_line": "netloc = (subdomain + '.' + domain) * ccTLD",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = (subdomain + '.' + domain) * ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if len(parsed.scheme) == 0:",
      "mutated_line": "return (False, 'Missing protocol')",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) != 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if len(parsed.netloc.split(\".\")) < 2:",
      "mutated_line": "if len(parsed.netloc.split('.')) <= 2:",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) <= 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if len(parsed.netloc.split(\".\")) < 2:",
      "mutated_line": "if len(parsed.netloc.split('.')) >= 2:",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) >= 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if len(parsed.netloc.split(\".\")) < 2:",
      "mutated_line": "if len(parsed.netloc.split('.')) != 2:",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) != 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if parsed.path == '':",
      "mutated_line": "if parsed.path != '':",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path != '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "netloc = subdomain + \".\" + domain + ccTLD",
      "mutated_line": "netloc = subdomain + '.' - domain + ccTLD",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' - domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "netloc = subdomain + \".\" + domain + ccTLD",
      "mutated_line": "netloc = (subdomain + '.') * domain + ccTLD",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = (subdomain + '.') * domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(parsed.scheme) == 0:",
      "mutated_line": "return (False, 'Missing protocol')",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 1:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(parsed.scheme) == 0:",
      "mutated_line": "return (False, 'Missing protocol')",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == -1:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(parsed.scheme) == 0:",
      "mutated_line": "return (False, 'Missing protocol')",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 1:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if len(parsed.netloc.split(\".\")) < 2:",
      "mutated_line": "if len(parsed.netloc.split('.')) < 3:",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 3:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if len(parsed.netloc.split(\".\")) < 2:",
      "mutated_line": "if len(parsed.netloc.split('.')) < 1:",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 1:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if len(parsed.netloc.split(\".\")) < 2:",
      "mutated_line": "if len(parsed.netloc.split('.')) < 0:",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 0:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if len(parsed.netloc.split(\".\")) < 2:",
      "mutated_line": "if len(parsed.netloc.split('.')) < 1:",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 1:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if len(parsed.netloc.split(\".\")) < 2:",
      "mutated_line": "if len(parsed.netloc.split('.')) < -2:",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < -2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if parsed.path == '':",
      "mutated_line": "if parsed.path == 'MUTATED':",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == 'MUTATED':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return True, None",
      "mutated_line": "return (False, None)",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (False, None)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "netloc = subdomain + \".\" + domain + ccTLD",
      "mutated_line": "netloc = subdomain - '.' + domain + ccTLD",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain - '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "netloc = subdomain + \".\" + domain + ccTLD",
      "mutated_line": "netloc = subdomain * '.' + domain + ccTLD",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain * '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))",
      "mutated_line": "url = urllib.parse.urlunparse(('', netloc, path, None, urllib.parse.urlencode(parameters), fragment))",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return False, \"Missing protocol\"",
      "mutated_line": "return (True, 'Missing protocol')",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (True, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return False, \"Missing protocol\"",
      "mutated_line": "return (False, '')",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, '')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return False, \"Invalid domain or subdomain\"",
      "mutated_line": "return (True, 'Invalid domain or subdomain')",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (True, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return False, \"Invalid domain or subdomain\"",
      "mutated_line": "return (False, '')",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, '')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return False, \"Missing resource path\"",
      "mutated_line": "return (True, 'Missing resource path')",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (True, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return False, \"Missing resource path\"",
      "mutated_line": "return (False, '')",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, '')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "netloc = subdomain + \".\" + domain + ccTLD",
      "mutated_line": "netloc = subdomain + '' + domain + ccTLD",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('.')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if len(parsed.netloc.split(\".\")) < 2:",
      "mutated_line": "if len(parsed.netloc.split('')) < 2:",
      "code": "import urllib.parse\n\ndef constructURL(subdomain, domain, ccTLD, path, parameters={}, fragment=None):\n    \"\"\"\n    Construct a URL using the given parameters.\n\n    Args:\n        subdomain (str): The subdomain of the URL.\n        domain (str): The domain of the URL.\n        ccTLD (str): The country-code top-level domain of the URL.\n        path (str): The path of the URL.\n        parameters (dict): The query parameters of the URL. Defaults to {}.\n        fragment (str): The fragment of the URL. Defaults to None.\n\n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    netloc = subdomain + '.' + domain + ccTLD\n    url = urllib.parse.urlunparse(('http', netloc, path, None, urllib.parse.urlencode(parameters), fragment))\n    return url\n\ndef validateURL(url):\n    \"\"\"\n    Validate a URL.\n\n    Args:\n        url (str): The URL to validate.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating whether the URL is valid and an error message if it's not.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    if len(parsed.scheme) == 0:\n        return (False, 'Missing protocol')\n    if len(parsed.netloc.split('')) < 2:\n        return (False, 'Invalid domain or subdomain')\n    if parsed.path == '':\n        return (False, 'Missing resource path')\n    return (True, None)"
    }
  ]
}